[
  {
    "name": "2D_Convolution",
    "requirement": "Given the C++ program below, convert it into a functionally equivalent SystemC code. The expected input consists of a 4 by 4 double matrix and a 3 by 3 double matrix.",
    "code": "#include <iostream>\nusing namespace std;\n\ndouble* conv2D(\n    const double* input, int in_h, int in_w,\n    const double* kernel, int ker_h, int ker_w)\n{\n    int pad_h = ker_h / 2;\n    int pad_w = ker_w / 2;\n    int padded_h = in_h + 2 * pad_h;\n    int padded_w = in_w + 2 * pad_w;\n    int out_h = in_h;\n    int out_w = in_w;\n\n    double* padded = new double[padded_h * padded_w]();\n    double* output = new double[out_h * out_w];\n\n    for (int i = 0; i < in_h; ++i) {\n        for (int j = 0; j < in_w; ++j) {\n            padded[(i + pad_h) * padded_w + (j + pad_w)] = input[i * in_w + j];\n        }\n    }\n\n    for (int i = 0; i < out_h; ++i) {\n        for (int j = 0; j < out_w; ++j) {\n            double sum = 0.0;\n            for (int m = 0; m < ker_h; ++m) {\n                for (int n = 0; n < ker_w; ++n) {\n                    sum += padded[(i + m) * padded_w + (j + n)]\n                         * kernel[m * ker_w + n];\n                }\n            }\n            output[i * out_w + j] = sum;\n        }\n    }\n\n    delete[] padded;\n    return output;\n}\n\nint main() {\n    const int in_h = 4, in_w = 4;\n    double input[in_h * in_w] = {\n        1, 2, 3, 4,\n        5, 6, 7, 8,\n        9, 8, 7, 6,\n        5, 4, 3, 2\n    };\n\n    const int ker_h = 3, ker_w = 3;\n    double kernel[ker_h * ker_w];\n    for (int i = 0; i < ker_h * ker_w; ++i) {\n        kernel[i] = 1.0 / 9.0;\n    }\n\n    double* result = conv2D(input, in_h, in_w, kernel, ker_h, ker_w);\n\n    cout << \"Result: \" << endl;\n    for (int i = 0; i < in_h; ++i) {\n        for (int j = 0; j < in_w; ++j) {\n            cout << result[i * in_w + j] << \" \";\n        }\n        cout << endl;\n    }\n\n    delete[] result;\n    return 0;\n}\n"
  }
]