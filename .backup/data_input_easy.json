[
  {
    "name": "MultiplyTwoMatrices",
    "requirement": "Given the C++ program below, convert it into a functionally equivalent SystemC code. The expected input consists of a 2 by 2 integer matrix and a 2 by 3 integer matrix.",
    "code": "// C++ program to multiply two matrices\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Edit MACROs here, according to your Matrix Dimensions for\n// mat1[R1][C1] and mat2[R2][C2]\n#define R1 2 // number of rows in Matrix-1\n#define C1 2 // number of columns in Matrix-1\n#define R2 2 // number of rows in Matrix-2\n#define C2 3 // number of columns in Matrix-2\n\nvoid mulMat(int mat1[][C1], int mat2[][C2])\n{\n\tint rslt[R1][C2];\n\n\tcout << \"Multiplication of given two matrices is:\\n\";\n\n\tfor (int i = 0; i < R1; i++) {\n\t\tfor (int j = 0; j < C2; j++) {\n\t\t\trslt[i][j] = 0;\n\n\t\t\tfor (int k = 0; k < R2; k++) {\n\t\t\t\trslt[i][j] += mat1[i][k] * mat2[k][j];\n\t\t\t}\n\n\t\t\tcout << rslt[i][j] << \"\\t\";\n\t\t}\n\n\t\tcout << endl;\n\t}\n}\n\n// Driver code\nint main()\n{\n\t// R1 = 4, C1 = 4 and R2 = 4, C2 = 4 (Update these\n\t// values in MACROs)\n\tint mat1[R1][C1] = { { 1, 1 }, { 2, 2 } };\n\n\tint mat2[R2][C2] = { { 1, 1, 1 }, { 2, 2, 2 } };\n\n\tif (C1 != R2) {\n\t\tcout << \"The number of columns in Matrix-1 must \"\n\t\t\t\t\"be equal to the number of rows in \"\n\t\t\t\t\"Matrix-2\"\n\t\t\t<< endl;\n\t\tcout << \"Please update MACROs according to your \"\n\t\t\t\t\"array dimension in #define section\"\n\t\t\t<< endl;\n\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t// Function call\n\tmulMat(mat1, mat2);\n\n\treturn 0;\n}\n"
  },
  {
    "name": "AddTwoMatrices",
    "requirement": "Given the C++ program below, convert it into a functionally equivalent SystemC code. The expected input consists of two 4 by 4 integer matrices.",
    "code": "// C++ program for addition of two matrices\n#include <bits/stdc++.h>\nusing namespace std;\n#define N 4\n\n// This function adds A[][] and B[][],\n// and stores the result in C[][]\nvoid add(int A[][N], int B[][N], int C[][N])\n{\n    int i, j;\n    for (i = 0; i < N; i++)\n        for (j = 0; j < N; j++)\n            C[i][j] = A[i][j] + B[i][j];\n}\n\n// Driver code\nint main()\n{\n    int A[N][N] = { { 1, 1, 1, 1 },\n                    { 2, 2, 2, 2 },\n                    { 3, 3, 3, 3 },\n                    { 4, 4, 4, 4 } };\n\n    int B[N][N] = { { 1, 1, 1, 1 },\n                    { 2, 2, 2, 2 },\n                    { 3, 3, 3, 3 },\n                    { 4, 4, 4, 4 } };\n\n    // To store the result\n    int C[N][N];\n    int i, j;\n    add(A, B, C);\n\n    cout << \"Result matrix is \" << endl;\n    for (i = 0; i < N; i++) {\n        for (j = 0; j < N; j++)\n            cout << C[i][j] << \" \";\n        cout << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "name": "RotateMatrixElementsofaMatrix",
    "requirement": "Given the C++ program below, convert it into a functionally equivalent SystemC code. The expected input consists of a 4 by 4 integer matrix.",
    "code": "// C++ program to rotate a matrix \n#include <iostream> \n#define R 4 \n#define C 4 \nusing namespace std; \n\n// A function to rotate a matrix \n// mat[][] of size R x C. \n// Initially, m = R and n = C \nvoid rotatematrix(int m, int n, \n\t\t\t\tint mat[R][C]) \n{ \n\tint row = 0, col = 0; \n\tint prev, curr; \n\n\t/* row - Starting row index \n\tm - ending row index \n\tcol - starting column index \n\tn - ending column index \n\ti - iterator */\n\twhile (row < m && col < n) \n\t{ \n\t\tif (row + 1 == m || \n\t\t\tcol + 1 == n) \n\t\t\tbreak; \n\n\t\t// Store the first element of \n\t\t// next row, this element will \n\t\t// replace first element of current \n\t\t// row \n\t\tprev = mat[row + 1][col]; \n\n\t\t/* Move elements of first row from \n\t\tthe remaining rows */\n\t\tfor (int i = col; i < n; i++) \n\t\t{ \n\t\t\tcurr = mat[row][i]; \n\t\t\tmat[row][i] = prev; \n\t\t\tprev = curr; \n\t\t} \n\t\trow++; \n\n\t\t/* Move elements of last column \n\t\tfrom the remaining columns */\n\t\tfor (int i = row; i < m; i++) \n\t\t{ \n\t\t\tcurr = mat[i][n-1]; \n\t\t\tmat[i][n-1] = prev; \n\t\t\tprev = curr; \n\t\t} \n\t\tn--; \n\n\t\t/* Move elements of last row from \n\t\tthe remaining rows */\n\t\tif (row < m) \n\t\t{ \n\t\t\tfor (int i = n-1; i >= col; i--) \n\t\t\t{ \n\t\t\t\tcurr = mat[m-1][i]; \n\t\t\t\tmat[m-1][i] = prev; \n\t\t\t\tprev = curr; \n\t\t\t} \n\t\t} \n\t\tm--; \n\n\t\t/* Move elements of first column from \n\t\tthe remaining rows */\n\t\tif (col < n) \n\t\t{ \n\t\t\tfor (int i = m-1; i >= row; i--) \n\t\t\t{ \n\t\t\t\tcurr = mat[i][col]; \n\t\t\t\tmat[i][col] = prev; \n\t\t\t\tprev = curr; \n\t\t\t} \n\t\t} \n\t\tcol++; \n\t} \n\n\t// Print rotated matrix \n\tfor (int i=0; i<R; i++) \n\t{ \n\t\tfor (int j=0; j<C; j++) \n\t\tcout << mat[i][j] << \" \"; \n\t\tcout << endl; \n\t} \n} \n\n// Driver code \nint main() \n{ \n\t// Test Case 1 \n\tint a[R][C] = {{1, 2, 3, 4}, \n\t\t\t\t{5, 6, 7, 8}, \n\t\t\t\t{9, 10, 11, 12}, \n\t\t\t\t{13, 14, 15, 16}}; \n\n\t// Test Case 2 \n\t/* int a[R][C] = {{1, 2, 3}, \n\t\t\t\t\t{4, 5, 6}, \n\t\t\t\t\t{7, 8, 9}}; \n\t*/ rotatematrix(R, C, a); \n\treturn 0; \n} \n"
  },
  {
    "name": "InterchangeElementsofFirstAndLastRowsinMatrix",
    "requirement": "Given the C++ program below, convert it into a functionally equivalent SystemC code. The expected input consists of a 4 by 4 integer matrix.",
    "code": "// C++ code to swap the element of first \n// and last column and display the result \n#include <iostream> \nusing namespace std; \n\n#define n 4 \n\nvoid interchangeFirstLast(int m[][n]) \n{ \n\t// swapping of element between first \n\t// and last columns \n\tfor (int i = 0; i < n; i++) \n\t{ \n\t\tint t = m[i][0]; \n\t\tm[i][0] = m[i][n - 1]; \n\t\tm[i][n - 1] = t; \n\t} \n} \n\n// Driver function \nint main() \n{ \n\t// input in the array \n\tint m[n][n] = {{8, 9, 7, 6}, \n\t\t\t\t{4, 7, 6, 5}, \n\t\t\t\t{3, 2, 1, 8}, \n\t\t\t\t{9, 9, 7, 7}}; \n\n\tinterchangeFirstLast(m); \n\n\t// printing the interchanged matrix \n\tfor (int i = 0; i < n; i++) \n\t{ \n\t\tfor (int j = 0; j < n; j++) \n\t\t\tcout << m[i][j] << \" \"; \n\t\tcout << endl; \n\t} \n} \n"
  },
  {
    "name": "FindtheDeterminantofaMatrix",
    "requirement": "Given the C++ program below, convert it into a functionally equivalent SystemC code. The expected input consists of a 4 by 4 double matrix.",
    "code": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nconst int MAXN = 105;\ndouble a[MAXN][MAXN];\n\ndouble determinant(int n) {\n\tdouble det = 1.0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint pivot = i;\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tif (abs(a[j][i]) > abs(a[pivot][i])) {\n\t\t\t\tpivot = j;\n\t\t\t}\n\t\t}\n\t\tif (pivot != i) {\n\t\t\tswap(a[i], a[pivot]);\n\t\t\tdet *= -1;\n\t\t}\n\t\tif (a[i][i] == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tdet *= a[i][i];\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tdouble factor = a[j][i] / a[i][i];\n\t\t\tfor (int k = i + 1; k < n; k++) {\n\t\t\t\ta[j][k] -= factor * a[i][k];\n\t\t\t}\n\t\t}\n\t}\n\treturn det;\n}\n\nint main() {\n\tint n = 4;\n\tdouble matrix[4][4] = {{1, 0, 2, -1},\n\t\t\t\t\t\t{3, 0, 0, 5},\n\t\t\t\t\t\t{2, 1, 4, -3},\n\t\t\t\t\t\t{1, 0, 5, 0}};\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\ta[i][j] = matrix[i][j];\n\t\t}\n\t}\n\tdouble det = determinant(n);\n\tcout << \"Determinant = \" << det << endl;\n\treturn 0;\n}\n"
  },
  {
    "name": "NumberofUniqueTripletsWhoseXORisZero",
    "requirement": "Given the C++ program below, convert it into a functionally equivalent SystemC code. The expected input consists of a 6-element integer array.",
    "code": "// CPP program to count the number of\n// unique triplets whose XOR is 0\n#include <bits/stdc++.h>\nusing namespace std;\n\n// function to count the number of \n// unique triplets whose xor is 0\nint countTriplets(int a[], int n) \n{\n\t// To store values that are present\n\tunordered_set<int> s;\n\tfor (int i = 0; i < n; i++)\n\t\ts.insert(a[i]);\n\t\n\t// stores the count of unique triplets\n\tint count = 0;\n\t\n\t// traverse for all i, j pairs such that j>i\n\tfor (int i = 0; i < n-1; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\n\t\t// xor of a[i] and a[j]\n\t\tint xr = a[i] ^ a[j];\n\t\n\t\t// if xr of two numbers is present, \n\t\t// then increase the count\n\t\tif (s.find(xr) != s.end() && xr != a[i] && \n\t\t\t\t\t\t\t\t\txr != a[j])\n\t\t\tcount++;\n\t\t}\n\t}\n\t\n\t// returns answer\n\treturn count / 3;\n}\n\n// Driver code to test above function\nint main() \n{\n\tint a[] = {1, 3, 5, 10, 14, 15};\n\tint n = sizeof(a) / sizeof(a[0]); \n\tcout << countTriplets(a, n); \n\treturn 0;\n}\n"
  },
  {
    "name": "MergeSort",
    "requirement": "Given the C++ program below, convert it into a functionally equivalent SystemC code. The expected input consists of a 6-element integer array.",
    "code": "// C++ program for the implementation of merge sort\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Merges two subarrays of vec.\n// First subarray is vec[left..mid]\n// Second subarray is vec[mid+1..right]\nvoid merge(vector<int>& vec, int left, int mid, int right) {\n    int i, j, k;\n    int n1 = mid - left + 1;\n    int n2 = right - mid;\n\n    // Create temporary vectors\n    vector<int> leftVec(n1), rightVec(n2);\n\n    // Copy data to temporary vectors\n    for (i = 0; i < n1; i++)\n        leftVec[i] = vec[left + i];\n    for (j = 0; j < n2; j++)\n        rightVec[j] = vec[mid + 1 + j];\n\n    // Merge the temporary vectors back into vec[left..right]\n    i = 0;\n    j = 0;\n    k = left;\n    while (i < n1 && j < n2) {\n        if (leftVec[i] <= rightVec[j]) {\n            vec[k] = leftVec[i];\n            i++;\n        } else {\n            vec[k] = rightVec[j];\n            j++;\n        }\n        k++;\n    }\n\n    // Copy the remaining elements of leftVec[], if any\n    while (i < n1) {\n        vec[k] = leftVec[i];\n        i++;\n        k++;\n    }\n\n    // Copy the remaining elements of rightVec[], if any\n    while (j < n2) {\n        vec[k] = rightVec[j];\n        j++;\n        k++;\n    }\n}\n\n// The subarray to be sorted is in the index range [left..right]\nvoid mergeSort(vector<int>& vec, int left, int right) {\n    if (left < right) {\n      \n        // Calculate the midpoint\n        int mid = left + (right - left) / 2;\n\n        // Sort first and second halves\n        mergeSort(vec, left, mid);\n        mergeSort(vec, mid + 1, right);\n\n        // Merge the sorted halves\n        merge(vec, left, mid, right);\n    }\n}\n\nint main() {\n    vector<int> vec = {12, 11, 13, 5, 6, 7};\n    int n = vec.size();\n\n    // Sorting vec using mergesort\n    mergeSort(vec, 0, n - 1);\n\n    for (auto i: vec)\n        cout << i << \" \";\n    return 0;\n}\n"
  },
  {
    "name": "SortanArray_BubbleSort",
    "requirement": "Given the C++ program below, convert it into a functionally equivalent SystemC code. The expected input consists of a 6-element integer array.",
    "code": "// C program for implementation of Bubble sort\n#include <stdio.h>\n\nvoid swap(int* arr, int i, int j) {\n    int temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n}\n\nvoid bubbleSort(int arr[], int n) {\n    for (int i = 0; i < n - 1; i++) {\n      \n        // Last i elements are already in place, so the loop\n        // will only num n - i - 1 times\n        for (int j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[j + 1])\n                swap(arr, j, j + 1);\n        }\n    }\n}\n\nint main() {\n    int arr[] = { 6, 0, 3, 5 };\n    int n = sizeof(arr) / sizeof(arr[0]);\n\n    // Calling bubble sort on array arr\n    bubbleSort(arr, n);\n\n    for (int i = 0; i < n; i++)\n        printf(\"%d \", arr[i]);\n\n    return 0;\n}\n"
  },
  {
    "name": "SearchanElementinanArray_BinarySearch",
    "requirement": "Given the C++ program below, convert it into a functionally equivalent SystemC code. The expected input consists of a 6-element integer array and an integer number.",
    "code": "// C++ program to implement iterative \n// binary search\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool binarySearch(vector<int>& v, int target) {\n    \n      // Defining the part of the vector to be\n      // searched\n    int low = 0, high = v.size() - 1;\n      \n      // Till the element is found or vector cannot\n      // be divided into more parts\n    while (low <= high) {\n      \n          // Finding mid point\n        int mid = ((high - low) / 2) + low;\n\n        // If the middle element is equal to target\n        if (v[mid] == target) {\n            return true;\n        }\n\n        // If the middle element is greater than \n        // target, search in the left half \n        if (v[mid] > target)\n            high = mid - 1;\n        \n        // If the middle element is smaller than\n        // target, search the right half \n        else\n            low = mid + 1;\n    }\n      \n      // If we don't find the target\n      return false;\n}\n\nint main() {\n    vector<int> v = {1, 2, 3, 4, 5, 8, 9, 11};\n    \n      // Element to be searched\n      int target = 8;\n  \n      // Searching the target element\n    if (binarySearch(v, target)) {\n        cout << target << \" found.\";\n    } else {\n        cout << target << \" NOT found.\";\n    }\n    return 0;\n}\n"
  },
  {
    "name": "ArrayRotation",
    "requirement": "Given the C++ program below, convert it into a functionally equivalent SystemC code. The expected input consists of a 6-element integer array and a integer.",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to rotate array\nvoid Rotate(int arr[], int d, int n)\n{\n\t// Storing rotated version of array\n\tint temp[n];\n\n\t// Keeping track of the current index\n\t// of temp[]\n\tint k = 0;\n\n\t// Storing the n - d elements of\n\t// array arr[] to the front of temp[]\n\tfor (int i = d; i < n; i++) {\n\t\ttemp[k] = arr[i];\n\t\tk++;\n\t}\n\n\t// Storing the first d elements of array arr[]\n\t// into temp\n\tfor (int i = 0; i < d; i++) {\n\t\ttemp[k] = arr[i];\n\t\tk++;\n\t}\n\n\t// Copying the elements of temp[] in arr[]\n\t// to get the final rotated array\n\tfor (int i = 0; i < n; i++) {\n\t\tarr[i] = temp[i];\n\t}\n}\n\n// Function to print elements of array\nvoid PrintTheArray(int arr[], int n)\n{\n\tfor (int i = 0; i < n; i++) {\n\t\tcout << arr[i] << \" \";\n\t}\n}\n\n// Driver code\nint main()\n{\n\tint arr[] = { 1, 2, 3, 4, 5, 6, 7 };\n\tint N = sizeof(arr) / sizeof(arr[0]);\n\tint d = 2;\n\n\t// Function calling\n\tRotate(arr, d, N);\n\tPrintTheArray(arr, N);\n\n\treturn 0;\n}\n"
  },
  {
    "name": "CopyAlltheElementsofOneArraytoAnotherintheReverseOrder",
    "requirement": "Given the C++ program below, convert it into a functionally equivalent SystemC code. The expected input consists of a 6-element integer array.",
    "code": "// C program to copy the contents \n// of one array into another \n// in the reverse order \n\n#include <stdio.h> \n\n// Function to print the array \nvoid printArray(int arr[], int len) \n{ \n\tint i; \n\tfor (i = 0; i < len; i++) { \n\t\tprintf(\"%d \", arr[i]); \n\t} \n} \n\n// Driver code \nint main() \n{ \n\tint original_arr[] = {1, 2, 3, 4, 5}; \n\tint len = sizeof(original_arr)/sizeof(original_arr[0]); \n\n\tint copied_arr[len], i, j; \n\t\n\t// Copy the elements of the array \n\t// in the copied_arr in Reverse Order \n\tfor (i = 0; i < len; i++) { \n\t\tcopied_arr[i] = original_arr[len - i - 1]; \n\t} \n\n\t// Print the original_arr \n\tprintf(\" Original array: \"); \n\tprintArray(original_arr, len); \n\n\t// Print the copied array \n\tprintf(\" Resultant array: \"); \n\tprintArray(copied_arr, len); \n\n\treturn 0; \n} \n"
  },
  {
    "name": "AddTwoBinaryStrings",
    "requirement": "Given the C++ program below, convert it into a functionally equivalent SystemC code. The expected input consists of two 8-bit strings.",
    "code": "// C++ program to add two binary strings \n#include <bits/stdc++.h> \nusing namespace std; \n\n// This function adds two binary strings and return result as a third string \nstring addBinary(string A, string B) \n{ \n\t// If the length of string A is greater \n\t// than the length of B then just swap \n\t// the string by calling the same \n\t// function and make sure to return \n\t// the function otherwise recursion \n\t// will occur which leads to calling \n\t// the same function twice \n\tif (A.length() > B.length()) \n\t\treturn addBinary(B, A); \n\n\t// Calculating the difference between \n\t// the length of the two strings. \n\tint diff = B.length() - A.length(); \n\n\t// Initialise the padding string which \n\t// is used to store zeroes that should \n\t// be added as prefix to the string which \n\t// has length smaller than the other string. \n\tstring padding; \n\tfor (int i = 0; i < diff; i++) \n\t\tpadding.push_back('0'); \n\n\tA = padding + A; \n\tstring res; \n\tchar carry = '0'; \n\n\tfor (int i = A.length() - 1; i >= 0; i--) \n\t{ \n\t\t// This if condition solves 110 111 \n\t\t// possible cases \n\t\tif (A[i] == '1' && B[i] == '1') \n\t\t{ \n\t\t\tif (carry == '1') \n\t\t\t\tres.push_back('1'), carry = '1'; \n\t\t\telse\n\t\t\t\tres.push_back('0'), carry = '1'; \n\t\t} \n\n\t\t// This if condition solves 000 001 \n\t\t// possible cases \n\t\telse if (A[i] == '0' && B[i] == '0') \n\t\t{ \n\t\t\tif (carry == '1') \n\t\t\t\tres.push_back('1'), carry = '0'; \n\t\t\telse\n\t\t\t\tres.push_back('0'), carry = '0'; \n\t\t} \n\n\t\t// This if condition solves 100 101 010 \n\t\t// 011 possible cases \n\t\telse if (A[i] != B[i]) \n\t\t{ \n\t\t\tif (carry == '1') \n\t\t\t\tres.push_back('0'), carry = '1'; \n\t\t\telse\n\t\t\t\tres.push_back('1'), carry = '0'; \n\t\t} \n\t} \n\n\t// If at the end their is carry then just \n\t// add it to the result \n\tif (carry == '1') \n\t\tres.push_back(carry); \n\t// reverse the result \n\treverse(res.begin(), res.end()); \n\n\t// To remove leading zeroes \n\tint index = 0; \n\twhile (index + 1 < res.length() && \n\t\tres[index] == '0') \n\t\tindex++; \n\treturn (res.substr(index)); \n} \n\n// Driver code \nint main() \n{ \n\tstring a = \"1101\", b = \"100\"; \n\tcout << addBinary(a, b) << endl; \n\treturn 0; \n}\n"
  },
  {
    "name": "BinarytoDecimalConversion",
    "requirement": "Given the C++ program below, convert it into a functionally equivalent SystemC code. The expected input consists of a binary integer.",
    "code": "// C++ program to convert binary to decimal \n#include <iostream> \nusing namespace std; \n\n// Function to convert binary \n// to decimal \nint binaryToDecimal(int n) \n{ \n\tint num = n; \n\tint dec_value = 0; \n\n\t// Initializing base value to \n\t// 1, i.e 2^0 \n\tint base = 1; \n\n\tint temp = num; \n\twhile (temp) { \n\t\tint last_digit = temp % 10; \n\t\ttemp = temp / 10; \n\t\tdec_value += last_digit * base; \n\t\tbase = base * 2; \n\t} \n\n\treturn dec_value; \n} \n\n// Driver code \nint main() \n{ \n\tint num = 10101001; \n\tcout << binaryToDecimal(num) << endl; \n}\n"
  },
  {
    "name": "FindGCD",
    "requirement": "Given the C++ program below, convert it into a functionally equivalent SystemC code. The expected input consists of two integer numbers.",
    "code": "// C++ program to find GCD of two numbers using simple arithmetic\n#include <bits/stdc++.h>\nusing namespace std;\n\nint gcd(int a, int b) {\n    // Find Minimum of a and b\n    int res = min(a, b);\n\n      // Testing divisiblity with all numbers starting from\n    // min(a, b) to 1\n\n    while (res > 1) {\n\n        // If any number divide both a and b, so we\n        // got the answer\n        if (a % res == 0 && b % res == 0)\n            break;\n        res--;\n    }\n    return res;\n}\n\nint main() {\n    int a = 12, b = 16;\n  \n    // Finding gcd of two numbers a and b\n\n\n    cout << gcd(a, b);\n    return 0;\n}\n"
  },
  {
    "name": "FindLCM",
    "requirement": "Given the C++ program below, convert it into a functionally equivalent SystemC code. The expected input consists of two integer numbers.",
    "code": "// C++ program to find the LCM of two\n// numbers using the if statement and\n// while loop\n#include <iostream>\nusing namespace std;\n\n// Driver code\nint main()\n{\n\tint a = 15, b = 20, max_num, flag = 1;\n\n\t// Use ternary operator to get the\n\t// large number\n\tmax_num = (a > b) ? a : b;\n\n\twhile (flag) {\n\t\t// if statement checks max_num is completely\n\t\t// divisible by n1 and n2.\n\t\tif (max_num % a == 0 && max_num % b == 0) {\n\t\t\tcout << \"LCM of \" << a << \" and \" << b << \" is \"\n\t\t\t\t<< max_num;\n\t\t\tbreak;\n\t\t}\n\n\t\t// update by 1 on each iteration\n\t\t++max_num;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "name": "FindFactorialofaNumber",
    "requirement": "Given the C++ program below, convert it into a functionally equivalent SystemC code. The expected input consists of a integer number.",
    "code": "// C++ program for factorial of a number\n#include <iostream>\nusing namespace std;\n\n// Function to find factorial of\n// given number\nunsigned int factorial(unsigned int n)\n{\n\tint res = 1, i;\n\tfor (i = 2; i <= n; i++)\n\t\tres *= i;\n\treturn res;\n}\n\n// Driver code\nint main()\n{\n\tint num = 5;\n\tcout << \"Factorial of \" << num << \" is \"\n\t\t<< factorial(num) << endl;\n\treturn 0;\n}\n"
  },
  {
    "name": "FibonacciNumber",
    "requirement": "Given the C++ program below, convert it into a functionally equivalent SystemC code. The expected input consists of a integer number.",
    "code": "// C++ Program to find the nth fibonacci number using loops\n#include <bits/stdc++.h>\nusing namespace std;\n\nint fib(int n) {\n  \n      // For 0th and 1st term\n    if (n <= 1)\n        return n;\n    \n      // Variable to store the last two terms\n    int prev1 = 1, prev2 = 0;\n      \n      // Variable that stores the current fibonacci term\n      int curr;\n\n    // Calculating the next fibonacci number by using\n      // the previous two number\n    for (int i = 2; i <= n; i++) {\n        curr = prev1 + prev2;\n        prev2 = prev1;\n        prev1 = curr;\n    }\n    return curr;\n}\n\nint main() {\n    int n = 5;\n    \n      // Finding the nth fibonacci number\n    cout << fib(n);\n    return 0;\n}\n"
  },
  {
    "name": "FindPowerWithoutUsingMultiplicationAndDivisionOperators",
    "requirement": "Given the C++ program below, convert it into a functionally equivalent SystemC code. The expected input consists of two integer numbers.",
    "code": "// C++ code for power function \n#include <bits/stdc++.h> \nusing namespace std; \n\n// Works only if a >= 0 \n// and b >= 0 \nint pow(int a, int b) \n{ \n\tif (b == 0) \n\t\treturn 1; \n\tint answer = a; \n\tint increment = a; \n\tint i, j; \n\tfor(i = 1; i < b; i++) \n\t{ \n\t\tfor(j = 1; j < a; j++) \n\t\t{ \n\t\t\tanswer += increment; \n\t\t} \n\t\tincrement = answer; \n\t} \n\treturn answer; \n} \n\n// Driver Code \nint main() \n{ \n\tcout << pow(5, 3); \n\treturn 0; \n} \n\n// This code is contributed by rathbhupendra \n"
  },
  {
    "name": "CheckWhetheraNumberisPrimeorNot",
    "requirement": "Given the C++ program below, convert it into a functionally equivalent SystemC code. The expected input consists of a integer number.",
    "code": "// C++ Program to check for prime number using Simple Trial Division\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int n = 29;\n\n    int cnt = 0;\n\n    // If number is less than/equal to 1,\n    // it is not prime\n    if (n <= 1)\n        cout << n << \" is NOT prime\" << endl;\n    else {\n\n        // Check for divisors from 1 to n\n        for (int i = 1; i <= n; i++) {\n\n            // Check how many number is divisible\n            // by n\n            if (n % i == 0)\n                cnt++;\n        }\n\n        // If n is divisible by more than 2 numbers\n        // then it is not prime\n        if (cnt > 2)\n            cout << n << \" is NOT prime\" << endl;\n\n        // else it is prime\n        else\n            cout << n << \" is prime\" << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "name": "CheckWhetheraNumberCanbeExpressedasSumofTwoPrimeNumbers",
    "requirement": "Given the C++ program below, convert it into a functionally equivalent SystemC code. The expected input consists of a integer number.",
    "code": "// C++ program to check if a prime number can be expressed as sum of two Prime Numbers \n#include <bits/stdc++.h> \nusing namespace std; \n\n// Function to check whether \n// a number is prime or not \nbool isPrime(int n) \n{ \n\tif (n <= 1) \n\t\treturn false; \n\n\tfor (int i = 2; i <= sqrt(n); i++) \n\t{ \n\t\tif (n % i == 0) \n\t\t\treturn false; \n\t} \n\n\treturn true; \n} \n\n// Function to check if a prime number \n// can be expressed as sum of \n// two Prime Numbers \nbool isPossible(int N) \n{ \n\t// if the number is prime, \n\t// and number-2 is also prime \n\tif (isPrime(N) && isPrime(N - 2)) \n\t\treturn true; \n\telse\n\t\treturn false; \n} \n\n// Driver code \nint main() \n{ \n\tint n = 13; \n\n\tif (isPossible(n)) \n\t\tcout << \"Yes\"; \n\telse\n\t\tcout << \"No\"; \n\n\treturn 0; \n} \n"
  }
]