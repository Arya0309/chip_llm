[
    {
        "task_id":1,
        "task":"DecimaltoHexadecimalConversion",
        "code":"\/\/ C++ program to convert a decimal number to hexadecimal number \n#include <iostream> \nusing namespace std; \n\n\/\/ Function to convert decimal to hexadecimal \nvoid decToHexa(int n) \n{ \n\t\/\/ char array to store hexadecimal number \n\tchar hexaDeciNum[100]; \n\n\t\/\/ Counter for hexadecimal number array \n\tint i = 0; \n\twhile (n != 0) { \n\t\t\/\/ Temporary variable to store remainder \n\t\tint temp = 0; \n\n\t\t\/\/ Storing remainder in temp variable. \n\t\ttemp = n % 16; \n\n\t\t\/\/ Check if temp < 10 \n\t\tif (temp < 10) { \n\t\t\thexaDeciNum[i] = temp + 48; \n\t\t\ti++; \n\t\t} \n\t\telse { \n\t\t\thexaDeciNum[i] = temp + 55; \n\t\t\ti++; \n\t\t} \n\n\t\tn = n \/ 16; \n\t} \n\n\t\/\/ Printing hexadecimal number \n\t\/\/ array in reverse order \n\tfor (int j = i - 1; j >= 0; j--) \n\t\tcout << hexaDeciNum[j]; \n} \n\n\/\/ Driver code \nint main() \n{ \n\tint n = 2545; \n\tdecToHexa(n); \n\treturn 0; \n}\n",
        "category":"Basic Math Operations",
        "sub_category":"Number Base Conversion",
        "adoption":false,
        "reason":"Involves string",
        "module_name":null,
        "testbench":null,
        "signal":null,
        "prompt":null
    },
    {
        "task_id":2,
        "task":"SortanArray_InsertionSort",
        "code":"\/\/ C++ program to sort \n\/\/ 2D matrix row-wise\n#include<bits\/stdc++.h>\nusing namespace std;\n\nvoid sortRowWise(int m[][4],\n\t\t\t\tint r, int c)\n{\n\/\/ Loop for rows of matrix\nfor (int i = 0; i < r; i++) \n{\n\t\/\/ Loop for column of matrix\n\tfor (int j = 0; j < c; j++) \n\t{\n\t\/\/ Loop for comparison and swapping\n\tfor (int k = 0; k < c - j - 1; k++) \n\t{\n\t\tif (m[i][k] > m[i][k + 1]) \n\t\t{\n\t\t\/\/ Swapping of elements\n\t\tswap(m[i][k], m[i][k + 1]);\n\t\t}\n\t}\n\t}\n}\n\n\/\/ Printing the sorted matrix\nfor (int i = 0; i < r; i++) \n{\n\tfor (int j = 0; j < c; j++)\n\tcout << m[i][j] << \" \";\n\tcout << endl;\n}\n}\n\n\/\/ Driver code\nint main()\n{\nint m[][4] = {{9, 8, 7, 1},\n\t\t\t\t{7, 3, 0, 2},\n\t\t\t\t{9, 5, 3, 2},\n\t\t\t\t{6, 3, 1, 2}};\nint c = sizeof(m[0]) \/ sizeof(m[0][0]);\nint r = sizeof(m) \/ sizeof(m[0]);\nsortRowWise(m, r, c);\nreturn 0;\n}\n",
        "category":"Array Operations",
        "sub_category":"Array Sorting",
        "adoption":false,
        "reason":"Weird code",
        "module_name":null,
        "testbench":null,
        "signal":null,
        "prompt":null
    },
    {
        "task_id":3,
        "task":"PrintMultiplicationTableofaNumber",
        "code":"\/\/ C++ program to print table\n\/\/ of a number\n#include <iostream>\nusing namespace std;\n\n\/\/ Driver code\nint main()\n{\n\t\/\/ Change here to change output\n\tint n = 5;\n\tfor (int i = 1; i <= 10; ++i)\n\t\tcout << n << \" * \" << i << \" = \" << n * i << endl;\n\treturn 0;\n}\n",
        "category":"Miscellaneous",
        "sub_category":"Miscellaneous",
        "adoption":false,
        "reason":null,
        "module_name":null,
        "testbench":null,
        "signal":null,
        "prompt":null
    },
    {
        "task_id":4,
        "task":"CopyAlltheElementsofOneArraytoAnotherintheReverseOrder",
        "code":"\/\/ C program to copy the contents \n\/\/ of one array into another \n\/\/ in the reverse order \n\n#include <stdio.h> \n\n\/\/ Function to print the array \nvoid printArray(int arr[], int len) \n{ \n\tint i; \n\tfor (i = 0; i < len; i++) { \n\t\tprintf(\"%d \", arr[i]); \n\t} \n} \n\n\/\/ Driver code \nint main() \n{ \n\tint original_arr[] = {1, 2, 3, 4, 5}; \n\tint len = sizeof(original_arr)\/sizeof(original_arr[0]); \n\n\tint copied_arr[len], i, j; \n\t\n\t\/\/ Copy the elements of the array \n\t\/\/ in the copied_arr in Reverse Order \n\tfor (i = 0; i < len; i++) { \n\t\tcopied_arr[i] = original_arr[len - i - 1]; \n\t} \n\n\t\/\/ Print the original_arr \n\tprintf(\" Original array: \"); \n\tprintArray(original_arr, len); \n\n\t\/\/ Print the copied array \n\tprintf(\" Resultant array: \"); \n\tprintArray(copied_arr, len); \n\n\treturn 0; \n} \n",
        "category":"Array Operations",
        "sub_category":"Array Processing",
        "adoption":true,
        "reason":null,
        "module_name":"ArrayReverse",
        "testbench":"SC_MODULE(Testbench) {\n    sc_clock clk;          \/\/ Clock signal for synchronization\n    sc_signal<bool> start; \/\/ Signal to trigger the reversal\n    sc_signal<bool> done;  \/\/ Signal indicating the reversal is complete\n\n    \/\/ Instance of the ArrayReverse module\n    ArrayReverse* array_rev_inst;\n\n    SC_CTOR(Testbench) : clk(\"clk\", 1, SC_NS) {\n        array_rev_inst = new ArrayReverse(\"array_rev_inst\");\n        array_rev_inst->clk(clk);\n        array_rev_inst->start(start);\n        array_rev_inst->done(done);\n\n        SC_THREAD(run_tests);\n    }\n\n    \/\/ Process to run the test cases.\n    void run_tests() {\n        \/\/ Initialize the original array with fixed values {1, 2, 3, 4, 5}\n        int original[5] = {1, 2, 3, 4, 5};\n        \/\/ Expected reversed result is {5, 4, 3, 2, 1}\n        int expected[5] = {5, 4, 3, 2, 1};\n\n        \/\/ Load the original array into the ArrayReverse module.\n        array_rev_inst->load_array(original);\n\n        \/\/ Trigger the reversal process.\n        start.write(true);\n        wait(1, SC_NS); \/\/ Wait for one clock cycle.\n        start.write(false);\n\n        \/\/ Wait until the module signals that the reversal is done.\n        while (done.read() != true) {\n            wait(1, SC_NS);\n        }\n        \n        \/\/ Retrieve the reversed array.\n        int result[5];\n        array_rev_inst->read_array(result);\n\n        \/\/ Print the original and reversed arrays.\n        cout << \"Original Array: \";\n        for (int i = 0; i < 5; i++) {\n            cout << original[i] << \" \";\n        }\n        cout << \"\\nReversed Array: \";\n        for (int i = 0; i < 5; i++) {\n            cout << result[i] << \" \";\n        }\n        cout << endl;\n\n        \/\/ Verify that the reversed array matches the expected result.\n        for (int i = 0; i < 5; i++) {\n            assert(result[i] == expected[i]);\n        }\n        cout << \"All tests passed successfully.\" << endl;\n\n        sc_stop(); \/\/ End the simulation.\n    }\n};\n\n\/\/ sc_main: Entry point for the SystemC simulation.\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); \/\/ Create the testbench instance.\n    sc_start();         \/\/ Start the simulation.\n    return 0;\n}\n",
        "signal":"sc_in<bool> clk;\nsc_in<bool> start;\nsc_out<bool> done;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input. \n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<bool> clk;\nsc_in<bool> start;\nsc_out<bool> done;\n> **Note**: Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n\n**C++\/C Code**:\n```\n\/\/ C program to copy the contents \n\/\/ of one array into another \n\/\/ in the reverse order \n\n#include <stdio.h> \n\n\/\/ Function to print the array \nvoid printArray(int arr[], int len) \n{ \n\tint i; \n\tfor (i = 0; i < len; i++) { \n\t\tprintf(\"%d \", arr[i]); \n\t} \n} \n\n\/\/ Driver code \nint main() \n{ \n\tint original_arr[] = {1, 2, 3, 4, 5}; \n\tint len = sizeof(original_arr)\/sizeof(original_arr[0]); \n\n\tint copied_arr[len], i, j; \n\t\n\t\/\/ Copy the elements of the array \n\t\/\/ in the copied_arr in Reverse Order \n\tfor (i = 0; i < len; i++) { \n\t\tcopied_arr[i] = original_arr[len - i - 1]; \n\t} \n\n\t\/\/ Print the original_arr \n\tprintf(\" Original array: \"); \n\tprintArray(original_arr, len); \n\n\t\/\/ Print the copied array \n\tprintf(\" Resultant array: \"); \n\tprintArray(copied_arr, len); \n\n\treturn 0; \n} \n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\n#include <systemc.h>\n\n\/\/ BubbleSort Module: Implements the bubble sort algorithm\nSC_MODULE(BubbleSort) {\n    sc_in<bool> clk;      \/\/ Clock input\n    sc_in<bool> start;    \/\/ Signal to start sorting\n    sc_out<bool> done;    \/\/ Signal to indicate sorting is complete\n\n    \/\/ Internal storage for the array (fixed size of 4 elements)\n    int arr[4];\n\n    \/\/ Constructor: register the process\n    SC_CTOR(BubbleSort) {\n        SC_THREAD(sort_process);\n        sensitive << clk.pos();\n    }\n\n    \/\/ Process that waits for the start signal and performs sorting\n    void sort_process() {\n        while (true) {\n            wait(); \/\/ wait for a clock cycle\n            if (start.read() == true) {\n                bubbleSort(); \/\/ perform sorting\n                done.write(true);\n                wait(); \/\/ wait for one cycle to signal completion\n                done.write(false);\n            }\n        }\n    }\n\n    \/\/ Bubble sort algorithm implementation (sorts the internal array)\n    void bubbleSort() {\n        \/\/ Number of elements is fixed at 4\n        const int n = 4;\n        for (int i = 0; i < n - 1; i++) {\n            for (int j = 0; j < n - i - 1; j++) {\n                if (arr[j] > arr[j + 1]) {\n                    \/\/ Swap arr[j] and arr[j+1]\n                    int temp = arr[j];\n                    arr[j] = arr[j + 1];\n                    arr[j + 1] = temp;\n                }\n            }\n        }\n    }\n\n    \/\/ Helper method to load an input array into the module\n    void load_array(const int input[4]) {\n        for (int i = 0; i < 4; i++) {\n            arr[i] = input[i];\n        }\n    }\n\n    \/\/ Helper method to read the sorted array from the module\n    void read_array(int output[4]) {\n        for (int i = 0; i < 4; i++) {\n            output[i] = arr[i];\n        }\n    }\n};\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":5,
        "task":"CalculateSumofFirstnNaturalNumbers",
        "code":"\/\/ C++ program to find sum of first n natural numbers. \n#include <iostream> \nusing namespace std; \n\n\/\/ Returns sum of first n natural \n\/\/ numbers \nint findSum(int n) \n{ \n\tint sum = 0; \n\tfor (int i = 1; i <= n; i++) \n\t\tsum = sum + i; \n\treturn sum; \n} \n\n\/\/ Driver code \nint main() \n{ \n\tint n = 5; \n\tcout << findSum(n); \n\treturn 0; \n}\n",
        "category":"Basic Math Operations",
        "sub_category":"Basic Math Operations",
        "adoption":true,
        "reason":null,
        "module_name":"SumCalculator",
        "testbench":"SC_MODULE(Testbench) {\n    sc_signal<unsigned int> n_sig;    \/\/ Signal for the number of natural numbers\n    sc_signal<unsigned int> result_sig; \/\/ Signal for the sum result\n\n    \/\/ Instance of the SumCalculator module\n    SumCalculator sum_calc_inst;\n\n    \/\/ Constructor\n    SC_CTOR(Testbench) : sum_calc_inst(\"sum_calc_inst\") {\n        \/\/ Connect signals to module ports\n        sum_calc_inst.n(n_sig);\n        sum_calc_inst.result(result_sig);\n\n        \/\/ Create a test thread to provide stimulus and check the result\n        SC_THREAD(run_tests);\n    }\n\n    \/\/ Thread to run test cases\n    void run_tests() {\n        \/\/ Test case: n = 5 (expected sum = 15)\n        n_sig.write(5);\n        wait(1, SC_NS); \/\/ Wait for the process to update\n        unsigned int result = result_sig.read();\n        std::cout << \"Sum of first \" << n_sig.read() << \" natural numbers: \" << result << std::endl;\n        assert(result == 15);\n\n        \/\/ Additional test case: n = 10 (expected sum = 55)\n        n_sig.write(10);\n        wait(1, SC_NS);\n        result = result_sig.read();\n        std::cout << \"Sum of first \" << n_sig.read() << \" natural numbers: \" << result << std::endl;\n        assert(result == 55);\n\n        \/\/ End simulation after successful test\n        std::cout << \"All tests passed successfully.\" << std::endl;\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); \/\/ Instantiate the testbench module\n    sc_start();         \/\/ Start the simulation\n    return 0;\n}\n",
        "signal":"sc_in<unsigned int> n;\nsc_out<unsigned int> result;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input. \n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<unsigned int> n;\nsc_out<unsigned int> result;\n> **Note**: Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n\n**C++\/C Code**:\n```\n\/\/ C++ program to find sum of first n natural numbers. \n#include <iostream> \nusing namespace std; \n\n\/\/ Returns sum of first n natural \n\/\/ numbers \nint findSum(int n) \n{ \n\tint sum = 0; \n\tfor (int i = 1; i <= n; i++) \n\t\tsum = sum + i; \n\treturn sum; \n} \n\n\/\/ Driver code \nint main() \n{ \n\tint n = 5; \n\tcout << findSum(n); \n\treturn 0; \n}\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":6,
        "task":"DisplayPrimeNumbersBetweenTwoIntervals",
        "code":"\/\/ C++ program to find the prime numbers between a given interval\n#include <bits\/stdc++.h>\nusing namespace std;\n\n\/\/ Driver code\nint main()\n{\n    \/\/ Declare the variables\n    int a, b, i, j, flag;\n\n    \/\/ Ask user to enter lower value\n    \/\/ of interval\n    cout << \"Enter lower bound of the interval: \";\n\n    \/\/ Take input\n    \/\/ cin >> a;\n    a = 100;\n\n    \/\/ Ask user to enter upper value\n    \/\/ of interval\n    cout << \"Enter upper bound of the interval: \";\n\n    \/\/ Take input\n    \/\/ cin >> b;\n    b = 300;\n    \/\/ Print display message\n    cout << \"Prime numbers between \" << a << \" and \" << b\n         << \" are: \";\n\n    \/\/ Traverse each number in the interval\n    \/\/ with the help of for loop\n    for (i = a; i <= b; i++) {\n        \/\/ Skip 0 and 1 as they are\n        \/\/ neither prime nor composite\n        if (i == 1 || i == 0)\n            continue;\n\n        \/\/ flag variable to tell\n        \/\/ if i is prime or not\n        flag = 1;\n\n        for (j = 2; j <= i \/ 2; ++j) {\n            if (i % j == 0) {\n                flag = 0;\n                break;\n            }\n        }\n\n        \/\/ flag = 1 means i is prime\n        \/\/ and flag = 0 means i is not prime\n        if (flag == 1)\n            cout << i << \" \";\n    }\n\n    return 0;\n}\n",
        "category":"Miscellaneous",
        "sub_category":"Miscellaneous",
        "adoption":false,
        "reason":null,
        "module_name":null,
        "testbench":null,
        "signal":null,
        "prompt":null
    },
    {
        "task_id":7,
        "task":"OctaltoDecimalConversion",
        "code":"\/\/ C++ program to convert octal \n\/\/ to decimal\n#include <iostream>\nusing namespace std;\n\n\/\/ Function to convert octal \n\/\/ to decimal\nint octalToDecimal(int n)\n{\n\tint num = n;\n\tint dec_value = 0;\n\n\t\/\/ Initializing base value to 1, \n\t\/\/ i.e 8^0\n\tint base = 1;\n\n\tint temp = num;\n\twhile (temp) \n\t{\n\t\t\/\/ Extracting last digit\n\t\tint last_digit = temp % 10;\n\t\ttemp = temp \/ 10;\n\n\t\t\/\/ Multiplying last digit with \n\t\t\/\/ appropriate base value and adding \n\t\t\/\/ it to dec_value\n\t\tdec_value += last_digit * base;\n\n\t\tbase = base * 8;\n\t}\n\n\treturn dec_value;\n}\n\n\/\/ Driver code\nint main()\n{\n\tint num = 67;\n\n\tcout << octalToDecimal(num) << endl;\n}\n",
        "category":"Basic Math Operations",
        "sub_category":"Number Base Conversion",
        "adoption":true,
        "reason":null,
        "module_name":"OctalToDecimalConverter",
        "testbench":"SC_MODULE(Testbench) {\n    sc_signal<int> octal_input_sig; \/\/ Signal for the octal input\n    sc_signal<int> decimal_output_sig; \/\/ Signal for the decimal output\n\n    OctalToDecimalConverter converter_inst; \/\/ Instance of the converter module\n\n    \/\/ Constructor\n    SC_CTOR(Testbench) : converter_inst(\"converter\") {\n        \/\/ Connect signals to ports\n        converter_inst.octal_input(octal_input_sig);\n        converter_inst.decimal_output(decimal_output_sig);\n\n        \/\/ Process to run tests\n        SC_THREAD(run_tests);\n    }\n\n    \/\/ Thread to run test cases\n    void run_tests() {\n        \/\/ Test case 1: Convert 67 (octal) to decimal\n        octal_input_sig = 67;\n        wait(1, SC_NS); \/\/ Wait for the converter to process\n        int result = decimal_output_sig.read();\n        cout << \"Octal: 67 -> Decimal: \" << result << endl;\n        assert(result == 55); \/\/ 67 in octal is 55 in decimal\n\n        \/\/ Additional test case: Convert 123 (octal) to decimal\n        octal_input_sig = 123;\n        wait(1, SC_NS);\n        result = decimal_output_sig.read();\n        cout << \"Octal: 123 -> Decimal: \" << result << endl;\n        assert(result == 83); \/\/ 123 in octal is 83 in decimal\n\n        \/\/ Print success message\n        cout << \"All tests passed successfully.\" << endl;\n\n        sc_stop(); \/\/ Stop the simulation\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); \/\/ Create an instance of the Testbench\n\n    \/\/ Start the simulation\n    sc_start();\n\n    return 0;\n}\n",
        "signal":"sc_in<int> octal_input;\nsc_out<int> decimal_output;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input. \n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<int> octal_input;\nsc_out<int> decimal_output;\n> **Note**: Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n\n**C++\/C Code**:\n```\n\/\/ C++ program to convert octal \n\/\/ to decimal\n#include <iostream>\nusing namespace std;\n\n\/\/ Function to convert octal \n\/\/ to decimal\nint octalToDecimal(int n)\n{\n\tint num = n;\n\tint dec_value = 0;\n\n\t\/\/ Initializing base value to 1, \n\t\/\/ i.e 8^0\n\tint base = 1;\n\n\tint temp = num;\n\twhile (temp) \n\t{\n\t\t\/\/ Extracting last digit\n\t\tint last_digit = temp % 10;\n\t\ttemp = temp \/ 10;\n\n\t\t\/\/ Multiplying last digit with \n\t\t\/\/ appropriate base value and adding \n\t\t\/\/ it to dec_value\n\t\tdec_value += last_digit * base;\n\n\t\tbase = base * 8;\n\t}\n\n\treturn dec_value;\n}\n\n\/\/ Driver code\nint main()\n{\n\tint num = 67;\n\n\tcout << octalToDecimal(num) << endl;\n}\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":8,
        "task":"SearchanElementinanArray_BinarySearch",
        "code":"\/\/ C++ program to implement iterative \n\/\/ binary search\n#include <bits\/stdc++.h>\nusing namespace std;\n\nbool binarySearch(vector<int>& v, int target) {\n    \n      \/\/ Defining the part of the vector to be\n      \/\/ searched\n    int low = 0, high = v.size() - 1;\n      \n      \/\/ Till the element is found or vector cannot\n      \/\/ be divided into more parts\n    while (low <= high) {\n      \n          \/\/ Finding mid point\n        int mid = ((high - low) \/ 2) + low;\n\n        \/\/ If the middle element is equal to target\n        if (v[mid] == target) {\n            return true;\n        }\n\n        \/\/ If the middle element is greater than \n        \/\/ target, search in the left half \n        if (v[mid] > target)\n            high = mid - 1;\n        \n        \/\/ If the middle element is smaller than\n        \/\/ target, search the right half \n        else\n            low = mid + 1;\n    }\n      \n      \/\/ If we don't find the target\n      return false;\n}\n\nint main() {\n    vector<int> v = {1, 2, 3, 4, 5, 8, 9, 11};\n    \n      \/\/ Element to be searched\n      int target = 8;\n  \n      \/\/ Searching the target element\n    if (binarySearch(v, target)) {\n        cout << target << \" found.\";\n    } else {\n        cout << target << \" NOT found.\";\n    }\n    return 0;\n}\n",
        "category":"Array Operations",
        "sub_category":"Array Searching",
        "adoption":true,
        "reason":null,
        "module_name":"BinarySearchModule",
        "testbench":"SC_MODULE(Testbench) {\n    sc_vector<sc_signal<int>> v_sig; \/\/ Signals for the vector elements\n    sc_signal<int> target_sig;       \/\/ Signal for the target value\n    sc_signal<bool> found_sig;       \/\/ Signal for the result\n\n    BinarySearchModule bs_inst; \/\/ Instance of the BinarySearchModule\n\n    \/\/ Constructor\n    SC_CTOR(Testbench)\n    : bs_inst(\"bs_inst\"), v_sig(\"v_sig\", 8) { \/\/ Initialize vector size to 8\n        \/\/ Connect signals to module ports\n        for (size_t i = 0; i < v_sig.size(); ++i) {\n            bs_inst.v[i](v_sig[i]);\n        }\n        bs_inst.target(target_sig);\n        bs_inst.found(found_sig);\n\n        \/\/ Process to run tests\n        SC_THREAD(run_tests);\n    }\n\n    \/\/ Thread to run test cases\n    void run_tests() {\n        \/\/ Initialize the vector with sorted values\n        std::vector<int> v_values = {1, 2, 3, 4, 5, 8, 9, 11};\n        for (size_t i = 0; i < v_values.size(); ++i) {\n            v_sig[i].write(v_values[i]);\n        }\n\n        \/\/ Test case 1: Target found\n        target_sig.write(8);\n        wait(1, SC_NS); \/\/ Wait for the module to process\n        assert(found_sig.read() == true);\n        cout << \"Target \" << target_sig.read() << \" found: \" << found_sig.read() << endl;\n\n        \/\/ Test case 2: Target not found\n        target_sig.write(7);\n        wait(1, SC_NS); \/\/ Wait for the module to process\n        assert(found_sig.read() == false);\n        cout << \"Target \" << target_sig.read() << \" found: \" << found_sig.read() << endl;\n\n        \/\/ End simulation after successful test\n        cout << \"All tests passed successfully.\" << endl;\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); \/\/ Create an instance of the Testbench\n\n    \/\/ Start the simulation\n    sc_start();\n\n    return 0;\n}\n",
        "signal":"sc_in<int> target;\nsc_out<bool> found;\nsc_vector<sc_in<int>> v;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input. \n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<int> target;\nsc_out<bool> found;\nsc_vector<sc_in<int>> v;\n> **Note**: Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n\n**C++\/C Code**:\n```\n\/\/ C++ program to implement iterative \n\/\/ binary search\n#include <bits\/stdc++.h>\nusing namespace std;\n\nbool binarySearch(vector<int>& v, int target) {\n    \n      \/\/ Defining the part of the vector to be\n      \/\/ searched\n    int low = 0, high = v.size() - 1;\n      \n      \/\/ Till the element is found or vector cannot\n      \/\/ be divided into more parts\n    while (low <= high) {\n      \n          \/\/ Finding mid point\n        int mid = ((high - low) \/ 2) + low;\n\n        \/\/ If the middle element is equal to target\n        if (v[mid] == target) {\n            return true;\n        }\n\n        \/\/ If the middle element is greater than \n        \/\/ target, search in the left half \n        if (v[mid] > target)\n            high = mid - 1;\n        \n        \/\/ If the middle element is smaller than\n        \/\/ target, search the right half \n        else\n            low = mid + 1;\n    }\n      \n      \/\/ If we don't find the target\n      return false;\n}\n\nint main() {\n    vector<int> v = {1, 2, 3, 4, 5, 8, 9, 11};\n    \n      \/\/ Element to be searched\n      int target = 8;\n  \n      \/\/ Searching the target element\n    if (binarySearch(v, target)) {\n        cout << target << \" found.\";\n    } else {\n        cout << target << \" NOT found.\";\n    }\n    return 0;\n}\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\n#include <systemc.h>\n\n\/\/ BubbleSort Module: Implements the bubble sort algorithm\nSC_MODULE(BubbleSort) {\n    sc_in<bool> clk;      \/\/ Clock input\n    sc_in<bool> start;    \/\/ Signal to start sorting\n    sc_out<bool> done;    \/\/ Signal to indicate sorting is complete\n\n    \/\/ Internal storage for the array (fixed size of 4 elements)\n    int arr[4];\n\n    \/\/ Constructor: register the process\n    SC_CTOR(BubbleSort) {\n        SC_THREAD(sort_process);\n        sensitive << clk.pos();\n    }\n\n    \/\/ Process that waits for the start signal and performs sorting\n    void sort_process() {\n        while (true) {\n            wait(); \/\/ wait for a clock cycle\n            if (start.read() == true) {\n                bubbleSort(); \/\/ perform sorting\n                done.write(true);\n                wait(); \/\/ wait for one cycle to signal completion\n                done.write(false);\n            }\n        }\n    }\n\n    \/\/ Bubble sort algorithm implementation (sorts the internal array)\n    void bubbleSort() {\n        \/\/ Number of elements is fixed at 4\n        const int n = 4;\n        for (int i = 0; i < n - 1; i++) {\n            for (int j = 0; j < n - i - 1; j++) {\n                if (arr[j] > arr[j + 1]) {\n                    \/\/ Swap arr[j] and arr[j+1]\n                    int temp = arr[j];\n                    arr[j] = arr[j + 1];\n                    arr[j + 1] = temp;\n                }\n            }\n        }\n    }\n\n    \/\/ Helper method to load an input array into the module\n    void load_array(const int input[4]) {\n        for (int i = 0; i < 4; i++) {\n            arr[i] = input[i];\n        }\n    }\n\n    \/\/ Helper method to read the sorted array from the module\n    void read_array(int output[4]) {\n        for (int i = 0; i < 4; i++) {\n            output[i] = arr[i];\n        }\n    }\n};\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":9,
        "task":"SumofFibonacciNumbersatEvenIndexesuptoNTerms",
        "code":"\/\/ C++ Program to find sum of \n\/\/ even-indiced Fibonacci numbers\n#include <bits\/stdc++.h>\nusing namespace std;\n\n\/\/ Computes value of first \n\/\/ fibonacci numbers and \n\/\/ stores the even-indexed sum\nint calculateEvenSum(int n)\n{\n\tif (n <= 0)\n\t\treturn 0;\n\n\tint fibo[2 * n + 1];\n\tfibo[0] = 0, fibo[1] = 1;\n\n\t\/\/ Initialize result\n\tint sum = 0;\n\n\t\/\/ Add remaining terms\n\tfor (int i = 2; i <= 2 * n; i++) \n\t{\n\t\tfibo[i] = fibo[i - 1] + fibo[i - 2];\n\n\t\t\/\/ For even indices\n\t\tif (i % 2 == 0)\n\t\t\tsum += fibo[i];\n\t}\n\n\t\/\/ Return the alternating sum\n\treturn sum;\n}\n\n\/\/ Driver code\nint main()\n{\n\n\t\/\/ Get n\n\tint n = 8;\n\n\t\/\/ Find the even-indiced sum\n\tcout << \"Even indexed Fibonacci Sum upto \" << \n\t\t\tn << \" terms: \" << calculateEvenSum(n) << \n\t\t\tendl;\n\n\treturn 0;\n}\n",
        "category":"Basic Math Operations",
        "sub_category":"Basic Math Operations",
        "adoption":true,
        "reason":null,
        "module_name":"FibonacciSumCalculator",
        "testbench":"SC_MODULE(Testbench) {\n    sc_signal<int> n_sig; \/\/ Signal for the number of terms\n    sc_signal<int> sum_sig; \/\/ Signal for the sum of even-indexed Fibonacci numbers\n\n    \/\/ Instance of the FibonacciSumCalculator module\n    FibonacciSumCalculator fib_sum_calc_inst;\n\n    \/\/ Constructor\n    SC_CTOR(Testbench)\n    : fib_sum_calc_inst(\"fib_sum_calc_inst\") {\n        \/\/ Connect signals to module ports\n        fib_sum_calc_inst.n(n_sig);\n        fib_sum_calc_inst.sum(sum_sig);\n\n        \/\/ Create a test thread to provide stimulus and check the result\n        SC_THREAD(run_tests);\n    }\n\n    \/\/ Thread to run test cases\n    void run_tests() {\n        \/\/ Test case: n = 8 (expected sum = 44)\n        n_sig.write(8);\n        wait(1, SC_NS); \/\/ Wait for the process to update\n        int result = sum_sig.read();\n        std::cout << \"Even indexed Fibonacci Sum upto \" << n_sig.read() << \" terms: \" << result << std::endl;\n        assert(result == 1596);\n\n        \/\/ Additional test case: n = 5 (expected sum = 10)\n        n_sig.write(5);\n        wait(1, SC_NS);\n        result = sum_sig.read();\n        std::cout << \"Even indexed Fibonacci Sum upto \" << n_sig.read() << \" terms: \" << result << std::endl;\n        assert(result == 88);\n\n        \/\/ End simulation after successful tests\n        std::cout << \"All tests passed successfully.\" << std::endl;\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); \/\/ Instantiate the testbench module\n    sc_start();         \/\/ Start the simulation\n    return 0;\n}\n",
        "signal":"sc_in<int> n;\nsc_out<int> sum;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input. \n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<int> n;\nsc_out<int> sum;\n> **Note**: Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n\n**C++\/C Code**:\n```\n\/\/ C++ Program to find sum of \n\/\/ even-indiced Fibonacci numbers\n#include <bits\/stdc++.h>\nusing namespace std;\n\n\/\/ Computes value of first \n\/\/ fibonacci numbers and \n\/\/ stores the even-indexed sum\nint calculateEvenSum(int n)\n{\n\tif (n <= 0)\n\t\treturn 0;\n\n\tint fibo[2 * n + 1];\n\tfibo[0] = 0, fibo[1] = 1;\n\n\t\/\/ Initialize result\n\tint sum = 0;\n\n\t\/\/ Add remaining terms\n\tfor (int i = 2; i <= 2 * n; i++) \n\t{\n\t\tfibo[i] = fibo[i - 1] + fibo[i - 2];\n\n\t\t\/\/ For even indices\n\t\tif (i % 2 == 0)\n\t\t\tsum += fibo[i];\n\t}\n\n\t\/\/ Return the alternating sum\n\treturn sum;\n}\n\n\/\/ Driver code\nint main()\n{\n\n\t\/\/ Get n\n\tint n = 8;\n\n\t\/\/ Find the even-indiced sum\n\tcout << \"Even indexed Fibonacci Sum upto \" << \n\t\t\tn << \" terms: \" << calculateEvenSum(n) << \n\t\t\tendl;\n\n\treturn 0;\n}\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":10,
        "task":"CheckWhetheraNumberisPrimeorNot",
        "code":"\/\/ C++ Program to check for prime number using Simple Trial Division\n#include <bits\/stdc++.h>\nusing namespace std;\n\nint main() {\n    int n = 29;\n\n    int cnt = 0;\n\n    \/\/ If number is less than\/equal to 1,\n    \/\/ it is not prime\n    if (n <= 1)\n        cout << n << \" is NOT prime\" << endl;\n    else {\n\n        \/\/ Check for divisors from 1 to n\n        for (int i = 1; i <= n; i++) {\n\n            \/\/ Check how many number is divisible\n            \/\/ by n\n            if (n % i == 0)\n                cnt++;\n        }\n\n        \/\/ If n is divisible by more than 2 numbers\n        \/\/ then it is not prime\n        if (cnt > 2)\n            cout << n << \" is NOT prime\" << endl;\n\n        \/\/ else it is prime\n        else\n            cout << n << \" is prime\" << endl;\n    }\n\n    return 0;\n}\n\n",
        "category":"Basic Math Operations",
        "sub_category":"Decision",
        "adoption":true,
        "reason":null,
        "module_name":"PrimeChecker",
        "testbench":"SC_MODULE(Testbench) {\n    sc_signal<int> n_sig;       \/\/ Signal for the input number\n    sc_signal<bool> prime_sig;  \/\/ Signal for the prime check result\n\n    \/\/ Instance of the PrimeChecker module\n    PrimeChecker prime_checker_inst;\n\n    \/\/ Constructor: Initialize the module and run the test thread\n    SC_CTOR(Testbench)\n    : prime_checker_inst(\"prime_checker_inst\") {\n        \/\/ Connect signals to module ports\n        prime_checker_inst.n(n_sig);\n        prime_checker_inst.is_prime(prime_sig);\n\n        \/\/ Create a test thread to provide stimulus and check the result\n        SC_THREAD(run_tests);\n    }\n\n    \/\/ Thread to run test cases\n    void run_tests() {\n        \/\/ Test case: n = 29 (expected: prime)\n        n_sig.write(29);\n        wait(1, SC_NS); \/\/ Wait for the process to update\n        bool result = prime_sig.read();\n        std::cout << \"Number \" << n_sig.read() << \" is \" << (result ? \"prime\" : \"NOT prime\") << std::endl;\n        assert(result == true);\n\n        \/\/ Test case: n = 1 (expected: NOT prime)\n        n_sig.write(1);\n        wait(1, SC_NS);\n        result = prime_sig.read();\n        std::cout << \"Number \" << n_sig.read() << \" is \" << (result ? \"prime\" : \"NOT prime\") << std::endl;\n        assert(result == false);\n\n        \/\/ Test case: n = 10 (expected: NOT prime)\n        n_sig.write(10);\n        wait(1, SC_NS);\n        result = prime_sig.read();\n        std::cout << \"Number \" << n_sig.read() << \" is \" << (result ? \"prime\" : \"NOT prime\") << std::endl;\n        assert(result == false);\n\n        \/\/ Test case: n = 13 (expected: prime)\n        n_sig.write(13);\n        wait(1, SC_NS);\n        result = prime_sig.read();\n        std::cout << \"Number \" << n_sig.read() << \" is \" << (result ? \"prime\" : \"NOT prime\") << std::endl;\n        assert(result == true);\n\n        \/\/ End simulation after successful tests\n        std::cout << \"All tests passed successfully.\" << std::endl;\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); \/\/ Instantiate the testbench module\n    sc_start();         \/\/ Start the simulation\n    return 0;\n}\n",
        "signal":"sc_in<int> n;\nsc_out<bool> is_prime;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input. \n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<int> n;\nsc_out<bool> is_prime;\n> **Note**: Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n\n**C++\/C Code**:\n```\n\/\/ C++ Program to check for prime number using Simple Trial Division\n#include <bits\/stdc++.h>\nusing namespace std;\n\nint main() {\n    int n = 29;\n\n    int cnt = 0;\n\n    \/\/ If number is less than\/equal to 1,\n    \/\/ it is not prime\n    if (n <= 1)\n        cout << n << \" is NOT prime\" << endl;\n    else {\n\n        \/\/ Check for divisors from 1 to n\n        for (int i = 1; i <= n; i++) {\n\n            \/\/ Check how many number is divisible\n            \/\/ by n\n            if (n % i == 0)\n                cnt++;\n        }\n\n        \/\/ If n is divisible by more than 2 numbers\n        \/\/ then it is not prime\n        if (cnt > 2)\n            cout << n << \" is NOT prime\" << endl;\n\n        \/\/ else it is prime\n        else\n            cout << n << \" is prime\" << endl;\n    }\n\n    return 0;\n}\n\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":11,
        "task":"SorttheElementsofanArrayinDescendingOrder",
        "code":"\/\/ C++ program to sort array \n\/\/ in ascending order using\n\/\/ Brute-force approach\n\/\/ using bubble sort\n#include <bits\/stdc++.h>\nusing namespace std;\n\nvoid sort(int num[], int len);\nvoid swapNums(int nums[], \n\t\t\tint first, int second);\n\n\/\/ Driver code\nint main()\n{\n\t\/\/ Initializing arrya\n\tint nums[] = {1, 12, 6, 8, 10};\n\tint size_nums = (sizeof(nums) \/ \n\t\t\t\t\tsizeof(nums[0]));\n\n\tcout << \"Before sorting the array is: \\n\";\n\tfor (int i = 0; i < size_nums; i++)\n\t\tcout << nums[i] << \" \";\n\tcout << \"\\n\\n\";\n\n\tsort(nums, size_nums);\n\n\tcout << \"After sorting the array is: \\n\";\n\n\tfor (int i = 0; i < size_nums; i++)\n\t\tcout << nums[i] << \" \";\n\tcout << \"\\n\";\n\treturn 0;\n}\n\n\/\/ Sort function\nvoid sort(int num[], int len)\n{\n\tbool isSwapped;\n\n\t\/**\n\t* Here we are running n-1 steps, \n\tfor each step, max item will \n\tcome at the last respective \n\tindex and swap element if the \n\telement is smaller than the \n\tprevious one.\n\t**\/\n\tfor (int i = 0; i < len; i++) \n\t{\n\t\tisSwapped = false;\n\t\tfor (int j = 1; j < len - i; j++) \n\t\t{\n\t\t\tif (num[j] < num[j - 1]) \n\t\t\t{\n\t\t\t\tswapNums(num, j, (j - 1));\n\t\t\t\tisSwapped = true;\n\t\t\t}\n\t\t}\n\t\tif (!isSwapped) \n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n\/\/ Swaps two numbers in array\nvoid swapNums(int nums[], \n\t\t\tint first, int second)\n{\n\tint curr = nums[first];\n\tnums[first] = nums[second];\n\tnums[second] = curr;\n}\n",
        "category":"Array Operations",
        "sub_category":"Array Sorting",
        "adoption":true,
        "reason":null,
        "module_name":"BubbleSort",
        "testbench":"SC_MODULE(Testbench) {\n    sc_clock clk;          \/\/ Clock signal for synchronization\n    sc_signal<bool> start; \/\/ Signal to trigger sorting\n    sc_signal<bool> done;  \/\/ Signal indicating sort completion\n\n    \/\/ Instance of the BubbleSort module\n    BubbleSort* bubble_sort_inst;\n\n    SC_CTOR(Testbench) : clk(\"clk\", 1, SC_NS) {\n        bubble_sort_inst = new BubbleSort(\"bubble_sort_inst\");\n        bubble_sort_inst->clk(clk);\n        bubble_sort_inst->start(start);\n        bubble_sort_inst->done(done);\n\n        SC_THREAD(run_tests);\n    }\n\n    \/\/ Process to run the test cases.\n    void run_tests() {\n        \/\/ Initialize the array with unsorted values {1, 12, 6, 8, 10}.\n        int arr_in[5] = {1, 12, 6, 8, 10};\n        bubble_sort_inst->load_array(arr_in);\n\n        \/\/ Optional: Print array before sorting.\n        std::cout << \"Before sorting: \";\n        for (int i = 0; i < 5; i++) {\n            std::cout << arr_in[i] << \" \";\n        }\n        std::cout << std::endl;\n\n        \/\/ Start the sorting process.\n        start.write(true);\n        wait(1, SC_NS); \/\/ Wait one clock cycle.\n        start.write(false);\n\n        \/\/ Wait until the bubble sort module signals that sorting is done.\n        while (done.read() != true) {\n            wait(1, SC_NS);\n        }\n        \n        \/\/ Retrieve the sorted array from the BubbleSort module.\n        int arr_out[5];\n        bubble_sort_inst->read_array(arr_out);\n\n        \/\/ Expected sorted result is {1, 6, 8, 10, 12}.\n        int expected[5] = {1, 6, 8, 10, 12};\n\n        \/\/ Optional: Print sorted array.\n        std::cout << \"After sorting: \";\n        for (int i = 0; i < 5; i++) {\n            std::cout << arr_out[i] << \" \";\n        }\n        std::cout << std::endl;\n\n        \/\/ Verify that each element is sorted as expected.\n        for (int i = 0; i < 5; i++) {\n            assert(arr_out[i] == expected[i]);\n        }\n        std::cout << \"All tests passed successfully.\" << std::endl;\n\n        sc_stop(); \/\/ End simulation.\n    }\n};\n\n\/\/ sc_main: Entry point for the SystemC simulation.\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); \/\/ Create the testbench instance.\n    sc_start();         \/\/ Start the simulation.\n    return 0;\n}\n",
        "signal":"sc_in<bool> clk;\nsc_in<bool> start;\nsc_out<bool> done;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input. \n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<bool> clk;\nsc_in<bool> start;\nsc_out<bool> done;\n> **Note**: Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n\n**C++\/C Code**:\n```\n\/\/ C++ program to sort array \n\/\/ in ascending order using\n\/\/ Brute-force approach\n\/\/ using bubble sort\n#include <bits\/stdc++.h>\nusing namespace std;\n\nvoid sort(int num[], int len);\nvoid swapNums(int nums[], \n\t\t\tint first, int second);\n\n\/\/ Driver code\nint main()\n{\n\t\/\/ Initializing arrya\n\tint nums[] = {1, 12, 6, 8, 10};\n\tint size_nums = (sizeof(nums) \/ \n\t\t\t\t\tsizeof(nums[0]));\n\n\tcout << \"Before sorting the array is: \\n\";\n\tfor (int i = 0; i < size_nums; i++)\n\t\tcout << nums[i] << \" \";\n\tcout << \"\\n\\n\";\n\n\tsort(nums, size_nums);\n\n\tcout << \"After sorting the array is: \\n\";\n\n\tfor (int i = 0; i < size_nums; i++)\n\t\tcout << nums[i] << \" \";\n\tcout << \"\\n\";\n\treturn 0;\n}\n\n\/\/ Sort function\nvoid sort(int num[], int len)\n{\n\tbool isSwapped;\n\n\t\/**\n\t* Here we are running n-1 steps, \n\tfor each step, max item will \n\tcome at the last respective \n\tindex and swap element if the \n\telement is smaller than the \n\tprevious one.\n\t**\/\n\tfor (int i = 0; i < len; i++) \n\t{\n\t\tisSwapped = false;\n\t\tfor (int j = 1; j < len - i; j++) \n\t\t{\n\t\t\tif (num[j] < num[j - 1]) \n\t\t\t{\n\t\t\t\tswapNums(num, j, (j - 1));\n\t\t\t\tisSwapped = true;\n\t\t\t}\n\t\t}\n\t\tif (!isSwapped) \n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n\/\/ Swaps two numbers in array\nvoid swapNums(int nums[], \n\t\t\tint first, int second)\n{\n\tint curr = nums[first];\n\tnums[first] = nums[second];\n\tnums[second] = curr;\n}\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\n#include <systemc.h>\n\n\/\/ BubbleSort Module: Implements the bubble sort algorithm\nSC_MODULE(BubbleSort) {\n    sc_in<bool> clk;      \/\/ Clock input\n    sc_in<bool> start;    \/\/ Signal to start sorting\n    sc_out<bool> done;    \/\/ Signal to indicate sorting is complete\n\n    \/\/ Internal storage for the array (fixed size of 4 elements)\n    int arr[4];\n\n    \/\/ Constructor: register the process\n    SC_CTOR(BubbleSort) {\n        SC_THREAD(sort_process);\n        sensitive << clk.pos();\n    }\n\n    \/\/ Process that waits for the start signal and performs sorting\n    void sort_process() {\n        while (true) {\n            wait(); \/\/ wait for a clock cycle\n            if (start.read() == true) {\n                bubbleSort(); \/\/ perform sorting\n                done.write(true);\n                wait(); \/\/ wait for one cycle to signal completion\n                done.write(false);\n            }\n        }\n    }\n\n    \/\/ Bubble sort algorithm implementation (sorts the internal array)\n    void bubbleSort() {\n        \/\/ Number of elements is fixed at 4\n        const int n = 4;\n        for (int i = 0; i < n - 1; i++) {\n            for (int j = 0; j < n - i - 1; j++) {\n                if (arr[j] > arr[j + 1]) {\n                    \/\/ Swap arr[j] and arr[j+1]\n                    int temp = arr[j];\n                    arr[j] = arr[j + 1];\n                    arr[j + 1] = temp;\n                }\n            }\n        }\n    }\n\n    \/\/ Helper method to load an input array into the module\n    void load_array(const int input[4]) {\n        for (int i = 0; i < 4; i++) {\n            arr[i] = input[i];\n        }\n    }\n\n    \/\/ Helper method to read the sorted array from the module\n    void read_array(int output[4]) {\n        for (int i = 0; i < 4; i++) {\n            output[i] = arr[i];\n        }\n    }\n};\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":12,
        "task":"InterchangeElementsofFirstAndLastColumnsInMatrix",
        "code":"\/\/ C++ code to swap the element of first \n\/\/ and last row and display the result \n#include <iostream> \nusing namespace std; \n\n#define n 4 \n\nvoid interchangeFirstLast(int m[][n]) \n{ \n\t\tint rows = n; \n\t\t\n\t\t\/\/ Swapping of element between first \n\t\t\/\/ and last rows \n\t\tfor (int i = 0; i < n; i++) \n\t\t{ \n\t\t\tint t = m[0][i]; \n\t\t\tm[0][i] = m[rows - 1][i]; \n\t\t\tm[rows - 1][i] = t; \n\t\t} \n} \n\n\/\/ Driver code \nint main() \n{ \n\t\/\/ input in the array \n\tint m[n][n] = {{8, 9, 7, 6}, \n\t\t\t\t{4, 7, 6, 5}, \n\t\t\t\t{3, 2, 1, 8}, \n\t\t\t\t{9, 9, 7, 7}}; \n\t\t\t\t\n\tinterchangeFirstLast(m); \n\t\n\t\/\/ Printing the interchanged matrix \n\tfor (int i = 0; i < n; i++) \n\t{ \n\t\tfor (int j = 0; j < n; j++) \n\t\t\tcout << m[i][j] << \" \"; \n\t\tcout << endl; \n\t} \n} \n\n\/\/ This code is contributed by Anant Agarwal. \n",
        "category":"Matrix Operations",
        "sub_category":"Matrix Operations",
        "adoption":true,
        "reason":null,
        "module_name":"MatrixSwapper",
        "testbench":"SC_MODULE(Testbench) {\n    \/\/ Use static const for constants instead of #define\n    static const int N = 4;\n    static const int SIZE = N * N;\n    \n    sc_signal<int> in[SIZE];\n    sc_signal<int> out[SIZE];\n    MatrixSwapper* swapper;\n\n    SC_CTOR(Testbench) {\n        swapper = new MatrixSwapper(\"swapper\");\n        \/\/ Connect the signals to the MatrixSwapper ports\n        for (int i = 0; i < SIZE; i++) {\n            swapper->in[i](in[i]);\n            swapper->out[i](out[i]);\n        }\n        SC_THREAD(run_tests);\n    }\n\n    \/\/ Thread that runs the test, checks outputs, and asserts correctness\n    void run_tests() {\n        \/\/ Initialize the matrix as in the original C++ code:\n        \/\/   { {8, 9, 7, 6},\n        \/\/     {4, 7, 6, 5},\n        \/\/     {3, 2, 1, 8},\n        \/\/     {9, 9, 7, 7} }\n        int m[SIZE] = {8, 9, 7, 6,\n                       4, 7, 6, 5,\n                       3, 2, 1, 8,\n                       9, 9, 7, 7};\n        for (int i = 0; i < SIZE; i++) {\n            in[i].write(m[i]);\n        }\n\n        \/\/ Wait for signals to propagate\n        wait(1, SC_NS);\n\n        \/\/ Expected output after swapping first and last rows:\n        \/\/   { {9, 9, 7, 7},\n        \/\/     {4, 7, 6, 5},\n        \/\/     {3, 2, 1, 8},\n        \/\/     {8, 9, 7, 6} }\n        int expected[SIZE] = {9, 9, 7, 7,\n                              4, 7, 6, 5,\n                              3, 2, 1, 8,\n                              8, 9, 7, 6};\n\n        \/\/ Print and check the result matrix\n        std::cout << \"Swapped Matrix:\" << std::endl;\n        for (int row = 0; row < N; row++) {\n            for (int col = 0; col < N; col++) {\n                int idx = row * N + col;\n                int result = out[idx].read();\n                std::cout << result << \" \";\n                assert(result == expected[idx]);\n            }\n            std::cout << std::endl;\n        }\n        std::cout << \"All tests passed successfully.\" << std::endl;\n\n        sc_stop(); \/\/ Stop the simulation\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); \/\/ Create an instance of the Testbench\n    sc_start();         \/\/ Start the simulation\n    return 0;\n}\n",
        "signal":"sc_in<int> in[SIZE];\nsc_out<int> out[SIZE];",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input. \n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<int> in[SIZE];\nsc_out<int> out[SIZE];\n> **Note**: Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n\n**C++\/C Code**:\n```\n\/\/ C++ code to swap the element of first \n\/\/ and last row and display the result \n#include <iostream> \nusing namespace std; \n\n#define n 4 \n\nvoid interchangeFirstLast(int m[][n]) \n{ \n\t\tint rows = n; \n\t\t\n\t\t\/\/ Swapping of element between first \n\t\t\/\/ and last rows \n\t\tfor (int i = 0; i < n; i++) \n\t\t{ \n\t\t\tint t = m[0][i]; \n\t\t\tm[0][i] = m[rows - 1][i]; \n\t\t\tm[rows - 1][i] = t; \n\t\t} \n} \n\n\/\/ Driver code \nint main() \n{ \n\t\/\/ input in the array \n\tint m[n][n] = {{8, 9, 7, 6}, \n\t\t\t\t{4, 7, 6, 5}, \n\t\t\t\t{3, 2, 1, 8}, \n\t\t\t\t{9, 9, 7, 7}}; \n\t\t\t\t\n\tinterchangeFirstLast(m); \n\t\n\t\/\/ Printing the interchanged matrix \n\tfor (int i = 0; i < n; i++) \n\t{ \n\t\tfor (int j = 0; j < n; j++) \n\t\t\tcout << m[i][j] << \" \"; \n\t\tcout << endl; \n\t} \n} \n\n\/\/ This code is contributed by Anant Agarwal. \n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\n#include <systemc.h>\n\n\/\/ Use static const for constants instead of #define\nstatic const int N = 4;\nstatic const int SIZE = N * N;\n\n\/\/ Module that performs matrix addition\nSC_MODULE(MatrixAdder) {\n    \/\/ Input ports for matrices A and B (flattened as 1D arrays)\n    sc_in<int> A[SIZE];\n    sc_in<int> B[SIZE];\n    \/\/ Output ports for matrix C (flattened as 1D array)\n    sc_out<int> C[SIZE];\n\n    SC_CTOR(MatrixAdder) {\n        \/\/ Use an SC_METHOD to perform combinational matrix addition\n        SC_METHOD(do_add);\n        for (int i = 0; i < SIZE; i++) {\n            sensitive << A[i] << B[i];\n        }\n    }\n\n    \/\/ Method that adds corresponding elements of A and B\n    void do_add() {\n        for (int i = 0; i < SIZE; i++) {\n            C[i].write(A[i].read() + B[i].read());\n        }\n    }\n};\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":13,
        "task":"AddTwoMatrices",
        "code":"\/\/ C++ program for addition of two matrices\n#include <bits\/stdc++.h>\nusing namespace std;\n#define N 4\n\n\/\/ This function adds A[][] and B[][],\n\/\/ and stores the result in C[][]\nvoid add(int A[][N], int B[][N], int C[][N])\n{\n    int i, j;\n    for (i = 0; i < N; i++)\n        for (j = 0; j < N; j++)\n            C[i][j] = A[i][j] + B[i][j];\n}\n\n\/\/ Driver code\nint main()\n{\n    int A[N][N] = { { 1, 1, 1, 1 },\n                    { 2, 2, 2, 2 },\n                    { 3, 3, 3, 3 },\n                    { 4, 4, 4, 4 } };\n\n    int B[N][N] = { { 1, 1, 1, 1 },\n                    { 2, 2, 2, 2 },\n                    { 3, 3, 3, 3 },\n                    { 4, 4, 4, 4 } };\n\n    \/\/ To store the result\n    int C[N][N];\n    int i, j;\n    add(A, B, C);\n\n    cout << \"Result matrix is \" << endl;\n    for (i = 0; i < N; i++) {\n        for (j = 0; j < N; j++)\n            cout << C[i][j] << \" \";\n        cout << endl;\n    }\n\n    return 0;\n}\n",
        "category":"Matrix Operations",
        "sub_category":"Matrix Operations",
        "adoption":false,
        "reason":"Few shot example",
        "module_name":"MatrixAdder",
        "testbench":"SC_MODULE(Testbench) {\n    static const int N = 4;\n    static const int SIZE = N * N;\n    \/\/ Signals to connect to the MatrixAdder ports\n    sc_signal<int> A[SIZE];\n    sc_signal<int> B[SIZE];\n    sc_signal<int> C[SIZE];\n\n    MatrixAdder* matrixAdder;\n\n    SC_CTOR(Testbench) {\n        \/\/ Instantiate the MatrixAdder module\n        matrixAdder = new MatrixAdder(\"matrixAdder\");\n        \/\/ Connect signals to the module's ports\n        for (int i = 0; i < SIZE; i++) {\n            matrixAdder->A[i](A[i]);\n            matrixAdder->B[i](B[i]);\n            matrixAdder->C[i](C[i]);\n        }\n        \/\/ Create a thread to run the test cases\n        SC_THREAD(run_tests);\n    }\n\n    \/\/ Thread that initializes inputs, checks outputs, and asserts correctness\n    void run_tests() {\n        \/\/ Initialize matrices A and B as defined in the original C++ code:\n        \/\/ Matrix A:\n        \/\/   { 1, 1, 1, 1 },\n        \/\/   { 2, 2, 2, 2 },\n        \/\/   { 3, 3, 3, 3 },\n        \/\/   { 4, 4, 4, 4 }\n        \/\/ Matrix B: identical to Matrix A.\n        for (int row = 0; row < N; row++) {\n            for (int col = 0; col < N; col++) {\n                int index = row * N + col;\n                A[index].write(row + 1); \/\/ row 0 => 1, row 1 => 2, etc.\n                B[index].write(row + 1);\n            }\n        }\n\n        \/\/ Wait for the signals to propagate and the combinational logic to settle.\n        wait(1, SC_NS);\n\n        \/\/ Check the result matrix C and print the output\n        std::cout << \"Result matrix is:\" << std::endl;\n        for (int row = 0; row < N; row++) {\n            for (int col = 0; col < N; col++) {\n                int index = row * N + col;\n                int expected = (row + 1) + (row + 1); \/\/ Since both matrices have the same values.\n                int result = C[index].read();\n                \/\/ Use assert to validate the result.\n                assert(result == expected);\n                std::cout << result << \" \";\n            }\n            std::cout << std::endl;\n        }\n        std::cout << \"All tests passed successfully.\" << std::endl;\n\n        sc_stop(); \/\/ Stop the simulation\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); \/\/ Create an instance of the Testbench\n    sc_start();         \/\/ Start the simulation\n    return 0;\n}\n",
        "signal":"sc_in<int> A[SIZE];\nsc_in<int> B[SIZE];\nsc_out<int> C[SIZE];",
        "prompt":null
    },
    {
        "task_id":14,
        "task":"CheckifaGivenYearisaLeapYear",
        "code":"\/\/ C++ program to check if a given year is a leap year or not\n#include <iostream>\nusing namespace std;\n\n\/\/ Function to check leap year\nbool checkYear(int year)\n{\n\tif (year % 400 == 0) {\n\t\treturn true;\n\t}\n\n\t\/\/ not a leap year if divisible by 100\n\t\/\/ but not divisible by 400\n\telse if (year % 100 == 0) {\n\t\treturn false;\n\t}\n\n\t\/\/ leap year if not divisible by 100\n\t\/\/ but divisible by 4\n\telse if (year % 4 == 0) {\n\t\treturn true;\n\t}\n\n\t\/\/ all other years are not leap years\n\telse {\n\t\treturn false;\n\t}\n}\n\n\/\/ Driver code\nint main()\n{\n\tint year = 2000;\n\n\tcheckYear(year) ? cout << \"Leap Year\"\n\t\t\t\t\t: cout << \"Not a Leap Year\";\n\n\treturn 0;\n}\n",
        "category":"Basic Math Operations",
        "sub_category":"Decision",
        "adoption":true,
        "reason":null,
        "module_name":"LeapYearChecker",
        "testbench":"SC_MODULE(Testbench) {\n    sc_signal<int> year;             \/\/ Signal for the year\n    sc_signal<bool> is_leap_year;    \/\/ Signal for the leap year check result\n\n    LeapYearChecker checker_inst;    \/\/ Instance of the LeapYearChecker module\n\n    \/\/ Constructor\n    SC_CTOR(Testbench) : checker_inst(\"checker\") {\n        \/\/ Connect signals to ports\n        checker_inst.year(year);\n        checker_inst.is_leap_year(is_leap_year);\n\n        \/\/ Process to run tests\n        SC_THREAD(run_tests);\n    }\n\n    \/\/ Thread to run test cases\n    void run_tests() {\n        \/\/ Test case 1: Year 2000 (Leap Year)\n        year = 2000;\n        wait(1, SC_NS);\n        assert(is_leap_year.read() == true);\n        cout << \"Year 2000: \" << (is_leap_year.read() ? \"Leap Year\" : \"Not a Leap Year\") << endl;\n\n        \/\/ Test case 2: Year 1900 (Not a Leap Year)\n        year = 1900;\n        wait(1, SC_NS);\n        assert(is_leap_year.read() == false);\n        cout << \"Year 1900: \" << (is_leap_year.read() ? \"Leap Year\" : \"Not a Leap Year\") << endl;\n\n        \/\/ Test case 3: Year 2004 (Leap Year)\n        year = 2004;\n        wait(1, SC_NS);\n        assert(is_leap_year.read() == true);\n        cout << \"Year 2004: \" << (is_leap_year.read() ? \"Leap Year\" : \"Not a Leap Year\") << endl;\n\n        \/\/ Test case 4: Year 2001 (Not a Leap Year)\n        year = 2001;\n        wait(1, SC_NS);\n        assert(is_leap_year.read() == false);\n        cout << \"Year 2001: \" << (is_leap_year.read() ? \"Leap Year\" : \"Not a Leap Year\") << endl;\n\n        \/\/ Print success message\n        cout << \"All tests passed successfully.\" << endl;\n\n        sc_stop(); \/\/ Stop the simulation\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); \/\/ Create an instance of the Testbench\n\n    \/\/ Start the simulation\n    sc_start();\n\n    return 0;\n}\n",
        "signal":"sc_in<int> year;\nsc_out<bool> is_leap_year;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input. \n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<int> year;\nsc_out<bool> is_leap_year;\n> **Note**: Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n\n**C++\/C Code**:\n```\n\/\/ C++ program to check if a given year is a leap year or not\n#include <iostream>\nusing namespace std;\n\n\/\/ Function to check leap year\nbool checkYear(int year)\n{\n\tif (year % 400 == 0) {\n\t\treturn true;\n\t}\n\n\t\/\/ not a leap year if divisible by 100\n\t\/\/ but not divisible by 400\n\telse if (year % 100 == 0) {\n\t\treturn false;\n\t}\n\n\t\/\/ leap year if not divisible by 100\n\t\/\/ but divisible by 4\n\telse if (year % 4 == 0) {\n\t\treturn true;\n\t}\n\n\t\/\/ all other years are not leap years\n\telse {\n\t\treturn false;\n\t}\n}\n\n\/\/ Driver code\nint main()\n{\n\tint year = 2000;\n\n\tcheckYear(year) ? cout << \"Leap Year\"\n\t\t\t\t\t: cout << \"Not a Leap Year\";\n\n\treturn 0;\n}\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":15,
        "task":"CalculatetheAverageofalltheElementsPresentinanArray",
        "code":"\/\/ C++ program to calculate average of array elements\n#include <iostream>\nusing namespace std;\n\n\/\/ Function that return average\n\/\/ of an array.\ndouble average(int a[], int n)\n{\n    \/\/ Find sum of array element\n    int sum = 0;\n    for (int i = 0; i < n; i++)\n        sum += a[i];\n\n    return (double)sum \/ n;\n}\n\n\/\/ Driver code\nint main()\n{\n    int arr[] = { 10, 2, 3, 4, 5, 6, 7, 8, 9 };\n    int n = sizeof(arr) \/ sizeof(arr[0]);\n\n    cout << average(arr, n) << endl;\n    return 0;\n}\n",
        "category":"Array Operations",
        "sub_category":"Array Operations",
        "adoption":true,
        "reason":null,
        "module_name":"AverageCalculator",
        "testbench":"SC_MODULE(Testbench) {\n    \/\/  9  sc_signal<int>\uff0c\n    sc_vector< sc_signal<int> > data_sig;\n    \/\/ \n    sc_signal<double> avg_sig;\n    \/\/ AverageCalculator \n    AverageCalculator avg_calc_inst;\n\n    \/\/ Constructor\uff0c\n    SC_CTOR(Testbench)\n    : data_sig(\"data_sig\", 9),   \/\/  9 \n      avg_calc_inst(\"avg_calc_inst\")\n    {\n        \/\/  Testbench  AverageCalculator \n        for (int i = 0; i < 9; i++) {\n            avg_calc_inst.data_in[i](data_sig[i]);\n        }\n        \/\/ \n        avg_calc_inst.average_out(avg_sig);\n\n        \/\/ \n        SC_THREAD(run_test);\n    }\n\n    \/\/ \uff1a\u3001\u3001\n    void run_test() {\n        \/\/ \n        int test_data[9] = {10, 2, 3, 4, 5, 6, 7, 8, 9};\n        for (int i = 0; i < 9; i++) {\n            data_sig[i].write(test_data[i]);\n        }\n        \/\/ \n        wait(1, SC_NS);\n\n        \/\/ \n        double computed_avg = avg_sig.read();\n        std::cout << \"Computed average: \" << computed_avg << std::endl;\n        assert(computed_avg == 6.0);\n\n        \/\/ \n        int test_data2[9] = {1, 2, 3, 4, 5, 6, 7, 8, 10};\n        for (int i = 0; i < 9; i++) {\n            data_sig[i].write(test_data2[i]);\n        }\n        \/\/ \n        wait(1, SC_NS);\n\n        \/\/ \n        computed_avg = avg_sig.read();\n        std::cout << \"Computed average: \" << computed_avg << std::endl;\n        double epsilon = 1e-5; \/\/ \n        assert(fabs(computed_avg - 5.11111) < epsilon); \/\/ \n\n        std::cout << \"Test passed successfully.\" << std::endl;\n\n        \/\/ \n        sc_stop();\n    }\n};\n\n\/\/ sc_main\uff1a\uff0c\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\");\n    sc_start();\n    return 0;\n}\n",
        "signal":"sc_out<double> average_out;\nsc_vector< sc_in<int> > data_in;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input. \n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_out<double> average_out;\nsc_vector< sc_in<int> > data_in;\n> **Note**: Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n\n**C++\/C Code**:\n```\n\/\/ C++ program to calculate average of array elements\n#include <iostream>\nusing namespace std;\n\n\/\/ Function that return average\n\/\/ of an array.\ndouble average(int a[], int n)\n{\n    \/\/ Find sum of array element\n    int sum = 0;\n    for (int i = 0; i < n; i++)\n        sum += a[i];\n\n    return (double)sum \/ n;\n}\n\n\/\/ Driver code\nint main()\n{\n    int arr[] = { 10, 2, 3, 4, 5, 6, 7, 8, 9 };\n    int n = sizeof(arr) \/ sizeof(arr[0]);\n\n    cout << average(arr, n) << endl;\n    return 0;\n}\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\n#include <systemc.h>\n\n\/\/ BubbleSort Module: Implements the bubble sort algorithm\nSC_MODULE(BubbleSort) {\n    sc_in<bool> clk;      \/\/ Clock input\n    sc_in<bool> start;    \/\/ Signal to start sorting\n    sc_out<bool> done;    \/\/ Signal to indicate sorting is complete\n\n    \/\/ Internal storage for the array (fixed size of 4 elements)\n    int arr[4];\n\n    \/\/ Constructor: register the process\n    SC_CTOR(BubbleSort) {\n        SC_THREAD(sort_process);\n        sensitive << clk.pos();\n    }\n\n    \/\/ Process that waits for the start signal and performs sorting\n    void sort_process() {\n        while (true) {\n            wait(); \/\/ wait for a clock cycle\n            if (start.read() == true) {\n                bubbleSort(); \/\/ perform sorting\n                done.write(true);\n                wait(); \/\/ wait for one cycle to signal completion\n                done.write(false);\n            }\n        }\n    }\n\n    \/\/ Bubble sort algorithm implementation (sorts the internal array)\n    void bubbleSort() {\n        \/\/ Number of elements is fixed at 4\n        const int n = 4;\n        for (int i = 0; i < n - 1; i++) {\n            for (int j = 0; j < n - i - 1; j++) {\n                if (arr[j] > arr[j + 1]) {\n                    \/\/ Swap arr[j] and arr[j+1]\n                    int temp = arr[j];\n                    arr[j] = arr[j + 1];\n                    arr[j + 1] = temp;\n                }\n            }\n        }\n    }\n\n    \/\/ Helper method to load an input array into the module\n    void load_array(const int input[4]) {\n        for (int i = 0; i < 4; i++) {\n            arr[i] = input[i];\n        }\n    }\n\n    \/\/ Helper method to read the sorted array from the module\n    void read_array(int output[4]) {\n        for (int i = 0; i < 4; i++) {\n            output[i] = arr[i];\n        }\n    }\n};\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":16,
        "task":"CheckWhetheraNumberCanbeExpressedasSumofTwoPrimeNumbers",
        "code":"\/\/ C++ program to check if a prime number can be expressed as sum of two Prime Numbers \n#include <bits\/stdc++.h> \nusing namespace std; \n\n\/\/ Function to check whether \n\/\/ a number is prime or not \nbool isPrime(int n) \n{ \n\tif (n <= 1) \n\t\treturn false; \n\n\tfor (int i = 2; i <= sqrt(n); i++) \n\t{ \n\t\tif (n % i == 0) \n\t\t\treturn false; \n\t} \n\n\treturn true; \n} \n\n\/\/ Function to check if a prime number \n\/\/ can be expressed as sum of \n\/\/ two Prime Numbers \nbool isPossible(int N) \n{ \n\t\/\/ if the number is prime, \n\t\/\/ and number-2 is also prime \n\tif (isPrime(N) && isPrime(N - 2)) \n\t\treturn true; \n\telse\n\t\treturn false; \n} \n\n\/\/ Driver code \nint main() \n{ \n\tint n = 13; \n\n\tif (isPossible(n)) \n\t\tcout << \"Yes\"; \n\telse\n\t\tcout << \"No\"; \n\n\treturn 0; \n} \n",
        "category":"Basic Math Operations",
        "sub_category":"Decision",
        "adoption":true,
        "reason":null,
        "module_name":"PrimeSumChecker",
        "testbench":"SC_MODULE(Testbench) {\n    sc_signal<int> n_sig;       \/\/ Signal for the input number\n    sc_signal<bool> result_sig; \/\/ Signal for the result\n\n    \/\/ Instance of the PrimeSumChecker module\n    PrimeSumChecker checker_inst;\n\n    \/\/ Constructor: Initialize the module and run the test thread\n    SC_CTOR(Testbench)\n    : checker_inst(\"checker_inst\") {\n        \/\/ Connect signals to module ports\n        checker_inst.n_in(n_sig);\n        checker_inst.result_out(result_sig);\n\n        \/\/ Create a test thread to provide stimulus and check the result\n        SC_THREAD(run_tests);\n    }\n\n    \/\/ Thread to run test cases\n    void run_tests() {\n        \/\/ Test case: n = 13 (expected result: true)\n        n_sig.write(13);\n        wait(1, SC_NS); \/\/ Wait for the process to update\n        bool result = result_sig.read();\n        std::cout << \"Can 13 be expressed as the sum of two primes? \" << (result ? \"Yes\" : \"No\") << std::endl;\n        assert(result == true);\n\n        \/\/ Additional test case: n = 17 (expected result: false)\n        n_sig.write(17);\n        wait(1, SC_NS);\n        result = result_sig.read();\n        std::cout << \"Can 17 be expressed as the sum of two primes? \" << (result ? \"Yes\" : \"No\") << std::endl;\n        assert(result == false);\n\n        \/\/ End simulation after successful tests\n        std::cout << \"All tests passed successfully.\" << std::endl;\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); \/\/ Instantiate the testbench module\n    sc_start();         \/\/ Start the simulation\n    return 0;\n}\n",
        "signal":"sc_in<int> n_in;\nsc_out<bool> result_out;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input. \n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<int> n_in;\nsc_out<bool> result_out;\n> **Note**: Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n\n**C++\/C Code**:\n```\n\/\/ C++ program to check if a prime number can be expressed as sum of two Prime Numbers \n#include <bits\/stdc++.h> \nusing namespace std; \n\n\/\/ Function to check whether \n\/\/ a number is prime or not \nbool isPrime(int n) \n{ \n\tif (n <= 1) \n\t\treturn false; \n\n\tfor (int i = 2; i <= sqrt(n); i++) \n\t{ \n\t\tif (n % i == 0) \n\t\t\treturn false; \n\t} \n\n\treturn true; \n} \n\n\/\/ Function to check if a prime number \n\/\/ can be expressed as sum of \n\/\/ two Prime Numbers \nbool isPossible(int N) \n{ \n\t\/\/ if the number is prime, \n\t\/\/ and number-2 is also prime \n\tif (isPrime(N) && isPrime(N - 2)) \n\t\treturn true; \n\telse\n\t\treturn false; \n} \n\n\/\/ Driver code \nint main() \n{ \n\tint n = 13; \n\n\tif (isPossible(n)) \n\t\tcout << \"Yes\"; \n\telse\n\t\tcout << \"No\"; \n\n\treturn 0; \n} \n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":17,
        "task":"MergeSort",
        "code":"\/\/ C++ program for the implementation of merge sort\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n\/\/ Merges two subarrays of vec.\n\/\/ First subarray is vec[left..mid]\n\/\/ Second subarray is vec[mid+1..right]\nvoid merge(vector<int>& vec, int left, int mid, int right) {\n    int i, j, k;\n    int n1 = mid - left + 1;\n    int n2 = right - mid;\n\n    \/\/ Create temporary vectors\n    vector<int> leftVec(n1), rightVec(n2);\n\n    \/\/ Copy data to temporary vectors\n    for (i = 0; i < n1; i++)\n        leftVec[i] = vec[left + i];\n    for (j = 0; j < n2; j++)\n        rightVec[j] = vec[mid + 1 + j];\n\n    \/\/ Merge the temporary vectors back into vec[left..right]\n    i = 0;\n    j = 0;\n    k = left;\n    while (i < n1 && j < n2) {\n        if (leftVec[i] <= rightVec[j]) {\n            vec[k] = leftVec[i];\n            i++;\n        } else {\n            vec[k] = rightVec[j];\n            j++;\n        }\n        k++;\n    }\n\n    \/\/ Copy the remaining elements of leftVec[], if any\n    while (i < n1) {\n        vec[k] = leftVec[i];\n        i++;\n        k++;\n    }\n\n    \/\/ Copy the remaining elements of rightVec[], if any\n    while (j < n2) {\n        vec[k] = rightVec[j];\n        j++;\n        k++;\n    }\n}\n\n\/\/ The subarray to be sorted is in the index range [left..right]\nvoid mergeSort(vector<int>& vec, int left, int right) {\n    if (left < right) {\n      \n        \/\/ Calculate the midpoint\n        int mid = left + (right - left) \/ 2;\n\n        \/\/ Sort first and second halves\n        mergeSort(vec, left, mid);\n        mergeSort(vec, mid + 1, right);\n\n        \/\/ Merge the sorted halves\n        merge(vec, left, mid, right);\n    }\n}\n\nint main() {\n    vector<int> vec = {12, 11, 13, 5, 6, 7};\n    int n = vec.size();\n\n    \/\/ Sorting vec using mergesort\n    mergeSort(vec, 0, n - 1);\n\n    for (auto i: vec)\n        cout << i << \" \";\n    return 0;\n}\n",
        "category":"Array Operations",
        "sub_category":"Array Sorting",
        "adoption":false,
        "reason":"Too complex",
        "module_name":null,
        "testbench":null,
        "signal":null,
        "prompt":null
    },
    {
        "task_id":18,
        "task":"Swaptwonumbers",
        "code":"\/\/ C++ program to swap two\n\/\/ numbers using 3rd variable\n#include <bits\/stdc++.h>\nusing namespace std;\n\n\/\/ Driver code\nint main()\n{\n    int a = 2, b = 3;\n\n    cout << \"Before swapping a = \" << a << \" , b = \" << b\n         << endl;\n\n    \/\/ temporary variable\n    int temp;\n\n    \/\/ appying swapping algorithm\n    temp = a;\n    a = b;\n    b = temp;\n    cout << \"After swapping a = \" << a << \" , b = \" << b\n         << endl;\n\n    return 0;\n}\n",
        "category":"Basic Math Operations",
        "sub_category":"Basic Math Operations",
        "adoption":true,
        "reason":null,
        "module_name":"Swapper",
        "testbench":"SC_MODULE(Testbench) {\n    sc_signal<int> a;      \/\/ Signal for the first number.\n    sc_signal<int> b;      \/\/ Signal for the second number.\n    sc_signal<int> out_a;  \/\/ Signal for the swapped output of a.\n    sc_signal<int> out_b;  \/\/ Signal for the swapped output of b.\n\n    Swapper swapper_inst;  \/\/ Instance of the Swapper module.\n\n    SC_CTOR(Testbench) : swapper_inst(\"swapper_inst\") {\n        \/\/ Connect the signals to the Swapper module ports.\n        swapper_inst.a(a);\n        swapper_inst.b(b);\n        swapper_inst.out_a(out_a);\n        swapper_inst.out_b(out_b);\n\n        \/\/ Create a thread to run test cases.\n        SC_THREAD(run_tests);\n    }\n\n    void run_tests() {\n        \/\/ Set initial values (equivalent to a = 2, b = 3 in the C++ code).\n        a.write(2);\n        b.write(3);\n        wait(1, SC_NS); \/\/ Allow time for the Swapper module to process the inputs.\n\n        \/\/ Assert that the swap operation has been performed correctly.\n        assert(out_a.read() == 3); \/\/ After swapping, out_a should be 3.\n        assert(out_b.read() == 2); \/\/ After swapping, out_b should be 2.\n\n        \/\/ Print the values before and after the swap.\n        cout << \"Before swapping a = \" << a.read() << \" , b = \" << b.read() << endl;\n        cout << \"After swapping a = \" << out_a.read() << \" , b = \" << out_b.read() << endl;\n        cout << \"All tests passed successfully.\" << endl;\n\n        sc_stop(); \/\/ Stop the simulation.\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); \/\/ Instantiate the Testbench.\n    sc_start();         \/\/ Start the simulation.\n    return 0;\n}\n",
        "signal":"sc_in<int> a;\nsc_in<int> b;\nsc_out<int> out_a;\nsc_out<int> out_b;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input. \n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<int> a;\nsc_in<int> b;\nsc_out<int> out_a;\nsc_out<int> out_b;\n> **Note**: Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n\n**C++\/C Code**:\n```\n\/\/ C++ program to swap two\n\/\/ numbers using 3rd variable\n#include <bits\/stdc++.h>\nusing namespace std;\n\n\/\/ Driver code\nint main()\n{\n    int a = 2, b = 3;\n\n    cout << \"Before swapping a = \" << a << \" , b = \" << b\n         << endl;\n\n    \/\/ temporary variable\n    int temp;\n\n    \/\/ appying swapping algorithm\n    temp = a;\n    a = b;\n    b = temp;\n    cout << \"After swapping a = \" << a << \" , b = \" << b\n         << endl;\n\n    return 0;\n}\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":19,
        "task":"FibonacciNumber",
        "code":"\/\/ C++ Program to find the nth fibonacci number using loops\n#include <bits\/stdc++.h>\nusing namespace std;\n\nint fib(int n) {\n  \n      \/\/ For 0th and 1st term\n    if (n <= 1)\n        return n;\n    \n      \/\/ Variable to store the last two terms\n    int prev1 = 1, prev2 = 0;\n      \n      \/\/ Variable that stores the current fibonacci term\n      int curr;\n\n    \/\/ Calculating the next fibonacci number by using\n      \/\/ the previous two number\n    for (int i = 2; i <= n; i++) {\n        curr = prev1 + prev2;\n        prev2 = prev1;\n        prev1 = curr;\n    }\n    return curr;\n}\n\nint main() {\n    int n = 5;\n    \n      \/\/ Finding the nth fibonacci number\n    cout << fib(n);\n    return 0;\n}\n",
        "category":"Basic Math Operations",
        "sub_category":"Basic Math Operations",
        "adoption":true,
        "reason":null,
        "module_name":"FibonacciCalculator",
        "testbench":"SC_MODULE(Testbench) {\n    sc_signal<int> n_sig;          \/\/ Signal for the input position\n    sc_signal<int> result_sig;      \/\/ Signal for the output Fibonacci number\n\n    \/\/ Instance of the FibonacciCalculator module\n    FibonacciCalculator fib_inst;\n\n    \/\/ Constructor: Initialize the module and run the test thread\n    SC_CTOR(Testbench)\n    : fib_inst(\"fib_inst\") {\n        \/\/ Connect signals to module ports\n        fib_inst.n(n_sig);\n        fib_inst.result(result_sig);\n\n        \/\/ Create a test thread to provide stimulus and check the result\n        SC_THREAD(run_tests);\n    }\n\n    \/\/ Thread to run test cases\n    void run_tests() {\n        \/\/ Test case: n = 5 (expected Fibonacci number = 5)\n        n_sig.write(5);\n        wait(1, SC_NS); \/\/ Wait for the process to update\n        int result = result_sig.read();\n        std::cout << \"Fibonacci number at position \" << n_sig.read() << \" is \" << result << std::endl;\n        assert(result == 5);\n\n        \/\/ Additional test case: n = 10 (expected Fibonacci number = 55)\n        n_sig.write(10);\n        wait(1, SC_NS);\n        result = result_sig.read();\n        std::cout << \"Fibonacci number at position \" << n_sig.read() << \" is \" << result << std::endl;\n        assert(result == 55);\n\n        \/\/ End simulation after successful tests\n        std::cout << \"All tests passed successfully.\" << std::endl;\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); \/\/ Instantiate the testbench module\n    sc_start();         \/\/ Start the simulation\n    return 0;\n}\n",
        "signal":"sc_in<int> n;\nsc_out<int> result;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input. \n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<int> n;\nsc_out<int> result;\n> **Note**: Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n\n**C++\/C Code**:\n```\n\/\/ C++ Program to find the nth fibonacci number using loops\n#include <bits\/stdc++.h>\nusing namespace std;\n\nint fib(int n) {\n  \n      \/\/ For 0th and 1st term\n    if (n <= 1)\n        return n;\n    \n      \/\/ Variable to store the last two terms\n    int prev1 = 1, prev2 = 0;\n      \n      \/\/ Variable that stores the current fibonacci term\n      int curr;\n\n    \/\/ Calculating the next fibonacci number by using\n      \/\/ the previous two number\n    for (int i = 2; i <= n; i++) {\n        curr = prev1 + prev2;\n        prev2 = prev1;\n        prev1 = curr;\n    }\n    return curr;\n}\n\nint main() {\n    int n = 5;\n    \n      \/\/ Finding the nth fibonacci number\n    cout << fib(n);\n    return 0;\n}\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":20,
        "task":"FindCommonArrayElements",
        "code":"\/\/ C++ program to find common elements between two Arrays using set_intersection()\n#include <bits\/stdc++.h>\nusing namespace std;\n\nint main() {\n    int arr1[] = {1, 45, 54, 71, 76, 12};\n    int arr2[] = {1, 7, 5, 4, 6, 12};\n\n    \/\/ Compute the sizes\n    int n1 = sizeof(arr1) \/ sizeof(arr1[0]);\n    int n2 = sizeof(arr2) \/ sizeof(arr2[0]);\n\n    \/\/ Sort the arrays\n    sort(arr1, arr1 + n1);\n    sort(arr2, arr2 + n2);\n\n    \/\/ Vector to store result\n    vector<int> v;\n    \n    \/\/ Finding common elements using\n    \/\/ set_intersection() function\n    set_intersection(arr1, arr1 + n1, arr2,\n        arr2 + n2, back_inserter(v));\n\n    for (auto i: v){\n        cout << i << \" \";\n    }\n    return 0;\n}\n",
        "category":"Array Operations",
        "sub_category":"Array Processing",
        "adoption":false,
        "reason":"Unknown output length",
        "module_name":null,
        "testbench":null,
        "signal":null,
        "prompt":null
    },
    {
        "task_id":21,
        "task":"FindGCD",
        "code":"\/\/ C++ program to find GCD of two numbers using simple arithmetic\n#include <bits\/stdc++.h>\nusing namespace std;\n\nint gcd(int a, int b) {\n    \/\/ Find Minimum of a and b\n    int res = min(a, b);\n\n      \/\/ Testing divisiblity with all numbers starting from\n    \/\/ min(a, b) to 1\n\n    while (res > 1) {\n\n        \/\/ If any number divide both a and b, so we\n        \/\/ got the answer\n        if (a % res == 0 && b % res == 0)\n            break;\n        res--;\n    }\n    return res;\n}\n\nint main() {\n    int a = 12, b = 16;\n  \n    \/\/ Finding gcd of two numbers a and b\n\n\n    cout << gcd(a, b);\n    return 0;\n}\n",
        "category":"Basic Math Operations",
        "sub_category":"Basic Math Operations",
        "adoption":true,
        "reason":null,
        "module_name":"GcdCalculator",
        "testbench":"SC_MODULE(Testbench) {\n    sc_signal<int> a_sig;       \/\/ Signal for the first input\n    sc_signal<int> b_sig;       \/\/ Signal for the second input\n    sc_signal<int> gcd_sig;     \/\/ Signal for the GCD output\n\n    \/\/ Instance of the GcdCalculator module\n    GcdCalculator gcd_inst;\n\n    \/\/ Constructor: Initialize the module and run the test thread\n    SC_CTOR(Testbench)\n    : gcd_inst(\"gcd_inst\") {\n        \/\/ Connect signals to module ports\n        gcd_inst.a(a_sig);\n        gcd_inst.b(b_sig);\n        gcd_inst.gcd_result(gcd_sig);\n\n        \/\/ Create a test thread to provide stimulus and check the result\n        SC_THREAD(run_tests);\n    }\n\n    \/\/ Thread to run test cases\n    void run_tests() {\n        \/\/ Test case: a = 12, b = 16 (expected GCD = 4)\n        a_sig.write(12);\n        b_sig.write(16);\n        wait(1, SC_NS); \/\/ Wait for the process to update\n        int result = gcd_sig.read();\n        std::cout << \"GCD(\" << a_sig.read() << \", \" << b_sig.read() << \") = \" << result << std::endl;\n        assert(result == 4);\n\n        \/\/ Additional test case: a = 48, b = 18 (expected GCD = 6)\n        a_sig.write(48);\n        b_sig.write(18);\n        wait(1, SC_NS);\n        result = gcd_sig.read();\n        std::cout << \"GCD(\" << a_sig.read() << \", \" << b_sig.read() << \") = \" << result << std::endl;\n        assert(result == 6);\n\n        \/\/ End simulation after successful tests\n        std::cout << \"All tests passed successfully.\" << std::endl;\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); \/\/ Instantiate the testbench module\n    sc_start();         \/\/ Start the simulation\n    return 0;\n}\n",
        "signal":"sc_in<int> a;\nsc_in<int> b;\nsc_out<int> gcd_result;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input. \n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<int> a;\nsc_in<int> b;\nsc_out<int> gcd_result;\n> **Note**: Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n\n**C++\/C Code**:\n```\n\/\/ C++ program to find GCD of two numbers using simple arithmetic\n#include <bits\/stdc++.h>\nusing namespace std;\n\nint gcd(int a, int b) {\n    \/\/ Find Minimum of a and b\n    int res = min(a, b);\n\n      \/\/ Testing divisiblity with all numbers starting from\n    \/\/ min(a, b) to 1\n\n    while (res > 1) {\n\n        \/\/ If any number divide both a and b, so we\n        \/\/ got the answer\n        if (a % res == 0 && b % res == 0)\n            break;\n        res--;\n    }\n    return res;\n}\n\nint main() {\n    int a = 12, b = 16;\n  \n    \/\/ Finding gcd of two numbers a and b\n\n\n    cout << gcd(a, b);\n    return 0;\n}\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":22,
        "task":"CheckEvenorOddIntegers",
        "code":"\/\/ C++ program to check if the number is even or odd using modulo operator\n#include <bits\/stdc++.h>\nusing namespace std;\n\nint main() {\n    int n = 11;\n\n    \/\/ If n is completely divisible by 2\n    if (n % 2 == 0)\n        cout << \"Even\";\n\n    \/\/ If n is NOT completely divisible by 2\n    else\n        cout << \"Odd\";\n    return 0;\n}\n",
        "category":"Basic Math Operations",
        "sub_category":"Decision",
        "adoption":true,
        "reason":null,
        "module_name":"EvenOddChecker",
        "testbench":"SC_MODULE(Testbench) {\n    sc_signal<int> number_sig;   \/\/ Signal for the input number\n    sc_signal<int> result_sig;   \/\/ Signal for the result\n\n    EvenOddChecker checker_inst; \/\/ Instance of the EvenOddChecker module\n\n    SC_CTOR(Testbench)\n    : checker_inst(\"checker_inst\")\n    {\n        checker_inst.number_in(number_sig);\n        checker_inst.result_out(result_sig);\n        SC_THREAD(run_tests);\n    }\n\n    void run_tests() {\n        \/\/ Test case 1: Number 11 (Odd)\n        number_sig.write(11);\n        wait(1, SC_NS);\n        std::cout << result_sig.read() << std::endl; \/\/ Expected output: 1\n        assert(result_sig.read() == 1);\n\n        \/\/ Test case 2: Number 12 (Even)\n        number_sig.write(12);\n        wait(1, SC_NS);\n        std::cout << result_sig.read() << std::endl; \/\/ Expected output: 0\n        assert(result_sig.read() == 0);\n        \n        std::cout << \"All tests pass successfully!\" << std::endl;\n        \/\/ End simulation\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\");\n    sc_start();\n    return 0;\n}\n",
        "signal":"sc_in<int> number_in;\nsc_out<int> result_out;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input. \n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<int> number_in;\nsc_out<int> result_out;\n> **Note**: Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n\n**C++\/C Code**:\n```\n\/\/ C++ program to check if the number is even or odd using modulo operator\n#include <bits\/stdc++.h>\nusing namespace std;\n\nint main() {\n    int n = 11;\n\n    \/\/ If n is completely divisible by 2\n    if (n % 2 == 0)\n        cout << \"Even\";\n\n    \/\/ If n is NOT completely divisible by 2\n    else\n        cout << \"Odd\";\n    return 0;\n}\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":23,
        "task":"DisplayPrimeNumbersBetweenTwoIntervalsUsingFunction",
        "code":"\/\/ C Program to Find Prime Numbers in a Given Range using Trial Division method\n#include <stdbool.h>\n#include <stdio.h>\n\nbool isPrime(int n) {\n\n    \/\/ Checking primality by finding a complete division\n      \/\/ in the range 2 to n-1\n    if (n <= 1)\n        return false;\n    for (int i = 2; i < n; i++) {\n        if (n % i == 0)\n            return false;\n    }\n    return true;\n}\n\nvoid findPrimes(int l, int r) {\n\n    \/\/ Flag to check if any prime numbers are found\n    bool found = false;\n    for (int i = l; i <= r; i++) {\n\n        \/\/ Checking if the number is prime\n        if (isPrime(i)) {\n            printf(\"%d \", i);\n            found = true;\n        }\n    }\n    if (!found) {\n        printf(\n            \"No prime numbers found in the given range.\");\n    }\n}\n\nint main() {\n    int l = 10, r = 30;\n    \n      \/\/ Finding and printing the prime between [l, r]\n    findPrimes(l, r);\n  \n    return 0;\n}\n",
        "category":"Miscellaneous",
        "sub_category":"Miscellaneous",
        "adoption":false,
        "reason":null,
        "module_name":null,
        "testbench":null,
        "signal":null,
        "prompt":null
    },
    {
        "task_id":24,
        "task":"AddTwoComplexNumbers",
        "code":"\/\/ C++ Program to Add Two Complex Numbers\n\n\/\/ Importing all libraries\n#include<bits\/stdc++.h>\nusing namespace std;\n\n\/\/ User Defined Complex class\nclass Complex \n{ \n\t\/\/ Declaring variables\n\tpublic: int real, imaginary;\n\n\t\/\/ Constructor to accept\n\t\/\/ real and imaginary part\n\tComplex(int tempReal = 0, \n\t\t\tint tempImaginary = 0)\n\t{\n\t\treal = tempReal;\n\t\timaginary = tempImaginary;\n\t}\n\n\t\/\/ Defining addComp() method\n\t\/\/ for adding two complex number\n\tComplex addComp(Complex C1, Complex C2)\n\t{\n\t\t\/\/ Creating temporary variable\n\t\tComplex temp;\n\n\t\t\/\/ Adding real part of \n\t\t\/\/ complex numbers\n\t\ttemp.real = C1.real + C2.real;\n\n\t\t\/\/ Adding Imaginary part of \n\t\t\/\/ complex numbers\n\t\ttemp.imaginary = (C1.imaginary + C2.imaginary);\n\n\t\t\/\/ Returning the sum\n\t\treturn temp;\n\t}\n};\n\n\/\/ Driver code\nint main()\n{\n\t\/\/ First Complex number\n\tComplex C1(3, 2);\n\n\t\/\/ printing first complex number\n\tcout << \"Complex number 1 : \" << \n\t\t\tC1.real << \" + i\" << \n\t\t\tC1.imaginary << endl;\n\n\t\/\/ Second Complex number\n\tComplex C2(9, 5);\n\n\t\/\/ Printing second complex number\n\tcout << \"Complex number 2 : \" << \n\t\t\tC2.real << \" + i\" << \n\t\t\tC2.imaginary << endl;\n\n\t\/\/ For Storing the sum\n\tComplex C3;\n\n\t\/\/ Calling addComp() method\n\tC3 = C3.addComp(C1, C2);\n\n\t\/\/ Printing the sum\n\tcout << \"Sum of complex number : \" << \n\t\t\tC3.real << \" + i\" << \n\t\t\tC3.imaginary;\n}\n",
        "category":"Basic Math Operations",
        "sub_category":"Basic Math Operations",
        "adoption":true,
        "reason":null,
        "module_name":"ComplexAdder",
        "testbench":"SC_MODULE(Testbench) {\n    sc_signal<int> real1;   \/\/ Signal for the real part of the first complex number\n    sc_signal<int> imag1;   \/\/ Signal for the imaginary part of the first complex number\n    sc_signal<int> real2;   \/\/ Signal for the real part of the second complex number\n    sc_signal<int> imag2;   \/\/ Signal for the imaginary part of the second complex number\n    sc_signal<int> real_sum;  \/\/ Signal for the real part of the sum\n    sc_signal<int> imag_sum;  \/\/ Signal for the imaginary part of the sum\n\n    ComplexAdder adder_inst; \/\/ Instance of the ComplexAdder module\n\n    \/\/ Constructor\n    SC_CTOR(Testbench) : adder_inst(\"adder\") {\n        \/\/ Connect signals to ports\n        adder_inst.real1(real1);\n        adder_inst.imag1(imag1);\n        adder_inst.real2(real2);\n        adder_inst.imag2(imag2);\n        adder_inst.real_sum(real_sum);\n        adder_inst.imag_sum(imag_sum);\n\n        \/\/ Process to run tests\n        SC_THREAD(run_tests);\n    }\n\n    \/\/ Thread to run test cases\n    void run_tests() {\n        \/\/ Test case: Adding complex numbers (3 + 2i) and (9 + 5i)\n        real1 = 3; imag1 = 2;\n        real2 = 9; imag2 = 5;\n        wait(1, SC_NS); \/\/ Wait for the adder to process\n        \n        \/\/ Use assertions to check that the sum is as expected\n        assert(real_sum.read() == 12 && \"Real sum is incorrect!\");\n        assert(imag_sum.read() == 7 && \"Imaginary sum is incorrect!\");\n\n        \/\/ Test case: Adding complex numbers (3 - 3i) and (9 + 5i)\n        real1 = 3; imag1 = -3;\n        real2 = 9; imag2 = 5;\n        wait(1, SC_NS); \/\/ Wait for the adder to process\n\n        \/\/ Use assertions to check that the sum is as expected\n        assert(real_sum.read() == 12 && \"Real sum is incorrect!\");\n        assert(imag_sum.read() == 2 && \"Imaginary sum is incorrect!\");\n\n        std::cout << \"All tests passed successfully.\" << std::endl;\n\n        sc_stop(); \/\/ Stop the simulation\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); \/\/ Create an instance of the Testbench\n\n    \/\/ Start the simulation\n    sc_start();\n\n    return 0;\n}\n",
        "signal":"sc_in<int> real1;\nsc_in<int> imag1;\nsc_in<int> real2;\nsc_in<int> imag2;\nsc_out<int> real_sum;\nsc_out<int> imag_sum;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input. \n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<int> real1;\nsc_in<int> imag1;\nsc_in<int> real2;\nsc_in<int> imag2;\nsc_out<int> real_sum;\nsc_out<int> imag_sum;\n> **Note**: Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n\n**C++\/C Code**:\n```\n\/\/ C++ Program to Add Two Complex Numbers\n\n\/\/ Importing all libraries\n#include<bits\/stdc++.h>\nusing namespace std;\n\n\/\/ User Defined Complex class\nclass Complex \n{ \n\t\/\/ Declaring variables\n\tpublic: int real, imaginary;\n\n\t\/\/ Constructor to accept\n\t\/\/ real and imaginary part\n\tComplex(int tempReal = 0, \n\t\t\tint tempImaginary = 0)\n\t{\n\t\treal = tempReal;\n\t\timaginary = tempImaginary;\n\t}\n\n\t\/\/ Defining addComp() method\n\t\/\/ for adding two complex number\n\tComplex addComp(Complex C1, Complex C2)\n\t{\n\t\t\/\/ Creating temporary variable\n\t\tComplex temp;\n\n\t\t\/\/ Adding real part of \n\t\t\/\/ complex numbers\n\t\ttemp.real = C1.real + C2.real;\n\n\t\t\/\/ Adding Imaginary part of \n\t\t\/\/ complex numbers\n\t\ttemp.imaginary = (C1.imaginary + C2.imaginary);\n\n\t\t\/\/ Returning the sum\n\t\treturn temp;\n\t}\n};\n\n\/\/ Driver code\nint main()\n{\n\t\/\/ First Complex number\n\tComplex C1(3, 2);\n\n\t\/\/ printing first complex number\n\tcout << \"Complex number 1 : \" << \n\t\t\tC1.real << \" + i\" << \n\t\t\tC1.imaginary << endl;\n\n\t\/\/ Second Complex number\n\tComplex C2(9, 5);\n\n\t\/\/ Printing second complex number\n\tcout << \"Complex number 2 : \" << \n\t\t\tC2.real << \" + i\" << \n\t\t\tC2.imaginary << endl;\n\n\t\/\/ For Storing the sum\n\tComplex C3;\n\n\t\/\/ Calling addComp() method\n\tC3 = C3.addComp(C1, C2);\n\n\t\/\/ Printing the sum\n\tcout << \"Sum of complex number : \" << \n\t\t\tC3.real << \" + i\" << \n\t\t\tC3.imaginary;\n}\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":25,
        "task":"PrintPascalsTriangle",
        "code":"\/\/  C++ code for Pascal's Triangle\n#include <iostream>\nusing namespace std;\n\n\/\/ See https:\/\/www.geeksforgeeks.org\/space-and-time-efficient-binomial-coefficient\/ \n\/\/ for details of this function\nint binomialCoeff(int n, int k);\n\n\/\/ Function to print first\n\/\/ n lines of Pascal's \n\/\/ Triangle\nvoid printPascal(int n)\n{\n    \/\/ Iterate through every line and\n    \/\/ print entries in it\n    for (int line = 0; line < n; line++)\n    {\n        \/\/ Every line has number of \n        \/\/ integers equal to line \n        \/\/ number\n        for (int i = 0; i <= line; i++)\n            cout <<\" \"<< binomialCoeff(line, i);\n        cout <<\"\\n\";\n    }\n}\n\n\/\/ See https:\/\/www.geeksforgeeks.org\/space-and-time-efficient-binomial-coefficient\/\n\/\/ for details of this function\nint binomialCoeff(int n, int k)\n{\n    int res = 1;\n    if (k > n - k)\n    k = n - k;\n    for (int i = 0; i < k; ++i)\n    {\n        res *= (n - i);\n        res \/= (i + 1);\n    }\n    \n    return res;\n}\n\n\/\/ Driver program \nint main()\n{\n    int n = 7;\n    printPascal(n);\n    return 0;\n}\n",
        "category":"Miscellaneous",
        "sub_category":"Miscellaneous",
        "adoption":false,
        "reason":null,
        "module_name":null,
        "testbench":null,
        "signal":null,
        "prompt":null
    },
    {
        "task_id":26,
        "task":"Sortthe2DArrayAcrossRows",
        "code":"\/\/ C++ code to \n\/\/ sort 2D matrix row-wise\n#include<bits\/stdc++.h>\nusing namespace std;\n\n\/\/Swap function \nvoid swap(int *xp, int *yp) \n{ \n\tint temp = *xp; \n\t*xp = *yp; \n\t*yp = temp; \n} \nvoid sortRowWise(int m[][4],\n\t\t\t\tint r, int c)\n{\n\/\/ loop for rows of matrix\nfor (int i = 0; i < r; i++) \n{\n\t\/\/ loop for column of matrix\n\tfor (int j = 0; j < c; j++) \n\t{\n\t\/\/ loop for comparison and swapping\n\tfor (int k = 0; k < c - j - 1; k++) \n\t{\n\t\tif (m[i][k] > m[i][k + 1]) \n\t\t{\n\t\t\/\/ swapping of elements\n\t\tswap(m[i][k], m[i][k + 1]);\n\t\t}\n\t}\n\t}\n}\n\n\/\/ printing the sorted matrix\nfor (int i = 0; i < r; i++) \n{\n\tfor (int j = 0; j < c; j++)\n\tcout << m[i][j] << \" \";\n\tcout << endl;\n}\n}\n\n\/\/ Driver code\nint main()\n{\nint m[][4] = {{9, 8, 7, 1},\n\t\t\t\t{7, 3, 0, 2},\n\t\t\t\t{9, 5, 3, 2},\n\t\t\t\t{6, 3, 1, 2}};\nint c = sizeof(m[0]) \/ sizeof(m[0][0]);\nint r = sizeof(m) \/ sizeof(m[0]);\nsortRowWise(m, r, c);\nreturn 0;\n}\n\n\/\/ This code is contributed by Rutvik_56\n",
        "category":"Matrix Operations",
        "sub_category":"Matrix Operations",
        "adoption":true,
        "reason":null,
        "module_name":"RowWiseSorter",
        "testbench":"SC_MODULE(Testbench) {\n    sc_clock clk;          \/\/ Clock signal for synchronization\n    sc_signal<bool> start; \/\/ Signal to trigger sorting\n    sc_signal<bool> done;  \/\/ Signal indicating sorting completion\n\n    \/\/ Instance of the RowWiseSorter module\n    RowWiseSorter* sorter;\n\n    SC_CTOR(Testbench) : clk(\"clk\", 1, SC_NS) {\n        sorter = new RowWiseSorter(\"RowWiseSorter\");\n        sorter->clk(clk);\n        sorter->start(start);\n        sorter->done(done);\n\n        SC_THREAD(run_tests);\n    }\n\n    \/\/ Process: Run the test, compare sorted matrix with expected output\n    void run_tests() {\n        \/\/ Define the unsorted input matrix (same as the C++ code)\n        int matrix_in[4][4] = {\n            {9, 8, 7, 1},\n            {7, 3, 0, 2},\n            {9, 5, 3, 2},\n            {6, 3, 1, 2}\n        };\n\n        \/\/ Expected sorted matrix\n        int expected[4][4] = {\n            {1, 7, 8, 9},\n            {0, 2, 3, 7},\n            {2, 3, 5, 9},\n            {1, 2, 3, 6}\n        };\n\n        \/\/ Load the input matrix into the sorter\n        sorter->load_matrix(matrix_in);\n\n        \/\/ Trigger the sorting process\n        start.write(true);\n        wait(1, SC_NS);\n        start.write(false);\n\n        \/\/ Wait until the sorter indicates that sorting is done\n        while (done.read() != true) {\n            wait(1, SC_NS);\n        }\n\n        \/\/ Retrieve the sorted matrix\n        int matrix_out[4][4];\n        sorter->read_matrix(matrix_out);\n\n        \/\/ Assert that each element of the sorted matrix is as expected\n        for (int i = 0; i < 4; i++) {\n            for (int j = 0; j < 4; j++) {\n                assert(matrix_out[i][j] == expected[i][j]);\n                std::cout << \"Row \" << i << \", Col \" << j \n                          << \" sorted value: \" << matrix_out[i][j] << std::endl;\n            }\n        }\n        std::cout << \"All tests passed successfully.\" << std::endl;\n\n        sc_stop(); \/\/ End simulation\n    }\n};\n\n\/\/ sc_main: Entry point for the SystemC simulation\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"Testbench\"); \/\/ Instantiate the testbench\n    sc_start();                \/\/ Start the simulation\n    return 0;\n}\n",
        "signal":"sc_in<bool> clk;\nsc_in<bool> start;\nsc_out<bool> done;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input. \n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<bool> clk;\nsc_in<bool> start;\nsc_out<bool> done;\n> **Note**: Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n\n**C++\/C Code**:\n```\n\/\/ C++ code to \n\/\/ sort 2D matrix row-wise\n#include<bits\/stdc++.h>\nusing namespace std;\n\n\/\/Swap function \nvoid swap(int *xp, int *yp) \n{ \n\tint temp = *xp; \n\t*xp = *yp; \n\t*yp = temp; \n} \nvoid sortRowWise(int m[][4],\n\t\t\t\tint r, int c)\n{\n\/\/ loop for rows of matrix\nfor (int i = 0; i < r; i++) \n{\n\t\/\/ loop for column of matrix\n\tfor (int j = 0; j < c; j++) \n\t{\n\t\/\/ loop for comparison and swapping\n\tfor (int k = 0; k < c - j - 1; k++) \n\t{\n\t\tif (m[i][k] > m[i][k + 1]) \n\t\t{\n\t\t\/\/ swapping of elements\n\t\tswap(m[i][k], m[i][k + 1]);\n\t\t}\n\t}\n\t}\n}\n\n\/\/ printing the sorted matrix\nfor (int i = 0; i < r; i++) \n{\n\tfor (int j = 0; j < c; j++)\n\tcout << m[i][j] << \" \";\n\tcout << endl;\n}\n}\n\n\/\/ Driver code\nint main()\n{\nint m[][4] = {{9, 8, 7, 1},\n\t\t\t\t{7, 3, 0, 2},\n\t\t\t\t{9, 5, 3, 2},\n\t\t\t\t{6, 3, 1, 2}};\nint c = sizeof(m[0]) \/ sizeof(m[0][0]);\nint r = sizeof(m) \/ sizeof(m[0]);\nsortRowWise(m, r, c);\nreturn 0;\n}\n\n\/\/ This code is contributed by Rutvik_56\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\n#include <systemc.h>\n\n\/\/ Use static const for constants instead of #define\nstatic const int N = 4;\nstatic const int SIZE = N * N;\n\n\/\/ Module that performs matrix addition\nSC_MODULE(MatrixAdder) {\n    \/\/ Input ports for matrices A and B (flattened as 1D arrays)\n    sc_in<int> A[SIZE];\n    sc_in<int> B[SIZE];\n    \/\/ Output ports for matrix C (flattened as 1D array)\n    sc_out<int> C[SIZE];\n\n    SC_CTOR(MatrixAdder) {\n        \/\/ Use an SC_METHOD to perform combinational matrix addition\n        SC_METHOD(do_add);\n        for (int i = 0; i < SIZE; i++) {\n            sensitive << A[i] << B[i];\n        }\n    }\n\n    \/\/ Method that adds corresponding elements of A and B\n    void do_add() {\n        for (int i = 0; i < SIZE; i++) {\n            C[i].write(A[i].read() + B[i].read());\n        }\n    }\n};\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":27,
        "task":"FindFactorialofaNumber",
        "code":"\/\/ C++ program for factorial of a number\n#include <iostream>\nusing namespace std;\n\n\/\/ Function to find factorial of\n\/\/ given number\nunsigned int factorial(unsigned int n)\n{\n\tint res = 1, i;\n\tfor (i = 2; i <= n; i++)\n\t\tres *= i;\n\treturn res;\n}\n\n\/\/ Driver code\nint main()\n{\n\tint num = 5;\n\tcout << \"Factorial of \" << num << \" is \"\n\t\t<< factorial(num) << endl;\n\treturn 0;\n}\n",
        "category":"Basic Math Operations",
        "sub_category":"Basic Math Operations",
        "adoption":true,
        "reason":null,
        "module_name":"Factorial",
        "testbench":"SC_MODULE(Testbench) {\n    sc_signal<unsigned int> num_sig;   \/\/ Signal to drive the input number\n    sc_signal<unsigned int> fact_sig;  \/\/ Signal to capture the output factorial\n\n    Factorial factorial_inst;  \/\/ Instance of the Factorial module\n\n    \/\/ Constructor: initialize the instance and connect signals\n    SC_CTOR(Testbench) : factorial_inst(\"factorial_inst\") {\n        factorial_inst.in(num_sig);\n        factorial_inst.out(fact_sig);\n\n        \/\/ Create a thread to run the test cases\n        SC_THREAD(run_tests);\n    }\n\n    \/\/ Thread that sets up test cases and checks the output\n    void run_tests() {\n        \/\/ Test case: Compute factorial for 5\n        num_sig.write(5);\n        wait(1, SC_NS);  \/\/ Wait for the process to execute\n\n        \/\/ Read the computed factorial value\n        unsigned int result = fact_sig.read();\n        cout << \"Factorial of 5 is \" << result << endl;\n        \/\/ Assert that the computed result is correct (120 for 5!)\n        assert(result == 120);\n\n        \/\/ Test case: Compute factorial for 0\n        num_sig.write(0);\n        wait(1, SC_NS);  \/\/ Wait for the process to execute\n        result = fact_sig.read();\n        cout << \"Factorial of 0 is \" << result << endl;\n        \/\/ Assert that the computed result is correct (1 for 0!)\n        assert(result == 1);\n\n        std::cout << \"All test passed successfully!\" << std::endl;\n        sc_stop();\n    }\n};\n\n\/\/ sc_main: Entry point for the SystemC simulation\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\");  \/\/ Create an instance of the Testbench module\n    sc_start();          \/\/ Start the simulation\n    return 0;\n}\n",
        "signal":"sc_in<unsigned int> in;\nsc_out<unsigned int> out;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input. \n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<unsigned int> in;\nsc_out<unsigned int> out;\n> **Note**: Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n\n**C++\/C Code**:\n```\n\/\/ C++ program for factorial of a number\n#include <iostream>\nusing namespace std;\n\n\/\/ Function to find factorial of\n\/\/ given number\nunsigned int factorial(unsigned int n)\n{\n\tint res = 1, i;\n\tfor (i = 2; i <= n; i++)\n\t\tres *= i;\n\treturn res;\n}\n\n\/\/ Driver code\nint main()\n{\n\tint num = 5;\n\tcout << \"Factorial of \" << num << \" is \"\n\t\t<< factorial(num) << endl;\n\treturn 0;\n}\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":28,
        "task":"CalculateFahrenheittoCelsius",
        "code":"\/\/ C++ program to convert Fahrenheit scale to Celsius scale\n#include <bits\/stdc++.h>\nusing namespace std;\n\n\/\/ Function to convert Fahrenheit \n\/\/ to Celsius\nfloat Conversion(float n)\n{\n\treturn (n - 32.0) * 5.0 \/ 9.0;\n}\n\n\/\/ Driver code\nint main()\n{\n\tfloat n = 40;\n\tcout << Conversion(n);\n\treturn 0;\n}\n",
        "category":"Basic Math Operations",
        "sub_category":"Format Conversion",
        "adoption":true,
        "reason":null,
        "module_name":"TempConverter",
        "testbench":"SC_MODULE(Testbench) {\n    sc_signal<float> fahrenheit; \/\/ Signal for Fahrenheit temperature\n    sc_signal<float> celsius;    \/\/ Signal for Celsius temperature\n\n    TempConverter converter_inst; \/\/ Instance of the TempConverter module\n\n    \/\/ Constructor\n    SC_CTOR(Testbench) : converter_inst(\"converter\") {\n        \/\/ Connect signals to ports\n        converter_inst.fahrenheit(fahrenheit);\n        converter_inst.celsius(celsius);\n\n        \/\/ Process to run tests\n        SC_THREAD(run_tests);\n    }\n\n    \/\/ Thread to run test cases\n    void run_tests() {\n        \/\/ Test case 1: Convert 40\u00b0F to Celsius\n        fahrenheit = 40.0;\n        wait(1, SC_NS); \/\/ Wait for the converter to process\n        float result = celsius.read();\n        cout << \"40\u00b0F in Celsius: \" << result << \"\u00b0C\" << endl;\n        assert(abs(result - 4.44444) < 0.0001); \/\/ Allow for floating-point precision errors\n\n        \/\/ Test case 2: Convert 100\u00b0F to Celsius\n        fahrenheit = 100.0;\n        wait(1, SC_NS);\n        result = celsius.read();\n        cout << \"100\u00b0F in Celsius: \" << result << \"\u00b0C\" << endl;\n        assert(abs(result - 37.7778) < 0.0001);\n\n        \/\/ Test case 3: Convert 32\u00b0F to Celsius (Freezing point of water)\n        fahrenheit = 32.0;\n        wait(1, SC_NS);\n        result = celsius.read();\n        cout << \"32\u00b0F in Celsius: \" << result << \"\u00b0C\" << endl;\n        assert(abs(result - 0.0) < 0.0001);\n\n        \/\/ Test case 4: Convert 212\u00b0F to Celsius (Boiling point of water)\n        fahrenheit = 212.0;\n        wait(1, SC_NS);\n        result = celsius.read();\n        cout << \"212\u00b0F in Celsius: \" << result << \"\u00b0C\" << endl;\n        assert(abs(result - 100.0) < 0.0001);\n\n        \/\/ Print success message\n        cout << \"All tests passed successfully.\" << endl;\n\n        sc_stop(); \/\/ Stop the simulation\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); \/\/ Create an instance of the Testbench\n\n    \/\/ Start the simulation\n    sc_start();\n\n    return 0;\n}\n",
        "signal":"sc_in<float> fahrenheit;\nsc_out<float> celsius;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input. \n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<float> fahrenheit;\nsc_out<float> celsius;\n> **Note**: Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n\n**C++\/C Code**:\n```\n\/\/ C++ program to convert Fahrenheit scale to Celsius scale\n#include <bits\/stdc++.h>\nusing namespace std;\n\n\/\/ Function to convert Fahrenheit \n\/\/ to Celsius\nfloat Conversion(float n)\n{\n\treturn (n - 32.0) * 5.0 \/ 9.0;\n}\n\n\/\/ Driver code\nint main()\n{\n\tfloat n = 40;\n\tcout << Conversion(n);\n\treturn 0;\n}\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":29,
        "task":"RotateMatrixElementsofaMatrix",
        "code":"\/\/ C++ program to rotate a matrix \n#include <iostream> \n#define R 4 \n#define C 4 \nusing namespace std; \n\n\/\/ A function to rotate a matrix \n\/\/ mat[][] of size R x C. \n\/\/ Initially, m = R and n = C \nvoid rotatematrix(int m, int n, \n\t\t\t\tint mat[R][C]) \n{ \n\tint row = 0, col = 0; \n\tint prev, curr; \n\n\t\/* row - Starting row index \n\tm - ending row index \n\tcol - starting column index \n\tn - ending column index \n\ti - iterator *\/\n\twhile (row < m && col < n) \n\t{ \n\t\tif (row + 1 == m || \n\t\t\tcol + 1 == n) \n\t\t\tbreak; \n\n\t\t\/\/ Store the first element of \n\t\t\/\/ next row, this element will \n\t\t\/\/ replace first element of current \n\t\t\/\/ row \n\t\tprev = mat[row + 1][col]; \n\n\t\t\/* Move elements of first row from \n\t\tthe remaining rows *\/\n\t\tfor (int i = col; i < n; i++) \n\t\t{ \n\t\t\tcurr = mat[row][i]; \n\t\t\tmat[row][i] = prev; \n\t\t\tprev = curr; \n\t\t} \n\t\trow++; \n\n\t\t\/* Move elements of last column \n\t\tfrom the remaining columns *\/\n\t\tfor (int i = row; i < m; i++) \n\t\t{ \n\t\t\tcurr = mat[i][n-1]; \n\t\t\tmat[i][n-1] = prev; \n\t\t\tprev = curr; \n\t\t} \n\t\tn--; \n\n\t\t\/* Move elements of last row from \n\t\tthe remaining rows *\/\n\t\tif (row < m) \n\t\t{ \n\t\t\tfor (int i = n-1; i >= col; i--) \n\t\t\t{ \n\t\t\t\tcurr = mat[m-1][i]; \n\t\t\t\tmat[m-1][i] = prev; \n\t\t\t\tprev = curr; \n\t\t\t} \n\t\t} \n\t\tm--; \n\n\t\t\/* Move elements of first column from \n\t\tthe remaining rows *\/\n\t\tif (col < n) \n\t\t{ \n\t\t\tfor (int i = m-1; i >= row; i--) \n\t\t\t{ \n\t\t\t\tcurr = mat[i][col]; \n\t\t\t\tmat[i][col] = prev; \n\t\t\t\tprev = curr; \n\t\t\t} \n\t\t} \n\t\tcol++; \n\t} \n\n\t\/\/ Print rotated matrix \n\tfor (int i=0; i<R; i++) \n\t{ \n\t\tfor (int j=0; j<C; j++) \n\t\tcout << mat[i][j] << \" \"; \n\t\tcout << endl; \n\t} \n} \n\n\/\/ Driver code \nint main() \n{ \n\t\/\/ Test Case 1 \n\tint a[R][C] = {{1, 2, 3, 4}, \n\t\t\t\t{5, 6, 7, 8}, \n\t\t\t\t{9, 10, 11, 12}, \n\t\t\t\t{13, 14, 15, 16}}; \n\n\t\/\/ Test Case 2 \n\t\/* int a[R][C] = {{1, 2, 3}, \n\t\t\t\t\t{4, 5, 6}, \n\t\t\t\t\t{7, 8, 9}}; \n\t*\/ rotatematrix(R, C, a); \n\treturn 0; \n} \n",
        "category":"Matrix Operations",
        "sub_category":"Matrix Operations",
        "adoption":true,
        "reason":null,
        "module_name":"MatrixRotator",
        "testbench":"SC_MODULE(Testbench) {\n    \/\/ Using static const for matrix dimensions instead of #define\n    static const int N = 4;\n    static const int SIZE = N * N;\n    \n    \/\/ Signals to connect to the MatrixRotator ports\n    sc_signal<int> in[SIZE];\n    sc_signal<int> out[SIZE];\n\n    MatrixRotator* matrixRotator;\n\n    SC_CTOR(Testbench) {\n        \/\/ Instantiate the MatrixRotator module\n        matrixRotator = new MatrixRotator(\"matrixRotator\");\n        \/\/ Connect the signals\n        for (int i = 0; i < SIZE; i++) {\n            matrixRotator->in[i](in[i]);\n            matrixRotator->out[i](out[i]);\n        }\n        SC_THREAD(run_tests);\n    }\n\n    \/\/ Thread to initialize the matrix, check outputs, and assert correctness\n    void run_tests() {\n        \/\/ Initialize the matrix with test values:\n        \/\/ { 1,  2,  3,  4,\n        \/\/   5,  6,  7,  8,\n        \/\/   9, 10, 11, 12,\n        \/\/  13, 14, 15, 16 }\n        int init[SIZE] = {\n            1, 2, 3, 4,\n            5, 6, 7, 8,\n            9, 10, 11, 12,\n            13, 14, 15, 16\n        };\n        for (int i = 0; i < SIZE; i++) {\n            in[i].write(init[i]);\n        }\n\n        \/\/ Wait for the signals to propagate\n        wait(1, SC_NS);\n\n        \/\/ Expected rotated matrix is:\n        \/\/  5   1   2   3\n        \/\/  9  10   6   4\n        \/\/ 13  11   7   8\n        \/\/ 14  15  16  12\n        int expected[SIZE] = {\n            5, 1, 2, 3,\n            9, 10, 6, 4,\n            13, 11, 7, 8,\n            14, 15, 16, 12\n        };\n\n        \/\/ Check the output matrix and print the result\n        std::cout << \"Rotated Matrix:\" << std::endl;\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                int index = i * N + j;\n                int result = out[index].read();\n                std::cout << result << \" \";\n                \/\/ Validate the result using assert\n                assert(result == expected[index]);\n            }\n            std::cout << std::endl;\n        }\n        std::cout << \"All tests passed successfully.\" << std::endl;\n\n        sc_stop(); \/\/ End the simulation\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); \/\/ Create an instance of the Testbench\n    sc_start();         \/\/ Start the simulation\n    return 0;\n}\n",
        "signal":"sc_in<int> in[SIZE];\nsc_out<int> out[SIZE];",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input. \n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<int> in[SIZE];\nsc_out<int> out[SIZE];\n> **Note**: Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n\n**C++\/C Code**:\n```\n\/\/ C++ program to rotate a matrix \n#include <iostream> \n#define R 4 \n#define C 4 \nusing namespace std; \n\n\/\/ A function to rotate a matrix \n\/\/ mat[][] of size R x C. \n\/\/ Initially, m = R and n = C \nvoid rotatematrix(int m, int n, \n\t\t\t\tint mat[R][C]) \n{ \n\tint row = 0, col = 0; \n\tint prev, curr; \n\n\t\/* row - Starting row index \n\tm - ending row index \n\tcol - starting column index \n\tn - ending column index \n\ti - iterator *\/\n\twhile (row < m && col < n) \n\t{ \n\t\tif (row + 1 == m || \n\t\t\tcol + 1 == n) \n\t\t\tbreak; \n\n\t\t\/\/ Store the first element of \n\t\t\/\/ next row, this element will \n\t\t\/\/ replace first element of current \n\t\t\/\/ row \n\t\tprev = mat[row + 1][col]; \n\n\t\t\/* Move elements of first row from \n\t\tthe remaining rows *\/\n\t\tfor (int i = col; i < n; i++) \n\t\t{ \n\t\t\tcurr = mat[row][i]; \n\t\t\tmat[row][i] = prev; \n\t\t\tprev = curr; \n\t\t} \n\t\trow++; \n\n\t\t\/* Move elements of last column \n\t\tfrom the remaining columns *\/\n\t\tfor (int i = row; i < m; i++) \n\t\t{ \n\t\t\tcurr = mat[i][n-1]; \n\t\t\tmat[i][n-1] = prev; \n\t\t\tprev = curr; \n\t\t} \n\t\tn--; \n\n\t\t\/* Move elements of last row from \n\t\tthe remaining rows *\/\n\t\tif (row < m) \n\t\t{ \n\t\t\tfor (int i = n-1; i >= col; i--) \n\t\t\t{ \n\t\t\t\tcurr = mat[m-1][i]; \n\t\t\t\tmat[m-1][i] = prev; \n\t\t\t\tprev = curr; \n\t\t\t} \n\t\t} \n\t\tm--; \n\n\t\t\/* Move elements of first column from \n\t\tthe remaining rows *\/\n\t\tif (col < n) \n\t\t{ \n\t\t\tfor (int i = m-1; i >= row; i--) \n\t\t\t{ \n\t\t\t\tcurr = mat[i][col]; \n\t\t\t\tmat[i][col] = prev; \n\t\t\t\tprev = curr; \n\t\t\t} \n\t\t} \n\t\tcol++; \n\t} \n\n\t\/\/ Print rotated matrix \n\tfor (int i=0; i<R; i++) \n\t{ \n\t\tfor (int j=0; j<C; j++) \n\t\tcout << mat[i][j] << \" \"; \n\t\tcout << endl; \n\t} \n} \n\n\/\/ Driver code \nint main() \n{ \n\t\/\/ Test Case 1 \n\tint a[R][C] = {{1, 2, 3, 4}, \n\t\t\t\t{5, 6, 7, 8}, \n\t\t\t\t{9, 10, 11, 12}, \n\t\t\t\t{13, 14, 15, 16}}; \n\n\t\/\/ Test Case 2 \n\t\/* int a[R][C] = {{1, 2, 3}, \n\t\t\t\t\t{4, 5, 6}, \n\t\t\t\t\t{7, 8, 9}}; \n\t*\/ rotatematrix(R, C, a); \n\treturn 0; \n} \n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\n#include <systemc.h>\n\n\/\/ Use static const for constants instead of #define\nstatic const int N = 4;\nstatic const int SIZE = N * N;\n\n\/\/ Module that performs matrix addition\nSC_MODULE(MatrixAdder) {\n    \/\/ Input ports for matrices A and B (flattened as 1D arrays)\n    sc_in<int> A[SIZE];\n    sc_in<int> B[SIZE];\n    \/\/ Output ports for matrix C (flattened as 1D array)\n    sc_out<int> C[SIZE];\n\n    SC_CTOR(MatrixAdder) {\n        \/\/ Use an SC_METHOD to perform combinational matrix addition\n        SC_METHOD(do_add);\n        for (int i = 0; i < SIZE; i++) {\n            sensitive << A[i] << B[i];\n        }\n    }\n\n    \/\/ Method that adds corresponding elements of A and B\n    void do_add() {\n        for (int i = 0; i < SIZE; i++) {\n            C[i].write(A[i].read() + B[i].read());\n        }\n    }\n};\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":30,
        "task":"SortanArray_BubbleSort",
        "code":"\/\/ C program for implementation of Bubble sort\n#include <stdio.h>\n\nvoid swap(int* arr, int i, int j) {\n    int temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n}\n\nvoid bubbleSort(int arr[], int n) {\n    for (int i = 0; i < n - 1; i++) {\n      \n        \/\/ Last i elements are already in place, so the loop\n        \/\/ will only num n - i - 1 times\n        for (int j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[j + 1])\n                swap(arr, j, j + 1);\n        }\n    }\n}\n\nint main() {\n    int arr[] = { 6, 0, 3, 5 };\n    int n = sizeof(arr) \/ sizeof(arr[0]);\n\n    \/\/ Calling bubble sort on array arr\n    bubbleSort(arr, n);\n\n    for (int i = 0; i < n; i++)\n        printf(\"%d \", arr[i]);\n\n    return 0;\n}\n",
        "category":"Array Operations",
        "sub_category":"Array Sorting",
        "adoption":false,
        "reason":"Few shot example",
        "module_name":"BubbleSort",
        "testbench":"SC_MODULE(Testbench) {\n    sc_clock clk;          \/\/ Clock signal for synchronization\n    sc_signal<bool> start; \/\/ Signal to trigger the sort\n    sc_signal<bool> done;  \/\/ Signal indicating sort completion\n\n    \/\/ Instance of the BubbleSort module\n    BubbleSort* bubble_sort_inst;\n\n    SC_CTOR(Testbench) : clk(\"clk\", 1, SC_NS) {\n        bubble_sort_inst = new BubbleSort(\"bubble_sort_inst\");\n        bubble_sort_inst->clk(clk);\n        bubble_sort_inst->start(start);\n        bubble_sort_inst->done(done);\n\n        SC_THREAD(run_tests);\n    }\n\n    \/\/ Process to run the test cases\n    void run_tests() {\n        \/\/ Initialize the array with unsorted values {6, 0, 3, 5}\n        int arr_in[4] = {6, 0, 3, 5};\n        bubble_sort_inst->load_array(arr_in);\n\n        \/\/ Start the sorting process\n        start.write(true);\n        wait(1, SC_NS); \/\/ wait for one clock cycle\n        start.write(false);\n\n        \/\/ Wait until the bubble sort module signals that sorting is done\n        while (done.read() != true) {\n            wait(1, SC_NS);\n        }\n        \n        \/\/ Retrieve the sorted array from the BubbleSort module\n        int arr_out[4];\n        bubble_sort_inst->read_array(arr_out);\n\n        \/\/ Expected sorted result is {0, 3, 5, 6}\n        int expected[4] = {0, 3, 5, 6};\n\n        \/\/ Verify that each element is sorted as expected\n        for (int i = 0; i < 4; i++) {\n            assert(arr_out[i] == expected[i]);\n            cout << \"Element \" << i << \" sorted value: \" << arr_out[i] << endl;\n        }\n        cout << \"All tests passed successfully.\" << endl;\n\n        sc_stop(); \/\/ End simulation\n    }\n};\n\n\/\/ sc_main: Entry point for the SystemC simulation\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); \/\/ Create the testbench instance\n    sc_start();         \/\/ Start the simulation\n    return 0;\n}\n",
        "signal":"sc_in<bool> clk;\nsc_in<bool> start;\nsc_out<bool> done;",
        "prompt":null
    },
    {
        "task_id":31,
        "task":"FindtheRootsoftheQuadraticEquation",
        "code":"\/\/ C++ program to find roots of\n\/\/ a quadratic equation\n#include <bits\/stdc++.h>\nusing namespace std;\n\n\/\/ Prints roots of quadratic equation\n\/\/ ax*2 + bx + x\nvoid findRoots(int a, int b, int c)\n{\n    \/\/ If a is 0, then equation is\n    \/\/ not quadratic, but linear\n    if (a == 0) {\n        cout << \"Invalid\";\n        return;\n    }\n\n    int d = b * b - 4 * a * c;\n    double sqrt_val = sqrt(abs(d));\n\n    if (d > 0) {\n        cout << \"Roots are real and different \";\n        cout << (double)(-b + sqrt_val) \/ (2 * a) << \" \"\n             << (double)(-b - sqrt_val) \/ (2 * a);\n    }\n    else if (d == 0) {\n        cout << \"Roots are real and same \";\n        cout << -(double)b \/ (2 * a);\n    }\n\n    \/\/ d < 0\n    else {\n        cout << \"Roots are complex \";\n        cout << -(double)b \/ (2 * a) << \" + i\"\n             << sqrt_val \/ (2 * a) << \" \"\n             << -(double)b \/ (2 * a) << \" - i\"\n             << sqrt_val \/ (2 * a);\n    }\n}\n\n\/\/ Driver code\nint main()\n{\n    int a = 1, b = -7, c = 12;\n\n    \/\/ Function call\n    findRoots(a, b, c);\n    return 0;\n}\n",
        "category":"Basic Math Operations",
        "sub_category":"Basic Math Operations",
        "adoption":false,
        "reason":"Too many signals",
        "module_name":null,
        "testbench":null,
        "signal":null,
        "prompt":null
    },
    {
        "task_id":32,
        "task":"BinarytoDecimalConversion",
        "code":"\/\/ C++ program to convert binary to decimal \n#include <iostream> \nusing namespace std; \n\n\/\/ Function to convert binary \n\/\/ to decimal \nint binaryToDecimal(int n) \n{ \n\tint num = n; \n\tint dec_value = 0; \n\n\t\/\/ Initializing base value to \n\t\/\/ 1, i.e 2^0 \n\tint base = 1; \n\n\tint temp = num; \n\twhile (temp) { \n\t\tint last_digit = temp % 10; \n\t\ttemp = temp \/ 10; \n\t\tdec_value += last_digit * base; \n\t\tbase = base * 2; \n\t} \n\n\treturn dec_value; \n} \n\n\/\/ Driver code \nint main() \n{ \n\tint num = 10101001; \n\tcout << binaryToDecimal(num) << endl; \n}\n",
        "category":"Basic Math Operations",
        "sub_category":"Number Base Conversion",
        "adoption":true,
        "reason":null,
        "module_name":"BinaryToDecimalConverter",
        "testbench":"SC_MODULE(Testbench) {\n    sc_signal<int> binary_sig; \/\/ Signal for the binary number\n    sc_signal<int> decimal_sig; \/\/ Signal for the decimal number\n\n    BinaryToDecimalConverter converter_inst; \/\/ Instance of the converter module\n\n    \/\/ Constructor\n    SC_CTOR(Testbench) : converter_inst(\"converter\") {\n        \/\/ Connect signals to ports\n        converter_inst.binary_in(binary_sig);\n        converter_inst.decimal_out(decimal_sig);\n\n        \/\/ Process to run tests\n        SC_THREAD(run_tests);\n    }\n\n    \/\/ Thread to run test cases\n    void run_tests() {\n        \/\/ Test case 1: Convert binary 10101001 to decimal\n        binary_sig = 10101001;\n        wait(1, SC_NS); \/\/ Wait for the conversion to process\n        int result = decimal_sig.read();\n        cout << \"Binary: 10101001 -> Decimal: \" << result << endl;\n        assert(result == 169);\n\n        \/\/ Test case 2: Convert binary 1111 to decimal\n        binary_sig = 1111;\n        wait(1, SC_NS);\n        result = decimal_sig.read();\n        cout << \"Binary: 1111 -> Decimal: \" << result << endl;\n        assert(result == 15);\n\n        \/\/ Test case 3: Convert binary 100000 to decimal\n        binary_sig = 100000;\n        wait(1, SC_NS);\n        result = decimal_sig.read();\n        cout << \"Binary: 100000 -> Decimal: \" << result << endl;\n        assert(result == 32);\n\n        \/\/ Print success message\n        cout << \"All tests passed successfully.\" << endl;\n\n        sc_stop(); \/\/ Stop the simulation\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); \/\/ Create an instance of the Testbench\n\n    \/\/ Start the simulation\n    sc_start();\n\n    return 0;\n}\n",
        "signal":"sc_in<int> binary_in;\nsc_out<int> decimal_out;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input. \n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<int> binary_in;\nsc_out<int> decimal_out;\n> **Note**: Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n\n**C++\/C Code**:\n```\n\/\/ C++ program to convert binary to decimal \n#include <iostream> \nusing namespace std; \n\n\/\/ Function to convert binary \n\/\/ to decimal \nint binaryToDecimal(int n) \n{ \n\tint num = n; \n\tint dec_value = 0; \n\n\t\/\/ Initializing base value to \n\t\/\/ 1, i.e 2^0 \n\tint base = 1; \n\n\tint temp = num; \n\twhile (temp) { \n\t\tint last_digit = temp % 10; \n\t\ttemp = temp \/ 10; \n\t\tdec_value += last_digit * base; \n\t\tbase = base * 2; \n\t} \n\n\treturn dec_value; \n} \n\n\/\/ Driver code \nint main() \n{ \n\tint num = 10101001; \n\tcout << binaryToDecimal(num) << endl; \n}\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":33,
        "task":"SortanArray_SelectionSort",
        "code":"\/\/ C++ program for implementation of \n\/\/ selection sort \n#include <bits\/stdc++.h> \nusing namespace std; \n\n\/\/Swap function \nvoid swap(int *xp, int *yp) \n{ \n\tint temp = *xp; \n\t*xp = *yp; \n\t*yp = temp; \n} \n\nvoid selectionSort(int arr[], int n) \n{ \n\tint i, j, min_idx; \n\n\t\/\/ One by one move boundary of \n\t\/\/ unsorted subarray \n\tfor (i = 0; i < n-1; i++) \n\t{ \n\t\t\n\t\t\/\/ Find the minimum element in \n\t\t\/\/ unsorted array \n\t\tmin_idx = i; \n\t\tfor (j = i+1; j < n; j++) \n\t\tif (arr[j] < arr[min_idx]) \n\t\t\tmin_idx = j; \n\n\t\t\/\/ Swap the found minimum element \n\t\t\/\/ with the first element \n\t\tswap(&arr[min_idx], &arr[i]); \n\t} \n} \n\n\/\/Function to print an array \nvoid printArray(int arr[], int size) \n{ \n\tint i; \n\tfor (i=0; i < size; i++) \n\t\tcout << arr[i] << \" \"; \n\tcout << endl; \n} \n\n\/\/ Driver program to test above functions \nint main() \n{ \n\tint arr[] = {64, 25, 12, 22, 11}; \n\tint n = sizeof(arr)\/sizeof(arr[0]); \n\tselectionSort(arr, n); \n\tcout << \"Sorted array: \"; \n\tprintArray(arr, n); \n\treturn 0; \n} \n",
        "category":"Array Operations",
        "sub_category":"Array Sorting",
        "adoption":true,
        "reason":null,
        "module_name":"SelectionSort",
        "testbench":"SC_MODULE(Testbench) {\n    sc_clock clk;              \/\/ Clock signal for synchronization\n    sc_signal<bool> start;     \/\/ Signal to trigger the sort\n    sc_signal<bool> done;      \/\/ Signal indicating sort completion\n\n    \/\/ Instance of the SelectionSort module\n    SelectionSort* selection_sort_inst;\n\n    SC_CTOR(Testbench) : clk(\"clk\", 1, SC_NS) {\n        selection_sort_inst = new SelectionSort(\"selection_sort_inst\");\n        selection_sort_inst->clk(clk);\n        selection_sort_inst->start(start);\n        selection_sort_inst->done(done);\n\n        SC_THREAD(run_tests);\n    }\n\n    \/\/ Process to run the test cases\n    void run_tests() {\n        \/\/ Initialize the array with unsorted values {64, 25, 12, 22, 11}\n        int arr_in[5] = {64, 25, 12, 22, 11};\n        selection_sort_inst->load_array(arr_in);\n\n        \/\/ Start the sorting process\n        start.write(true);\n        wait(1, SC_NS); \/\/ Wait for one clock cycle\n        start.write(false);\n\n        \/\/ Wait until the SelectionSort module signals that sorting is done\n        while (done.read() != true) {\n            wait(1, SC_NS);\n        }\n        \n        \/\/ Retrieve the sorted array from the SelectionSort module\n        int arr_out[5];\n        selection_sort_inst->read_array(arr_out);\n\n        \/\/ Expected sorted result is {11, 12, 22, 25, 64}\n        int expected[5] = {11, 12, 22, 25, 64};\n\n        \/\/ Verify that each element is sorted as expected\n        for (int i = 0; i < 5; i++) {\n            assert(arr_out[i] == expected[i]);\n            cout << \"Element \" << i << \" sorted value: \" << arr_out[i] << endl;\n        }\n        cout << \"All tests passed successfully.\" << endl;\n\n        sc_stop(); \/\/ End simulation\n    }\n};\n\n\/\/ sc_main: Entry point for the SystemC simulation\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); \/\/ Create the testbench instance\n    sc_start();         \/\/ Start the simulation\n    return 0;\n}\n",
        "signal":"sc_in<bool> clk;\nsc_in<bool> start;\nsc_out<bool> done;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input. \n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<bool> clk;\nsc_in<bool> start;\nsc_out<bool> done;\n> **Note**: Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n\n**C++\/C Code**:\n```\n\/\/ C++ program for implementation of \n\/\/ selection sort \n#include <bits\/stdc++.h> \nusing namespace std; \n\n\/\/Swap function \nvoid swap(int *xp, int *yp) \n{ \n\tint temp = *xp; \n\t*xp = *yp; \n\t*yp = temp; \n} \n\nvoid selectionSort(int arr[], int n) \n{ \n\tint i, j, min_idx; \n\n\t\/\/ One by one move boundary of \n\t\/\/ unsorted subarray \n\tfor (i = 0; i < n-1; i++) \n\t{ \n\t\t\n\t\t\/\/ Find the minimum element in \n\t\t\/\/ unsorted array \n\t\tmin_idx = i; \n\t\tfor (j = i+1; j < n; j++) \n\t\tif (arr[j] < arr[min_idx]) \n\t\t\tmin_idx = j; \n\n\t\t\/\/ Swap the found minimum element \n\t\t\/\/ with the first element \n\t\tswap(&arr[min_idx], &arr[i]); \n\t} \n} \n\n\/\/Function to print an array \nvoid printArray(int arr[], int size) \n{ \n\tint i; \n\tfor (i=0; i < size; i++) \n\t\tcout << arr[i] << \" \"; \n\tcout << endl; \n} \n\n\/\/ Driver program to test above functions \nint main() \n{ \n\tint arr[] = {64, 25, 12, 22, 11}; \n\tint n = sizeof(arr)\/sizeof(arr[0]); \n\tselectionSort(arr, n); \n\tcout << \"Sorted array: \"; \n\tprintArray(arr, n); \n\treturn 0; \n} \n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\n#include <systemc.h>\n\n\/\/ BubbleSort Module: Implements the bubble sort algorithm\nSC_MODULE(BubbleSort) {\n    sc_in<bool> clk;      \/\/ Clock input\n    sc_in<bool> start;    \/\/ Signal to start sorting\n    sc_out<bool> done;    \/\/ Signal to indicate sorting is complete\n\n    \/\/ Internal storage for the array (fixed size of 4 elements)\n    int arr[4];\n\n    \/\/ Constructor: register the process\n    SC_CTOR(BubbleSort) {\n        SC_THREAD(sort_process);\n        sensitive << clk.pos();\n    }\n\n    \/\/ Process that waits for the start signal and performs sorting\n    void sort_process() {\n        while (true) {\n            wait(); \/\/ wait for a clock cycle\n            if (start.read() == true) {\n                bubbleSort(); \/\/ perform sorting\n                done.write(true);\n                wait(); \/\/ wait for one cycle to signal completion\n                done.write(false);\n            }\n        }\n    }\n\n    \/\/ Bubble sort algorithm implementation (sorts the internal array)\n    void bubbleSort() {\n        \/\/ Number of elements is fixed at 4\n        const int n = 4;\n        for (int i = 0; i < n - 1; i++) {\n            for (int j = 0; j < n - i - 1; j++) {\n                if (arr[j] > arr[j + 1]) {\n                    \/\/ Swap arr[j] and arr[j+1]\n                    int temp = arr[j];\n                    arr[j] = arr[j + 1];\n                    arr[j + 1] = temp;\n                }\n            }\n        }\n    }\n\n    \/\/ Helper method to load an input array into the module\n    void load_array(const int input[4]) {\n        for (int i = 0; i < 4; i++) {\n            arr[i] = input[i];\n        }\n    }\n\n    \/\/ Helper method to read the sorted array from the module\n    void read_array(int output[4]) {\n        for (int i = 0; i < 4; i++) {\n            output[i] = arr[i];\n        }\n    }\n};\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":34,
        "task":"FindQuotientandRemainder",
        "code":"\/\/ C++ program to find quotient\n\/\/ and remainder\n#include <iostream>\nusing namespace std;\n\n\/\/ Driver code\nint main()\n{\n    int Dividend, Quotient, Divisor, Remainder;\n\n    cout << \"Enter Dividend & Divisor: \";\n    cin >> Dividend >> Divisor;\n\n    \/\/ Check for division by zero\n    if (Divisor == 0) {\n        cout << \"Error: Divisor cannot be zero.\" << endl;\n    } else {\n        Quotient = Dividend \/ Divisor;\n        Remainder = Dividend % Divisor;\n\n        cout << \"The Quotient = \" << Quotient << endl;\n        cout << \"The Remainder = \" << Remainder << endl;\n    }\n    return 0;\n}\n",
        "category":"Basic Math Operations",
        "sub_category":"Basic Math Operations",
        "adoption":true,
        "reason":null,
        "module_name":"Divider",
        "testbench":"SC_MODULE(Testbench) {\n    sc_signal<int> Dividend;   \/\/ Signal for the dividend\n    sc_signal<int> Divisor;    \/\/ Signal for the divisor\n    sc_signal<int> Quotient;   \/\/ Signal for the quotient\n    sc_signal<int> Remainder;  \/\/ Signal for the remainder\n    sc_signal<bool> Error;     \/\/ Signal to indicate division by zero error\n\n    Divider divider_inst;       \/\/ Instance of the Divider module\n\n    \/\/ Constructor\n    SC_CTOR(Testbench) : divider_inst(\"divider\") {\n        \/\/ Connect signals to ports\n        divider_inst.Dividend(Dividend);\n        divider_inst.Divisor(Divisor);\n        divider_inst.Quotient(Quotient);\n        divider_inst.Remainder(Remainder);\n        divider_inst.Error(Error);\n\n        \/\/ Process to run tests\n        SC_THREAD(run_tests);\n    }\n\n    \/\/ Thread to run test cases\n    void run_tests() {\n        \/\/ Test case 1: Division by zero\n        Dividend = 10;\n        Divisor = 0;\n        wait(1, SC_NS);\n        assert(Error.read() == true && \"Division by zero case\");\n        cout << \"Test Case 1: Division by zero - Error: \" << Error.read() << endl;\n\n        \/\/ Test case 2: Normal division\n        Dividend = 20;\n        Divisor = 3;\n        wait(1, SC_NS);\n        assert(Error.read() == false);\n        assert(Quotient.read() == 6);\n        assert(Remainder.read() == 2);\n        cout << \"Test Case 2: Quotient: \" << Quotient.read() << \", Remainder: \" << Remainder.read() << endl;\n\n        \/\/ Test case 3: Exact division\n        Dividend = 15;\n        Divisor = 5;\n        wait(1, SC_NS);\n        assert(Error.read() == false);\n        assert(Quotient.read() == 3);\n        assert(Remainder.read() == 0);\n        cout << \"Test Case 3: Quotient: \" << Quotient.read() << \", Remainder: \" << Remainder.read() << endl;\n\n        \/\/ Test case 4: Negative dividend\n        Dividend = -20;\n        Divisor = 3;\n        wait(1, SC_NS);\n        assert(Error.read() == false);\n        assert(Quotient.read() == -6);\n        assert(Remainder.read() == -2);\n        cout << \"Test Case 4: Quotient: \" << Quotient.read() << \", Remainder: \" << Remainder.read() << endl;\n\n        \/\/ Test case 5: Negative divisor\n        Dividend = 20;\n        Divisor = -3;\n        wait(1, SC_NS);\n        assert(Error.read() == false);\n        assert(Quotient.read() == -6);\n        assert(Remainder.read() == 2);\n        cout << \"Test Case 5: Quotient: \" << Quotient.read() << \", Remainder: \" << Remainder.read() << endl;\n\n        \/\/ Test case 6: Both negative\n        Dividend = -20;\n        Divisor = -3;\n        wait(1, SC_NS);\n        assert(Error.read() == false);\n        assert(Quotient.read() == 6);\n        assert(Remainder.read() == -2);\n        cout << \"Test Case 6: Quotient: \" << Quotient.read() << \", Remainder: \" << Remainder.read() << endl;\n\n        \/\/ Print success message\n        cout << \"All tests passed successfully.\" << endl;\n\n        sc_stop(); \/\/ Stop the simulation\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); \/\/ Create an instance of the Testbench\n\n    \/\/ Start the simulation\n    sc_start();\n\n    return 0;\n}\n",
        "signal":"sc_in<int> Dividend;\nsc_in<int> Divisor;\nsc_out<int> Quotient;\nsc_out<int> Remainder;\nsc_out<bool> Error;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input. \n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<int> Dividend;\nsc_in<int> Divisor;\nsc_out<int> Quotient;\nsc_out<int> Remainder;\nsc_out<bool> Error;\n> **Note**: Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n\n**C++\/C Code**:\n```\n\/\/ C++ program to find quotient\n\/\/ and remainder\n#include <iostream>\nusing namespace std;\n\n\/\/ Driver code\nint main()\n{\n    int Dividend, Quotient, Divisor, Remainder;\n\n    cout << \"Enter Dividend & Divisor: \";\n    cin >> Dividend >> Divisor;\n\n    \/\/ Check for division by zero\n    if (Divisor == 0) {\n        cout << \"Error: Divisor cannot be zero.\" << endl;\n    } else {\n        Quotient = Dividend \/ Divisor;\n        Remainder = Dividend % Divisor;\n\n        cout << \"The Quotient = \" << Quotient << endl;\n        cout << \"The Remainder = \" << Remainder << endl;\n    }\n    return 0;\n}\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":35,
        "task":"FindtheDeterminantofaMatrix",
        "code":"#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nconst int MAXN = 105;\ndouble a[MAXN][MAXN];\n\ndouble determinant(int n) {\n\tdouble det = 1.0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint pivot = i;\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tif (abs(a[j][i]) > abs(a[pivot][i])) {\n\t\t\t\tpivot = j;\n\t\t\t}\n\t\t}\n\t\tif (pivot != i) {\n\t\t\tswap(a[i], a[pivot]);\n\t\t\tdet *= -1;\n\t\t}\n\t\tif (a[i][i] == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tdet *= a[i][i];\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tdouble factor = a[j][i] \/ a[i][i];\n\t\t\tfor (int k = i + 1; k < n; k++) {\n\t\t\t\ta[j][k] -= factor * a[i][k];\n\t\t\t}\n\t\t}\n\t}\n\treturn det;\n}\n\nint main() {\n\tint n = 4;\n\tdouble matrix[4][4] = {{1, 0, 2, -1},\n\t\t\t\t\t\t{3, 0, 0, 5},\n\t\t\t\t\t\t{2, 1, 4, -3},\n\t\t\t\t\t\t{1, 0, 5, 0}};\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\ta[i][j] = matrix[i][j];\n\t\t}\n\t}\n\tdouble det = determinant(n);\n\tcout << \"Determinant = \" << det << endl;\n\treturn 0;\n}\n",
        "category":"Matrix Operations",
        "sub_category":"Matrix Operations",
        "adoption":true,
        "reason":null,
        "module_name":"DeterminantCalculator",
        "testbench":"SC_MODULE(Testbench) {\n    \/\/ Use static const for constants\n    static const int N = 4;\n    static const int SIZE = N * N;\n    \n    sc_signal<double> matrix[SIZE];\n    sc_signal<double> det;\n\n    DeterminantCalculator* detCalc;\n\n    SC_CTOR(Testbench) {\n        detCalc = new DeterminantCalculator(\"detCalc\");\n        for (int i = 0; i < SIZE; i++) {\n            detCalc->matrix[i](matrix[i]);\n        }\n        detCalc->det(det);\n        SC_THREAD(run_tests);\n    }\n\n    \/\/ Thread to initialize matrix, check result, and assert correctness\n    void run_tests() {\n        \/\/ Initialize the 4x4 matrix (row-major order)\n        \/\/ Matrix:\n        \/\/ { {1, 0, 2, -1},\n        \/\/   {3, 0, 0, 5},\n        \/\/   {2, 1, 4, -3},\n        \/\/   {1, 0, 5, 0} }\n        double init_matrix[SIZE] = {\n            1, 0, 2, -1,\n            3, 0, 0, 5,\n            2, 1, 4, -3,\n            1, 0, 5, 0\n        };\n        for (int i = 0; i < SIZE; i++) {\n            matrix[i].write(init_matrix[i]);\n        }\n\n        \/\/ Wait for signals to propagate and process to complete\n        wait(2, SC_NS);\n\n        \/\/ Read the result and check\n        double result = det.read();\n        std::cout << \"Determinant = \" << result << std::endl;\n        \/\/ Expected determinant is 30 (as computed in the original code)\n        assert(std::abs(result - 30.0) < 1e-6);\n        std::cout << \"Test passed successfully\" << std::endl;\n\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\");\n    sc_start();\n    return 0;\n}\n",
        "signal":"sc_in<double> matrix[SIZE];\nsc_out<double> det;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input. \n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<double> matrix[SIZE];\nsc_out<double> det;\n> **Note**: Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n\n**C++\/C Code**:\n```\n#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nconst int MAXN = 105;\ndouble a[MAXN][MAXN];\n\ndouble determinant(int n) {\n\tdouble det = 1.0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint pivot = i;\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tif (abs(a[j][i]) > abs(a[pivot][i])) {\n\t\t\t\tpivot = j;\n\t\t\t}\n\t\t}\n\t\tif (pivot != i) {\n\t\t\tswap(a[i], a[pivot]);\n\t\t\tdet *= -1;\n\t\t}\n\t\tif (a[i][i] == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tdet *= a[i][i];\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tdouble factor = a[j][i] \/ a[i][i];\n\t\t\tfor (int k = i + 1; k < n; k++) {\n\t\t\t\ta[j][k] -= factor * a[i][k];\n\t\t\t}\n\t\t}\n\t}\n\treturn det;\n}\n\nint main() {\n\tint n = 4;\n\tdouble matrix[4][4] = {{1, 0, 2, -1},\n\t\t\t\t\t\t{3, 0, 0, 5},\n\t\t\t\t\t\t{2, 1, 4, -3},\n\t\t\t\t\t\t{1, 0, 5, 0}};\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\ta[i][j] = matrix[i][j];\n\t\t}\n\t}\n\tdouble det = determinant(n);\n\tcout << \"Determinant = \" << det << endl;\n\treturn 0;\n}\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\n#include <systemc.h>\n\n\/\/ Use static const for constants instead of #define\nstatic const int N = 4;\nstatic const int SIZE = N * N;\n\n\/\/ Module that performs matrix addition\nSC_MODULE(MatrixAdder) {\n    \/\/ Input ports for matrices A and B (flattened as 1D arrays)\n    sc_in<int> A[SIZE];\n    sc_in<int> B[SIZE];\n    \/\/ Output ports for matrix C (flattened as 1D array)\n    sc_out<int> C[SIZE];\n\n    SC_CTOR(MatrixAdder) {\n        \/\/ Use an SC_METHOD to perform combinational matrix addition\n        SC_METHOD(do_add);\n        for (int i = 0; i < SIZE; i++) {\n            sensitive << A[i] << B[i];\n        }\n    }\n\n    \/\/ Method that adds corresponding elements of A and B\n    void do_add() {\n        for (int i = 0; i < SIZE; i++) {\n            C[i].write(A[i].read() + B[i].read());\n        }\n    }\n};\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":36,
        "task":"FindPowerWithoutUsingMultiplicationAndDivisionOperators",
        "code":"\/\/ C++ code for power function \n#include <bits\/stdc++.h> \nusing namespace std; \n\n\/\/ Works only if a >= 0 \n\/\/ and b >= 0 \nint pow(int a, int b) \n{ \n\tif (b == 0) \n\t\treturn 1; \n\tint answer = a; \n\tint increment = a; \n\tint i, j; \n\tfor(i = 1; i < b; i++) \n\t{ \n\t\tfor(j = 1; j < a; j++) \n\t\t{ \n\t\t\tanswer += increment; \n\t\t} \n\t\tincrement = answer; \n\t} \n\treturn answer; \n} \n\n\/\/ Driver Code \nint main() \n{ \n\tcout << pow(5, 3); \n\treturn 0; \n} \n\n\/\/ This code is contributed by rathbhupendra \n",
        "category":"Miscellaneous",
        "sub_category":"Miscellaneous",
        "adoption":false,
        "reason":null,
        "module_name":null,
        "testbench":null,
        "signal":null,
        "prompt":null
    },
    {
        "task_id":37,
        "task":"SorttheElementsofanArrayinAscendingOrder",
        "code":"\/\/ C++ program to sort array \n\/\/ in ascending order using\n\/\/ Brute-force approach\n\/\/ using bubble sort\n#include <bits\/stdc++.h>\nusing namespace std;\n\nvoid sort(int num[], int len);\nvoid swapNums(int nums[], \n\t\t\tint first, int second);\n\n\/\/ Driver code\nint main()\n{\n\t\/\/ Initializing arrya\n\tint nums[] = {1, 12, 6, 8, 10};\n\tint size_nums = (sizeof(nums) \/ \n\t\t\t\t\tsizeof(nums[0]));\n\n\tcout << \"Before sorting the array is: \\n\";\n\tfor (int i = 0; i < size_nums; i++)\n\t\tcout << nums[i] << \" \";\n\tcout << \"\\n\\n\";\n\n\tsort(nums, size_nums);\n\n\tcout << \"After sorting the array is: \\n\";\n\n\tfor (int i = 0; i < size_nums; i++)\n\t\tcout << nums[i] << \" \";\n\tcout << \"\\n\";\n\treturn 0;\n}\n\n\/\/ Sort function\nvoid sort(int num[], int len)\n{\n\tbool isSwapped;\n\n\t\/**\n\t* Here we are running n-1 steps, \n\tfor each step, max item will \n\tcome at the last respective \n\tindex and swap element if the \n\telement is smaller than the \n\tprevious one.\n\t**\/\n\tfor (int i = 0; i < len; i++) \n\t{\n\t\tisSwapped = false;\n\t\tfor (int j = 1; j < len - i; j++) \n\t\t{\n\t\t\tif (num[j] < num[j - 1]) \n\t\t\t{\n\t\t\t\tswapNums(num, j, (j - 1));\n\t\t\t\tisSwapped = true;\n\t\t\t}\n\t\t}\n\t\tif (!isSwapped) \n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n\/\/ Swaps two numbers in array\nvoid swapNums(int nums[], \n\t\t\tint first, int second)\n{\n\tint curr = nums[first];\n\tnums[first] = nums[second];\n\tnums[second] = curr;\n}\n",
        "category":"Array Operations",
        "sub_category":"Array Sorting",
        "adoption":true,
        "reason":null,
        "module_name":"BubbleSort",
        "testbench":"SC_MODULE(Testbench) {\n    sc_clock clk;          \/\/ Clock signal for synchronization\n    sc_signal<bool> start; \/\/ Signal to trigger the sort\n    sc_signal<bool> done;  \/\/ Signal indicating sort completion\n\n    \/\/ Instance of the BubbleSort module\n    BubbleSort* bubble_sort_inst;\n\n    SC_CTOR(Testbench) : clk(\"clk\", 1, SC_NS) {\n        bubble_sort_inst = new BubbleSort(\"bubble_sort_inst\");\n        bubble_sort_inst->clk(clk);\n        bubble_sort_inst->start(start);\n        bubble_sort_inst->done(done);\n\n        SC_THREAD(run_tests);\n    }\n\n    \/\/ Process to run the test cases\n    void run_tests() {\n        \/\/ Initialize the array with unsorted values {1, 12, 6, 8, 10}\n        int arr_in[5] = {1, 12, 6, 8, 10};\n        bubble_sort_inst->load_array(arr_in);\n\n        \/\/ Print the array before sorting\n        cout << \"Before sorting: \";\n        for (int i = 0; i < 5; i++) {\n            cout << arr_in[i] << \" \";\n        }\n        cout << endl;\n\n        \/\/ Start the sorting process\n        start.write(true);\n        wait(1, SC_NS); \/\/ wait for one clock cycle\n        start.write(false);\n\n        \/\/ Wait until the BubbleSort module signals that sorting is complete\n        while (done.read() != true) {\n            wait(1, SC_NS);\n        }\n        \n        \/\/ Retrieve the sorted array from the BubbleSort module\n        int arr_out[5];\n        bubble_sort_inst->read_array(arr_out);\n\n        \/\/ Print the sorted array\n        cout << \"After sorting: \";\n        for (int i = 0; i < 5; i++) {\n            cout << arr_out[i] << \" \";\n        }\n        cout << endl;\n\n        \/\/ Expected sorted result is {1, 6, 8, 10, 12}\n        int expected[5] = {1, 6, 8, 10, 12};\n        for (int i = 0; i < 5; i++) {\n            assert(arr_out[i] == expected[i]);\n            cout << \"Element \" << i << \" sorted value: \" << arr_out[i] << endl;\n        }\n        cout << \"All tests passed successfully.\" << endl;\n\n        sc_stop(); \/\/ End simulation\n    }\n};\n\n\/\/ sc_main: Entry point for the SystemC simulation\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); \/\/ Create the testbench instance\n    sc_start();         \/\/ Start the simulation\n    return 0;\n}\n",
        "signal":"sc_in<bool> clk;\nsc_in<bool> start;\nsc_out<bool> done;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input. \n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<bool> clk;\nsc_in<bool> start;\nsc_out<bool> done;\n> **Note**: Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n\n**C++\/C Code**:\n```\n\/\/ C++ program to sort array \n\/\/ in ascending order using\n\/\/ Brute-force approach\n\/\/ using bubble sort\n#include <bits\/stdc++.h>\nusing namespace std;\n\nvoid sort(int num[], int len);\nvoid swapNums(int nums[], \n\t\t\tint first, int second);\n\n\/\/ Driver code\nint main()\n{\n\t\/\/ Initializing arrya\n\tint nums[] = {1, 12, 6, 8, 10};\n\tint size_nums = (sizeof(nums) \/ \n\t\t\t\t\tsizeof(nums[0]));\n\n\tcout << \"Before sorting the array is: \\n\";\n\tfor (int i = 0; i < size_nums; i++)\n\t\tcout << nums[i] << \" \";\n\tcout << \"\\n\\n\";\n\n\tsort(nums, size_nums);\n\n\tcout << \"After sorting the array is: \\n\";\n\n\tfor (int i = 0; i < size_nums; i++)\n\t\tcout << nums[i] << \" \";\n\tcout << \"\\n\";\n\treturn 0;\n}\n\n\/\/ Sort function\nvoid sort(int num[], int len)\n{\n\tbool isSwapped;\n\n\t\/**\n\t* Here we are running n-1 steps, \n\tfor each step, max item will \n\tcome at the last respective \n\tindex and swap element if the \n\telement is smaller than the \n\tprevious one.\n\t**\/\n\tfor (int i = 0; i < len; i++) \n\t{\n\t\tisSwapped = false;\n\t\tfor (int j = 1; j < len - i; j++) \n\t\t{\n\t\t\tif (num[j] < num[j - 1]) \n\t\t\t{\n\t\t\t\tswapNums(num, j, (j - 1));\n\t\t\t\tisSwapped = true;\n\t\t\t}\n\t\t}\n\t\tif (!isSwapped) \n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n\/\/ Swaps two numbers in array\nvoid swapNums(int nums[], \n\t\t\tint first, int second)\n{\n\tint curr = nums[first];\n\tnums[first] = nums[second];\n\tnums[second] = curr;\n}\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\n#include <systemc.h>\n\n\/\/ BubbleSort Module: Implements the bubble sort algorithm\nSC_MODULE(BubbleSort) {\n    sc_in<bool> clk;      \/\/ Clock input\n    sc_in<bool> start;    \/\/ Signal to start sorting\n    sc_out<bool> done;    \/\/ Signal to indicate sorting is complete\n\n    \/\/ Internal storage for the array (fixed size of 4 elements)\n    int arr[4];\n\n    \/\/ Constructor: register the process\n    SC_CTOR(BubbleSort) {\n        SC_THREAD(sort_process);\n        sensitive << clk.pos();\n    }\n\n    \/\/ Process that waits for the start signal and performs sorting\n    void sort_process() {\n        while (true) {\n            wait(); \/\/ wait for a clock cycle\n            if (start.read() == true) {\n                bubbleSort(); \/\/ perform sorting\n                done.write(true);\n                wait(); \/\/ wait for one cycle to signal completion\n                done.write(false);\n            }\n        }\n    }\n\n    \/\/ Bubble sort algorithm implementation (sorts the internal array)\n    void bubbleSort() {\n        \/\/ Number of elements is fixed at 4\n        const int n = 4;\n        for (int i = 0; i < n - 1; i++) {\n            for (int j = 0; j < n - i - 1; j++) {\n                if (arr[j] > arr[j + 1]) {\n                    \/\/ Swap arr[j] and arr[j+1]\n                    int temp = arr[j];\n                    arr[j] = arr[j + 1];\n                    arr[j + 1] = temp;\n                }\n            }\n        }\n    }\n\n    \/\/ Helper method to load an input array into the module\n    void load_array(const int input[4]) {\n        for (int i = 0; i < 4; i++) {\n            arr[i] = input[i];\n        }\n    }\n\n    \/\/ Helper method to read the sorted array from the module\n    void read_array(int output[4]) {\n        for (int i = 0; i < 4; i++) {\n            output[i] = arr[i];\n        }\n    }\n};\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":38,
        "task":"DecimaltoOctalConversion",
        "code":"\/\/ C++ program to convert a decimal number to octal number \n#include <iostream> \nusing namespace std; \n\n\/\/ Function to convert decimal to octal \nvoid decToOctal(int n) \n{ \n\t\/\/ Array to store octal number \n\tint octalNum[100]; \n\n\t\/\/ Counter for octal number array \n\tint i = 0; \n\twhile (n != 0) { \n\t\t\/\/ Storing remainder in octal array \n\t\toctalNum[i] = n % 8; \n\t\tn = n \/ 8; \n\t\ti++; \n\t} \n\n\t\/\/ Printing octal number array in \n\t\/\/ reverse order \n\tfor (int j = i - 1; j >= 0; j--) \n\t\tcout << octalNum[j]; \n} \n\n\/\/ Driver Code \nint main() \n{ \n\tint n = 33; \n\n\t\/\/ Function Call \n\tdecToOctal(n); \n\n\treturn 0; \n}\n",
        "category":"Basic Math Operations",
        "sub_category":"Number Base Conversion",
        "adoption":false,
        "reason":"Involves string",
        "module_name":null,
        "testbench":null,
        "signal":null,
        "prompt":null
    },
    {
        "task_id":39,
        "task":"RemoveLeadingZeros",
        "code":"\/\/ C++ program to remove leading zeros \n\/\/ from a given string \n#include <iostream> \n\nusing namespace std; \n\nstring removeZero(string str) \n{ \n\t\/\/ Count leading zeros \n\tint i = 0; \n\twhile (str[i] == '0') \n\t\ti++; \n\n\t\/\/ The erase function removes i characters \n\t\/\/ from given index (0 here) \n\tstr.erase(0, i); \n\n\treturn str; \n} \n\n\/\/ Driver code \nint main() \n{ \n\tstring str; \n\tstr = \"00000123569\"; \n\tstr = removeZero(str); \n\tcout << str << endl; \n\treturn 0; \n}\n",
        "category":"Basic Math Operations",
        "sub_category":"Format Conversion",
        "adoption":false,
        "reason":"Unknown output length",
        "module_name":null,
        "testbench":null,
        "signal":null,
        "prompt":null
    },
    {
        "task_id":40,
        "task":"NumberofUniqueTripletsWhoseXORisZero",
        "code":"\/\/ CPP program to count the number of\n\/\/ unique triplets whose XOR is 0\n#include <bits\/stdc++.h>\nusing namespace std;\n\n\/\/ function to count the number of \n\/\/ unique triplets whose xor is 0\nint countTriplets(int a[], int n) \n{\n\t\/\/ To store values that are present\n\tunordered_set<int> s;\n\tfor (int i = 0; i < n; i++)\n\t\ts.insert(a[i]);\n\t\n\t\/\/ stores the count of unique triplets\n\tint count = 0;\n\t\n\t\/\/ traverse for all i, j pairs such that j>i\n\tfor (int i = 0; i < n-1; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\n\t\t\/\/ xor of a[i] and a[j]\n\t\tint xr = a[i] ^ a[j];\n\t\n\t\t\/\/ if xr of two numbers is present, \n\t\t\/\/ then increase the count\n\t\tif (s.find(xr) != s.end() && xr != a[i] && \n\t\t\t\t\t\t\t\t\txr != a[j])\n\t\t\tcount++;\n\t\t}\n\t}\n\t\n\t\/\/ returns answer\n\treturn count \/ 3;\n}\n\n\/\/ Driver code to test above function\nint main() \n{\n\tint a[] = {1, 3, 5, 10, 14, 15};\n\tint n = sizeof(a) \/ sizeof(a[0]); \n\tcout << countTriplets(a, n); \n\treturn 0;\n}\n",
        "category":"Array Operations",
        "sub_category":"Array Operations",
        "adoption":false,
        "reason":"Too complex",
        "module_name":null,
        "testbench":null,
        "signal":null,
        "prompt":null
    },
    {
        "task_id":41,
        "task":"FindSimpleInterest",
        "code":"\/\/ C++ program to find simple interest \n\/\/ for given principal amount, time \n\/\/ and rate of interest.\n#include<iostream>\nusing namespace std;\n\n\/\/ Driver code\nint main()\n{\n\t\/\/ We can change values here for\n\t\/\/ different inputs\n\tfloat P = 1, R = 1, T = 1;\n\n\t\/\/ Calculate simple interest \n\tfloat SI = (P * T * R) \/ 100;\n\n\t\/\/ Print the resultant value of SI \n\tcout << \"Simple Interest = \" << SI;\n\n\treturn 0;\n}\n\n",
        "category":"Basic Math Operations",
        "sub_category":"Basic Math Operations",
        "adoption":true,
        "reason":null,
        "module_name":"SimpleInterestCalculator",
        "testbench":"SC_MODULE(Testbench) {\n    sc_signal<float> P_sig;      \/\/ Signal for Principal\n    sc_signal<float> R_sig;      \/\/ Signal for Rate\n    sc_signal<float> T_sig;      \/\/ Signal for Time\n    sc_signal<float> SI_sig;     \/\/ Signal for Simple Interest\n\n    SimpleInterestCalculator si_inst; \/\/ Instance of the SimpleInterestCalculator module\n\n    \/\/ Constructor\n    SC_CTOR(Testbench)\n    : si_inst(\"si_inst\") {\n        \/\/ Connect signals to module ports\n        si_inst.P(P_sig);\n        si_inst.R(R_sig);\n        si_inst.T(T_sig);\n        si_inst.SI(SI_sig);\n\n        \/\/ Create a test thread to provide stimulus and check the result\n        SC_THREAD(run_tests);\n    }\n\n    \/\/ Thread to run test cases\n    void run_tests() {\n        \/\/ Test case 1: P = 1, R = 1, T = 1 (expected SI = 0.01)\n        P_sig = 1.0;\n        R_sig = 1.0;\n        T_sig = 1.0;\n        wait(1, SC_NS); \/\/ Wait for the process to update\n        float result = SI_sig.read();\n        std::cout << \"Simple Interest for P=1, R=1, T=1: \" << result << std::endl;\n        assert(abs(result - 0.01) < 1e-6); \/\/ Allow for floating-point precision errors\n\n        \/\/ Test case 2: P = 1000, R = 5, T = 2 (expected SI = 100.0)\n        P_sig = 1000.0;\n        R_sig = 5.0;\n        T_sig = 2.0;\n        wait(1, SC_NS); \/\/ Wait for the process to update\n        result = SI_sig.read();\n        std::cout << \"Simple Interest for P=1000, R=5, T=2: \" << result << std::endl;\n        assert(abs(result - 100.0) < 1e-6); \/\/ Allow for floating-point precision errors\n        \n        \/\/ End simulation after successful test\n        std::cout << \"Test passed successfully.\" << std::endl;\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); \/\/ Instantiate the testbench module\n    sc_start();         \/\/ Start the simulation\n    return 0;\n}\n",
        "signal":"sc_in<float> P;\nsc_in<float> R;\nsc_in<float> T;\nsc_out<float> SI;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input. \n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<float> P;\nsc_in<float> R;\nsc_in<float> T;\nsc_out<float> SI;\n> **Note**: Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n\n**C++\/C Code**:\n```\n\/\/ C++ program to find simple interest \n\/\/ for given principal amount, time \n\/\/ and rate of interest.\n#include<iostream>\nusing namespace std;\n\n\/\/ Driver code\nint main()\n{\n\t\/\/ We can change values here for\n\t\/\/ different inputs\n\tfloat P = 1, R = 1, T = 1;\n\n\t\/\/ Calculate simple interest \n\tfloat SI = (P * T * R) \/ 100;\n\n\t\/\/ Print the resultant value of SI \n\tcout << \"Simple Interest = \" << SI;\n\n\treturn 0;\n}\n\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":42,
        "task":"FindtheNormalandTraceofaMatrix",
        "code":"\/\/ C++ program to find trace and \n\/\/ normal of given matrix \n#include<bits\/stdc++.h> \nusing namespace std; \n\n\/\/ Size of given matrix \nconst int MAX = 100; \n\n\/\/ Returns Normal of a matrix of \n\/\/ size n x n \nint findNormal(int mat[][MAX], int n) \n{ \n\tint sum = 0; \n\tfor (int i = 0; i < n; i++) \n\t\tfor (int j = 0; j < n; j++) \n\t\t\tsum += mat[i][j] * mat[i][j]; \n\treturn sqrt(sum); \n} \n\n\/\/ Returns trace of a matrix of \n\/\/ size n x n \nint findTrace(int mat[][MAX], int n) \n{ \n\tint sum = 0; \n\tfor (int i = 0; i < n; i++) \n\t\tsum += mat[i][i]; \n\treturn sum; \n} \n\n\/\/ Driven code \nint main() \n{ \n\tint mat[][MAX] = {{1, 1, 1, 1, 1}, \n\t\t{2, 2, 2, 2, 2}, \n\t\t{3, 3, 3, 3, 3}, \n\t\t{4, 4, 4, 4, 4}, \n\t\t{5, 5, 5, 5, 5}}; \n\tcout << \"Trace of Matrix = \" << \n\t\t\tfindTrace(mat, 5) << endl; \n\tcout << \"Normal of Matrix = \" << \n\t\t\tfindNormal(mat, 5) << endl; \n\treturn 0; \n} \n",
        "category":"Matrix Operations",
        "sub_category":"Matrix Operations",
        "adoption":true,
        "reason":null,
        "module_name":"MatrixOperations",
        "testbench":"SC_MODULE(Testbench) {\n    \/\/ Use static const for constants\n    static const int N = 5;        \/\/ Dimension of the matrix (5x5)\n    static const int SIZE = N * N; \/\/ Total number of matrix elements   \n    \/\/ Signals to connect with the MatrixOperations module\n    sc_signal<int> matrix[SIZE];\n    sc_signal<int> trace_signal;\n    sc_signal<int> norm_signal;\n\n    \/\/ Instance of the MatrixOperations module\n    MatrixOperations* matrixOps;\n\n    SC_CTOR(Testbench) {\n        \/\/ Instantiate the MatrixOperations module\n        matrixOps = new MatrixOperations(\"matrixOps\");\n\n        \/\/ Connect the matrix signals to the module ports\n        for (int i = 0; i < SIZE; i++) {\n            matrixOps->matrix[i](matrix[i]);\n        }\n        matrixOps->trace(trace_signal);\n        matrixOps->norm(norm_signal);\n\n        \/\/ Create a thread to run test cases\n        SC_THREAD(run_tests);\n    }\n\n    \/\/ Thread that initializes the matrix, checks outputs, and asserts correctness\n    void run_tests() {\n        \/\/ Initialize the matrix with values as defined in the original C++ code:\n        \/\/ Matrix:\n        \/\/   {1, 1, 1, 1, 1},\n        \/\/   {2, 2, 2, 2, 2},\n        \/\/   {3, 3, 3, 3, 3},\n        \/\/   {4, 4, 4, 4, 4},\n        \/\/   {5, 5, 5, 5, 5}\n        for (int row = 0; row < N; row++) {\n            for (int col = 0; col < N; col++) {\n                int index = row * N + col;\n                matrix[index].write(row + 1); \/\/ Set all elements in a row to row+1\n            }\n        }\n\n        \/\/ Wait for the combinational logic to settle\n        wait(1, SC_NS);\n\n        \/\/ Expected outputs:\n        \/\/ Trace = 1 + 2 + 3 + 4 + 5 = 15\n        \/\/ Normal = sqrt(5*(1^2 + 2^2 + 3^2 + 4^2 + 5^2)) = sqrt(275) \u2248 16 (when truncated)\n        int expected_trace = 15;\n        int expected_norm = static_cast<int>(sqrt(275));\n\n        std::cout << \"Computed Trace: \" << trace_signal.read() << std::endl;\n        std::cout << \"Computed Normal: \" << norm_signal.read() << std::endl;\n\n        \/\/ Validate the computed outputs using assertions\n        assert(trace_signal.read() == expected_trace);\n        assert(norm_signal.read() == expected_norm);\n\n        std::cout << \"All tests passed successfully.\" << std::endl;\n\n        sc_stop(); \/\/ End the simulation\n    }\n};\n\n\/\/ sc_main: the entry point of the SystemC simulation\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); \/\/ Instantiate the testbench\n    sc_start();         \/\/ Start the simulation\n    return 0;\n}\n",
        "signal":"sc_in<int> matrix[SIZE];\nsc_out<int> trace;\nsc_out<int> norm;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input. \n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<int> matrix[SIZE];\nsc_out<int> trace;\nsc_out<int> norm;\n> **Note**: Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n\n**C++\/C Code**:\n```\n\/\/ C++ program to find trace and \n\/\/ normal of given matrix \n#include<bits\/stdc++.h> \nusing namespace std; \n\n\/\/ Size of given matrix \nconst int MAX = 100; \n\n\/\/ Returns Normal of a matrix of \n\/\/ size n x n \nint findNormal(int mat[][MAX], int n) \n{ \n\tint sum = 0; \n\tfor (int i = 0; i < n; i++) \n\t\tfor (int j = 0; j < n; j++) \n\t\t\tsum += mat[i][j] * mat[i][j]; \n\treturn sqrt(sum); \n} \n\n\/\/ Returns trace of a matrix of \n\/\/ size n x n \nint findTrace(int mat[][MAX], int n) \n{ \n\tint sum = 0; \n\tfor (int i = 0; i < n; i++) \n\t\tsum += mat[i][i]; \n\treturn sum; \n} \n\n\/\/ Driven code \nint main() \n{ \n\tint mat[][MAX] = {{1, 1, 1, 1, 1}, \n\t\t{2, 2, 2, 2, 2}, \n\t\t{3, 3, 3, 3, 3}, \n\t\t{4, 4, 4, 4, 4}, \n\t\t{5, 5, 5, 5, 5}}; \n\tcout << \"Trace of Matrix = \" << \n\t\t\tfindTrace(mat, 5) << endl; \n\tcout << \"Normal of Matrix = \" << \n\t\t\tfindNormal(mat, 5) << endl; \n\treturn 0; \n} \n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\n#include <systemc.h>\n\n\/\/ Use static const for constants instead of #define\nstatic const int N = 4;\nstatic const int SIZE = N * N;\n\n\/\/ Module that performs matrix addition\nSC_MODULE(MatrixAdder) {\n    \/\/ Input ports for matrices A and B (flattened as 1D arrays)\n    sc_in<int> A[SIZE];\n    sc_in<int> B[SIZE];\n    \/\/ Output ports for matrix C (flattened as 1D array)\n    sc_out<int> C[SIZE];\n\n    SC_CTOR(MatrixAdder) {\n        \/\/ Use an SC_METHOD to perform combinational matrix addition\n        SC_METHOD(do_add);\n        for (int i = 0; i < SIZE; i++) {\n            sensitive << A[i] << B[i];\n        }\n    }\n\n    \/\/ Method that adds corresponding elements of A and B\n    void do_add() {\n        for (int i = 0; i < SIZE; i++) {\n            C[i].write(A[i].read() + B[i].read());\n        }\n    }\n};\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":43,
        "task":"CalculatethePowerofaNumber",
        "code":"\/\/ C program to illustrate power function\n#include <math.h>\n#include <stdio.h>\n\nint main()\n{\n    double x = 6.1, y = 4.8;\n\n    \/\/ Storing the answer in result.\n    double result = pow(x, y);\n    printf(\"%.2lf\", result);\n\n    return 0;\n}\n",
        "category":"Miscellaneous",
        "sub_category":"Miscellaneous",
        "adoption":false,
        "reason":null,
        "module_name":null,
        "testbench":null,
        "signal":null,
        "prompt":null
    },
    {
        "task_id":44,
        "task":"InterchangeElementsofFirstAndLastRowsinMatrix",
        "code":"\/\/ C++ code to swap the element of first \n\/\/ and last column and display the result \n#include <iostream> \nusing namespace std; \n\n#define n 4 \n\nvoid interchangeFirstLast(int m[][n]) \n{ \n\t\/\/ swapping of element between first \n\t\/\/ and last columns \n\tfor (int i = 0; i < n; i++) \n\t{ \n\t\tint t = m[i][0]; \n\t\tm[i][0] = m[i][n - 1]; \n\t\tm[i][n - 1] = t; \n\t} \n} \n\n\/\/ Driver function \nint main() \n{ \n\t\/\/ input in the array \n\tint m[n][n] = {{8, 9, 7, 6}, \n\t\t\t\t{4, 7, 6, 5}, \n\t\t\t\t{3, 2, 1, 8}, \n\t\t\t\t{9, 9, 7, 7}}; \n\n\tinterchangeFirstLast(m); \n\n\t\/\/ printing the interchanged matrix \n\tfor (int i = 0; i < n; i++) \n\t{ \n\t\tfor (int j = 0; j < n; j++) \n\t\t\tcout << m[i][j] << \" \"; \n\t\tcout << endl; \n\t} \n} \n",
        "category":"Matrix Operations",
        "sub_category":"Matrix Operations",
        "adoption":true,
        "reason":null,
        "module_name":"MatrixSwapper",
        "testbench":"SC_MODULE(Testbench) {\n    \/\/ Use static const for constants instead of #define\n    static const int N = 4;\n    static const int SIZE = N * N;\n\n    sc_signal<int> in[SIZE];\n    sc_signal<int> out[SIZE];\n\n    MatrixSwapper* matrixSwapper;\n\n    SC_CTOR(Testbench) {\n        \/\/ Instantiate the MatrixSwapper module\n        matrixSwapper = new MatrixSwapper(\"matrixSwapper\");\n        \/\/ Connect the testbench signals to the module's ports\n        for (int i = 0; i < SIZE; i++) {\n            matrixSwapper->in[i](in[i]);\n            matrixSwapper->out[i](out[i]);\n        }\n        SC_THREAD(run_tests);\n    }\n\n    void run_tests() {\n        \/\/ Define the input matrix as per the original C++ code:\n        \/\/ { {8, 9, 7, 6},\n        \/\/   {4, 7, 6, 5},\n        \/\/   {3, 2, 1, 8},\n        \/\/   {9, 9, 7, 7} }\n        int input_matrix[SIZE] = {\n            8, 9, 7, 6,\n            4, 7, 6, 5,\n            3, 2, 1, 8,\n            9, 9, 7, 7\n        };\n\n        \/\/ Expected output after swapping first and last columns:\n        \/\/ { {6, 9, 7, 8},\n        \/\/   {5, 7, 6, 4},\n        \/\/   {8, 2, 1, 3},\n        \/\/   {7, 9, 7, 9} }\n        int expected[SIZE] = {\n            6, 9, 7, 8,\n            5, 7, 6, 4,\n            8, 2, 1, 3,\n            7, 9, 7, 9\n        };\n\n        \/\/ Write input matrix values into signals\n        for (int i = 0; i < SIZE; i++) {\n            in[i].write(input_matrix[i]);\n        }\n\n        \/\/ Allow the signals to propagate\n        wait(1, SC_NS);\n\n        \/\/ Check the swapped matrix and print the result\n        std::cout << \"Swapped Matrix:\" << std::endl;\n        for (int row = 0; row < N; row++) {\n            for (int col = 0; col < N; col++) {\n                int index = row * N + col;\n                int result = out[index].read();\n                \/\/ Assert that the result matches the expected value\n                assert(result == expected[index]);\n                std::cout << result << \" \";\n            }\n            std::cout << std::endl;\n        }\n        std::cout << \"All tests passed successfully.\" << std::endl;\n\n        sc_stop(); \/\/ Stop the simulation\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); \/\/ Create an instance of the Testbench\n    sc_start();         \/\/ Start the simulation\n    return 0;\n}\n",
        "signal":"sc_in<int> in[SIZE];\nsc_out<int> out[SIZE];",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input. \n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<int> in[SIZE];\nsc_out<int> out[SIZE];\n> **Note**: Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n\n**C++\/C Code**:\n```\n\/\/ C++ code to swap the element of first \n\/\/ and last column and display the result \n#include <iostream> \nusing namespace std; \n\n#define n 4 \n\nvoid interchangeFirstLast(int m[][n]) \n{ \n\t\/\/ swapping of element between first \n\t\/\/ and last columns \n\tfor (int i = 0; i < n; i++) \n\t{ \n\t\tint t = m[i][0]; \n\t\tm[i][0] = m[i][n - 1]; \n\t\tm[i][n - 1] = t; \n\t} \n} \n\n\/\/ Driver function \nint main() \n{ \n\t\/\/ input in the array \n\tint m[n][n] = {{8, 9, 7, 6}, \n\t\t\t\t{4, 7, 6, 5}, \n\t\t\t\t{3, 2, 1, 8}, \n\t\t\t\t{9, 9, 7, 7}}; \n\n\tinterchangeFirstLast(m); \n\n\t\/\/ printing the interchanged matrix \n\tfor (int i = 0; i < n; i++) \n\t{ \n\t\tfor (int j = 0; j < n; j++) \n\t\t\tcout << m[i][j] << \" \"; \n\t\tcout << endl; \n\t} \n} \n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\n#include <systemc.h>\n\n\/\/ Use static const for constants instead of #define\nstatic const int N = 4;\nstatic const int SIZE = N * N;\n\n\/\/ Module that performs matrix addition\nSC_MODULE(MatrixAdder) {\n    \/\/ Input ports for matrices A and B (flattened as 1D arrays)\n    sc_in<int> A[SIZE];\n    sc_in<int> B[SIZE];\n    \/\/ Output ports for matrix C (flattened as 1D array)\n    sc_out<int> C[SIZE];\n\n    SC_CTOR(MatrixAdder) {\n        \/\/ Use an SC_METHOD to perform combinational matrix addition\n        SC_METHOD(do_add);\n        for (int i = 0; i < SIZE; i++) {\n            sensitive << A[i] << B[i];\n        }\n    }\n\n    \/\/ Method that adds corresponding elements of A and B\n    void do_add() {\n        for (int i = 0; i < SIZE; i++) {\n            C[i].write(A[i].read() + B[i].read());\n        }\n    }\n};\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":45,
        "task":"AreaAndPerimeterofRectangle",
        "code":"\/\/ C++ program to find area\n\/\/ and perimeter of rectangle\n#include<iostream>\nusing namespace std;\n\n\/\/ Utility function\nint areaRectangle(int a, int b)\n{\nint area = a * b;\nreturn area;\n}\n\nint perimeterRectangle(int a, int b)\n{\nint perimeter = 2*(a + b);\nreturn perimeter;\n}\n\n\/\/ Driver code\nint main()\n{\nint a = 5;\nint b = 6;\ncout << \"Area = \" << \n\t\tareaRectangle(a, b) << \n\t\tendl;\ncout << \"Perimeter = \" << \n\t\tperimeterRectangle(a, b);\nreturn 0;\n} \n",
        "category":"Miscellaneous",
        "sub_category":"Miscellaneous",
        "adoption":false,
        "reason":null,
        "module_name":null,
        "testbench":null,
        "signal":null,
        "prompt":null
    },
    {
        "task_id":46,
        "task":"DisplayArmstrongNumbersBetween1to1000",
        "code":"\/\/ C++ program to find Armstrong numbers between 1 to 1000 using a brute force approach\n#include <bits\/stdc++.h>\nusing namespace std;\n\n\/\/ Function to return the order of a number.\nint order(int num)\n{\n\tint count = 0;\n\twhile (num > 0)\n\t{\n\t\tnum \/= 10;\n\t\tcount++;\n\t}\n\treturn count;\n}\n\n\/\/ Function to check whether thegiven number is Armstrong numberor not\nbool isArmstrong(int num)\n{\n\tint order_n = order(num);\n\tint num_temp = num, sum = 0;\n\n\twhile (num_temp > 0)\n\t{\n\t\tint curr = num_temp % 10;\n\t\tsum += pow(curr, order_n);\n\t\tnum_temp \/= 10;\n\t}\n\tif (sum == num)\n\t{\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n\n\/\/ Driver code\nint main()\n{\n\n\tcout << \"Armstrong numbers between 1 to 1000 : \";\n\t\/\/ Loop which will run from 1 to 1000\n\tfor (int num = 1; num <= 1000; ++num)\n\t{\n\n\t\tif (isArmstrong(num))\n\t\t{\n\t\t\tcout << num << \" \";\n\t\t}\n\t}\n\treturn 0;\n}\n",
        "category":"Miscellaneous",
        "sub_category":"Miscellaneous",
        "adoption":false,
        "reason":null,
        "module_name":null,
        "testbench":null,
        "signal":null,
        "prompt":null
    },
    {
        "task_id":47,
        "task":"FindLCM",
        "code":"\/\/ C++ program to find the LCM of two\n\/\/ numbers using the if statement and\n\/\/ while loop\n#include <iostream>\nusing namespace std;\n\n\/\/ Driver code\nint main()\n{\n\tint a = 15, b = 20, max_num, flag = 1;\n\n\t\/\/ Use ternary operator to get the\n\t\/\/ large number\n\tmax_num = (a > b) ? a : b;\n\n\twhile (flag) {\n\t\t\/\/ if statement checks max_num is completely\n\t\t\/\/ divisible by n1 and n2.\n\t\tif (max_num % a == 0 && max_num % b == 0) {\n\t\t\tcout << \"LCM of \" << a << \" and \" << b << \" is \"\n\t\t\t\t<< max_num;\n\t\t\tbreak;\n\t\t}\n\n\t\t\/\/ update by 1 on each iteration\n\t\t++max_num;\n\t}\n\treturn 0;\n}\n",
        "category":"Basic Math Operations",
        "sub_category":"Basic Math Operations",
        "adoption":true,
        "reason":null,
        "module_name":"LcmCalculator",
        "testbench":"SC_MODULE(Testbench) {\n    sc_signal<int> a_sig;       \/\/ Signal for the first input\n    sc_signal<int> b_sig;       \/\/ Signal for the second input\n    sc_signal<int> lcm_sig;      \/\/ Signal for the LCM output\n\n    \/\/ Instance of the LcmCalculator module\n    LcmCalculator lcm_inst;\n\n    \/\/ Constructor: Initialize the module and run the test thread\n    SC_CTOR(Testbench)\n    : lcm_inst(\"lcm_inst\") {\n        \/\/ Connect signals to module ports\n        lcm_inst.a(a_sig);\n        lcm_inst.b(b_sig);\n        lcm_inst.lcm_result(lcm_sig);\n\n        \/\/ Create a test thread to provide stimulus and check the result\n        SC_THREAD(run_tests);\n    }\n\n    \/\/ Thread to run test cases\n    void run_tests() {\n        \/\/ Test case: a = 15, b = 20 (expected LCM = 60)\n        a_sig.write(15);\n        b_sig.write(20);\n        wait(1, SC_NS); \/\/ Wait for the process to update\n        int result = lcm_sig.read();\n        std::cout << \"LCM(\" << a_sig.read() << \", \" << b_sig.read() << \") = \" << result << std::endl;\n        assert(result == 60);\n\n        \/\/ Test case: a = 17, b = 15 (expected LCM = 255)\n        a_sig.write(17);\n        b_sig.write(15);\n        wait(1, SC_NS); \/\/ Wait for the process to update\n        result = lcm_sig.read();\n        std::cout << \"LCM(\" << a_sig.read() << \", \" << b_sig.read() << \") = \" << result << std::endl;\n        assert(result == 255);\n\n        \/\/ End simulation after successful test\n        std::cout << \"Test passed successfully.\" << endl;\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); \/\/ Instantiate the testbench module\n    sc_start();         \/\/ Start the simulation\n    return 0;\n}\n",
        "signal":"sc_in<int> a;\nsc_in<int> b;\nsc_out<int> lcm_result;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input. \n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<int> a;\nsc_in<int> b;\nsc_out<int> lcm_result;\n> **Note**: Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n\n**C++\/C Code**:\n```\n\/\/ C++ program to find the LCM of two\n\/\/ numbers using the if statement and\n\/\/ while loop\n#include <iostream>\nusing namespace std;\n\n\/\/ Driver code\nint main()\n{\n\tint a = 15, b = 20, max_num, flag = 1;\n\n\t\/\/ Use ternary operator to get the\n\t\/\/ large number\n\tmax_num = (a > b) ? a : b;\n\n\twhile (flag) {\n\t\t\/\/ if statement checks max_num is completely\n\t\t\/\/ divisible by n1 and n2.\n\t\tif (max_num % a == 0 && max_num % b == 0) {\n\t\t\tcout << \"LCM of \" << a << \" and \" << b << \" is \"\n\t\t\t\t<< max_num;\n\t\t\tbreak;\n\t\t}\n\n\t\t\/\/ update by 1 on each iteration\n\t\t++max_num;\n\t}\n\treturn 0;\n}\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":48,
        "task":"MakeaSimpleCalculator",
        "code":"\/\/ C++ Program to make a Simple Calculator using\n\/\/ switch-case statements\n#include <bits\/stdc++.h>\nusing namespace std;\n\nint main() {\n    char op;\n    double a, b, res;\n\n    \/\/ Read the operator\n    cout << \"Enter an operator (+, -, *, \/): \";\n    cin >> op;\n\n    \/\/ Read the two numbers\n    cout << \"Enter two numbers: \";\n    cin >> a >> b;\n\n    \/\/ Define all four operations in the corresponding\n    \/\/ switch-case\n    switch (op) {\n    case '+':\n        res = a + b;\n        break;\n    case '-':\n        res = a - b;\n        break;\n    case '*':\n        res = a * b;\n        break;\n    case '\/':\n        res = a \/ b;\n        break;\n    default:\n        cout << \"Error! Operator is not correct\";\n        res = -DBL_MAX;\n    }\n    \n      \/\/ Printing the result\n    if (res != -DBL_MAX)\n        cout << \"Result: \" << res;\n    return 0;\n}\n",
        "category":"Miscellaneous",
        "sub_category":"Miscellaneous",
        "adoption":false,
        "reason":null,
        "module_name":null,
        "testbench":null,
        "signal":null,
        "prompt":null
    },
    {
        "task_id":49,
        "task":"CheckWhetherTwoMatricesAreEqualorNot",
        "code":"\/\/ C++ Program to check if two given matrices are identical \n#include <bits\/stdc++.h> \n#define N 4 \nusing namespace std; \n\n\/\/ This function returns 1 if A[][] \n\/\/ and B[][] are identical otherwise \n\/\/ returns 0 \nint areSame(int A[][N], int B[][N]) \n{ \n\tint i, j; \n\tfor (i = 0; i < N; i++) \n\t\tfor (j = 0; j < N; j++) \n\t\t\tif (A[i][j] != B[i][j]) \n\t\t\t\treturn 0; \n\treturn 1; \n} \n\nint main() \n{ \n\tint A[N][N] = {{1, 1, 1, 1}, \n\t\t\t\t{2, 2, 2, 2}, \n\t\t\t\t{3, 3, 3, 3}, \n\t\t\t\t{4, 4, 4, 4}}; \n\n\tint B[N][N] = {{1, 1, 1, 1}, \n\t\t\t\t{2, 2, 2, 2}, \n\t\t\t\t{3, 3, 3, 3}, \n\t\t\t\t{4, 4, 4, 4}}; \n\n\tif (areSame(A, B)) \n\t\tcout << \"Matrices are identical\"; \n\telse\n\t\tcout << \"Matrices are not identical\"; \n\treturn 0; \n} \n",
        "category":"Matrix Operations",
        "sub_category":"Matrix Operations",
        "adoption":true,
        "reason":null,
        "module_name":"MatrixComparator",
        "testbench":"SC_MODULE(Testbench) {\n    \/\/ Use static const for constants instead of #define\n    static const int N = 4;\n    static const int SIZE = N * N;\n    sc_signal<int> A[SIZE];\n    sc_signal<int> B[SIZE];\n    sc_signal<bool> result;\n\n    MatrixComparator* comparator;\n\n    SC_CTOR(Testbench) {\n        \/\/ Instantiate the MatrixComparator module\n        comparator = new MatrixComparator(\"comparator\");\n        \/\/ Connect signals to the module's ports\n        for (int i = 0; i < SIZE; i++) {\n            comparator->A[i](A[i]);\n            comparator->B[i](B[i]);\n        }\n        comparator->identical(result);\n\n        \/\/ Create a thread to run the test cases\n        SC_THREAD(run_tests);\n    }\n\n    \/\/ Thread that initializes inputs, checks outputs, and asserts correctness\n    void run_tests() {\n        \/\/ Initialize matrices A and B as defined in the original C++ code:\n        \/\/ Matrix A:\n        \/\/   { 1, 1, 1, 1 },\n        \/\/   { 2, 2, 2, 2 },\n        \/\/   { 3, 3, 3, 3 },\n        \/\/   { 4, 4, 4, 4 }\n        \/\/ Matrix B: identical to Matrix A.\n        for (int row = 0; row < N; row++) {\n            for (int col = 0; col < N; col++) {\n                int index = row * N + col;\n                A[index].write(row + 1); \/\/ For row 0, write 1; row 1, write 2; etc.\n                B[index].write(row + 1);\n            }\n        }\n\n        \/\/ Wait for the signals to propagate and for the comparison to be performed.\n        wait(1, SC_NS);\n\n        \/\/ Check the result and print the output\n        if (result.read() == true) {\n            std::cout << \"Matrices are identical\" << std::endl;\n        } else {\n            std::cout << \"Matrices are not identical\" << std::endl;\n        }\n\n        \/\/ Assert the result is true, as the matrices are identical.\n        assert(result.read() == true);\n        std::cout << \"Test passed successfully\" << std::endl;\n\n        sc_stop(); \/\/ End the simulation\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); \/\/ Create an instance of the Testbench\n    sc_start();         \/\/ Start the simulation\n    return 0;\n}\n",
        "signal":"sc_in<int> A[SIZE];\nsc_in<int> B[SIZE];\nsc_out<bool> identical;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input. \n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<int> A[SIZE];\nsc_in<int> B[SIZE];\nsc_out<bool> identical;\n> **Note**: Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n\n**C++\/C Code**:\n```\n\/\/ C++ Program to check if two given matrices are identical \n#include <bits\/stdc++.h> \n#define N 4 \nusing namespace std; \n\n\/\/ This function returns 1 if A[][] \n\/\/ and B[][] are identical otherwise \n\/\/ returns 0 \nint areSame(int A[][N], int B[][N]) \n{ \n\tint i, j; \n\tfor (i = 0; i < N; i++) \n\t\tfor (j = 0; j < N; j++) \n\t\t\tif (A[i][j] != B[i][j]) \n\t\t\t\treturn 0; \n\treturn 1; \n} \n\nint main() \n{ \n\tint A[N][N] = {{1, 1, 1, 1}, \n\t\t\t\t{2, 2, 2, 2}, \n\t\t\t\t{3, 3, 3, 3}, \n\t\t\t\t{4, 4, 4, 4}}; \n\n\tint B[N][N] = {{1, 1, 1, 1}, \n\t\t\t\t{2, 2, 2, 2}, \n\t\t\t\t{3, 3, 3, 3}, \n\t\t\t\t{4, 4, 4, 4}}; \n\n\tif (areSame(A, B)) \n\t\tcout << \"Matrices are identical\"; \n\telse\n\t\tcout << \"Matrices are not identical\"; \n\treturn 0; \n} \n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\n#include <systemc.h>\n\n\/\/ Use static const for constants instead of #define\nstatic const int N = 4;\nstatic const int SIZE = N * N;\n\n\/\/ Module that performs matrix addition\nSC_MODULE(MatrixAdder) {\n    \/\/ Input ports for matrices A and B (flattened as 1D arrays)\n    sc_in<int> A[SIZE];\n    sc_in<int> B[SIZE];\n    \/\/ Output ports for matrix C (flattened as 1D array)\n    sc_out<int> C[SIZE];\n\n    SC_CTOR(MatrixAdder) {\n        \/\/ Use an SC_METHOD to perform combinational matrix addition\n        SC_METHOD(do_add);\n        for (int i = 0; i < SIZE; i++) {\n            sensitive << A[i] << B[i];\n        }\n    }\n\n    \/\/ Method that adds corresponding elements of A and B\n    void do_add() {\n        for (int i = 0; i < SIZE; i++) {\n            C[i].write(A[i].read() + B[i].read());\n        }\n    }\n};\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":50,
        "task":"DecimaltoBinaryConversion",
        "code":"\/\/ C++ program to convert a decimal number to binary number\n#include <iostream>\nusing namespace std;\n\n\/\/ Function to convert decimal\n\/\/ to binary\nvoid decToBinary(int n)\n{\n\t\/\/ Array to store binary number\n\tint binaryNum[32];\n\n\t\/\/ Counter for binary array\n\tint i = 0;\n\twhile (n > 0) {\n\t\t\/\/ Storing remainder in binary\n\t\t\/\/ array\n\t\tbinaryNum[i] = n % 2;\n\t\tn = n \/ 2;\n\t\ti++;\n\t}\n\n\t\/\/ Printing binary array in reverse\n\t\/\/ order\n\tfor (int j = i - 1; j >= 0; j--)\n\t\tcout << binaryNum[j];\n}\n\n\/\/ Driver code\nint main()\n{\n\tint n = 10;\n\tdecToBinary(n);\n\treturn 0;\n}\n",
        "category":"Basic Math Operations",
        "sub_category":"Number Base Conversion",
        "adoption":true,
        "reason":null,
        "module_name":"DecToBinary",
        "testbench":"SC_MODULE(Testbench) {\n    sc_signal<int> dec_sig;    \/\/ Signal for the decimal input\n    sc_signal<int> bin_sig;    \/\/ Signal for the binary output\n\n    DecToBinary* dec_to_binary_inst;  \/\/ Instance of the conversion module\n\n    SC_CTOR(Testbench) {\n        \/\/ Instantiate the DecToBinary module and connect signals\n        dec_to_binary_inst = new DecToBinary(\"DecToBinary\");\n        dec_to_binary_inst->dec_in(dec_sig);\n        dec_to_binary_inst->binary_out(bin_sig);\n\n        SC_THREAD(run_tests);   \/\/ Launch test cases in a thread\n    }\n\n    void run_tests() {\n        \/\/ Test Case: Input n = 10 should result in binary 1010\n        dec_sig.write(10);\n        wait(1, SC_NS);  \/\/ Wait for the process to trigger\n\n        int result = bin_sig.read();\n        std::cout << \"Input: 10, Binary Output: \" << result << std::endl;\n        assert(result == 1010);\n\n        \/\/ Test Case: Input n = 0 should result in binary 0\n        dec_sig.write(0);\n        wait(1, SC_NS);  \/\/ Wait for the process to trigger\n\n        int result2 = bin_sig.read();\n        std::cout << \"Input: 0, Binary Output: \" << result2 << std::endl;\n        assert(result2 == 0);\n\n        \/\/ Test Case: Input n = 1000 should result in binary 1111101000\n        dec_sig.write(1000);\n        wait(1, SC_NS);  \/\/ Wait for the process to trigger\n        int result3 = bin_sig.read();\n        std::cout << \"Input: 1000, Binary Output: \" << result3 << std::endl;\n        assert(result3 == 1111101000);\n\n        \/\/ Print success message and stop simulation\n        std::cout << \"Test passed successfully.\" << std::endl;\n        sc_stop();\n    }\n\n    \/\/ Destructor to free allocated memory\n    ~Testbench() {\n        delete dec_to_binary_inst;\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\");  \/\/ Create an instance of the Testbench module\n    sc_start();          \/\/ Start the simulation\n    return 0;\n}\n",
        "signal":"sc_in<int> dec_in;\nsc_out<int> binary_out;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input. \n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<int> dec_in;\nsc_out<int> binary_out;\n> **Note**: Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n\n**C++\/C Code**:\n```\n\/\/ C++ program to convert a decimal number to binary number\n#include <iostream>\nusing namespace std;\n\n\/\/ Function to convert decimal\n\/\/ to binary\nvoid decToBinary(int n)\n{\n\t\/\/ Array to store binary number\n\tint binaryNum[32];\n\n\t\/\/ Counter for binary array\n\tint i = 0;\n\twhile (n > 0) {\n\t\t\/\/ Storing remainder in binary\n\t\t\/\/ array\n\t\tbinaryNum[i] = n % 2;\n\t\tn = n \/ 2;\n\t\ti++;\n\t}\n\n\t\/\/ Printing binary array in reverse\n\t\/\/ order\n\tfor (int j = i - 1; j >= 0; j--)\n\t\tcout << binaryNum[j];\n}\n\n\/\/ Driver code\nint main()\n{\n\tint n = 10;\n\tdecToBinary(n);\n\treturn 0;\n}\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":51,
        "task":"CheckWhetheraNumberisaPalindromeorNot",
        "code":"\/\/ C++ implementation of the above approach\n#include <iostream>\nusing namespace std;\n\n\/\/ Function to check palindrome\nint checkPalindrome(string str)\n{ \n\t\/\/ Calculating string length\n\tint len = str.length();\n\n\t\/\/ Traversing through the string \n\t\/\/ upto half its length\n\tfor (int i = 0; i < len \/ 2; i++) \n\t{\t \n\t\t\/\/ Comparing i th character from \n\t\t\/\/ starting and len-i th character \n\t\t\/\/ from end\n\t\tif (str[i] != str[len - i - 1])\n\t\t\treturn false;\n\t}\n\n\t\/\/ If the above loop doesn't return \n\t\/\/ then it is palindrome\n\treturn true;\n}\n\n\/\/ Driver Code\nint main()\n{ \n\t\/\/ Taking number as string\n\tstring st = \n\t\"112233445566778899000000998877665544332211\";\n\tif (checkPalindrome(st) == true)\n\t\tcout << \"Yes\";\n\telse\n\t\tcout << \"No\";\n\treturn 0;\n}\n\/\/ This code is written by vikkycirus\n",
        "category":"Basic Math Operations",
        "sub_category":"Decision",
        "adoption":false,
        "reason":"Involves string",
        "module_name":null,
        "testbench":null,
        "signal":null,
        "prompt":null
    },
    {
        "task_id":52,
        "task":"AddTwoNumbers",
        "code":"\/\/ C++ program to add two number using addition operator\n#include <bits\/stdc++.h>\nusing namespace std;\n\nint main() {\n    int a = 11, b = 9;\n\n    \/\/ Adding the two numbers and printing\n    \/\/ their sum\n    cout << a + b;\n    return 0;\n}\n",
        "category":"Basic Math Operations",
        "sub_category":"Basic Math Operations",
        "adoption":false,
        "reason":"Few shot example",
        "module_name":"Adder",
        "testbench":"SC_MODULE(Testbench) {\n    sc_signal<int> a; \/\/ Signal for the first number\n    sc_signal<int> b; \/\/ Signal for the second number\n    sc_signal<int> sum; \/\/ Signal for the sum\n\n    Adder adder_inst; \/\/ Instance of the Adder module\n\n    \/\/ Constructor\n    SC_CTOR(Testbench) : adder_inst(\"adder\") {\n        \/\/ Connect signals to ports\n        adder_inst.a(a);\n        adder_inst.b(b);\n        adder_inst.sum(sum);\n\n        \/\/ Process to run tests\n        SC_THREAD(run_tests);\n    }\n\n    \/\/ Thread to run test cases\n    void run_tests() {\n        \/\/ Test case 1: Simple addition\n        a = 11; b = 9;\n        wait(1, SC_NS); \/\/ Wait for the adder to process\n        assert(sum.read() == 20);\n        cout << \"Sum: \" << sum.read() << endl;\n\n        \/\/ Additional test case: One operand is zero\n        a = 0; b = 5;\n        wait(1, SC_NS);\n        assert(sum.read() == 5);\n        cout << \"Sum: \" << sum.read() << endl;\n\n        \/\/ Additional test case: Both operands are zero\n        a = 0; b = 0;\n        wait(1, SC_NS);\n        assert(sum.read() == 0);\n        cout << \"Sum: \" << sum.read() << endl;\n\n        \/\/ Print success message\n        cout << \"All tests passed successfully.\" << endl;\n\n        sc_stop(); \/\/ Stop the simulation\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); \/\/ Create an instance of the Testbench\n\n    \/\/ Start the simulation\n    sc_start();\n\n    return 0;\n}\n",
        "signal":"sc_in<int> a;\nsc_in<int> b;\nsc_out<int> sum;",
        "prompt":null
    },
    {
        "task_id":53,
        "task":"ArrayRotation",
        "code":"#include <bits\/stdc++.h>\nusing namespace std;\n\n\/\/ Function to rotate array\nvoid Rotate(int arr[], int d, int n)\n{\n\t\/\/ Storing rotated version of array\n\tint temp[n];\n\n\t\/\/ Keeping track of the current index\n\t\/\/ of temp[]\n\tint k = 0;\n\n\t\/\/ Storing the n - d elements of\n\t\/\/ array arr[] to the front of temp[]\n\tfor (int i = d; i < n; i++) {\n\t\ttemp[k] = arr[i];\n\t\tk++;\n\t}\n\n\t\/\/ Storing the first d elements of array arr[]\n\t\/\/ into temp\n\tfor (int i = 0; i < d; i++) {\n\t\ttemp[k] = arr[i];\n\t\tk++;\n\t}\n\n\t\/\/ Copying the elements of temp[] in arr[]\n\t\/\/ to get the final rotated array\n\tfor (int i = 0; i < n; i++) {\n\t\tarr[i] = temp[i];\n\t}\n}\n\n\/\/ Function to print elements of array\nvoid PrintTheArray(int arr[], int n)\n{\n\tfor (int i = 0; i < n; i++) {\n\t\tcout << arr[i] << \" \";\n\t}\n}\n\n\/\/ Driver code\nint main()\n{\n\tint arr[] = { 1, 2, 3, 4, 5, 6, 7 };\n\tint N = sizeof(arr) \/ sizeof(arr[0]);\n\tint d = 2;\n\n\t\/\/ Function calling\n\tRotate(arr, d, N);\n\tPrintTheArray(arr, N);\n\n\treturn 0;\n}\n",
        "category":"Array Operations",
        "sub_category":"Array Processing",
        "adoption":true,
        "reason":null,
        "module_name":"Rotator",
        "testbench":"SC_MODULE(Testbench) {\n    sc_signal<bool> clk;\n    sc_signal<bool> rst;\n    sc_signal<int> d;\n    sc_signal<int> in_array[7];\n    sc_signal<int> out_array[7];\n\n    Rotator* rotator_inst;\n\n    \/\/ Clock generator process\n    void generate_clock() {\n        while (true) {\n            clk.write(false);\n            wait(5, SC_NS);\n            clk.write(true);\n            wait(5, SC_NS);\n        }\n    }\n\n    \/\/ Process to run tests\n    void run_tests() {\n        \/\/ Activate reset for one clock cycle\n        rst.write(true);\n        wait(10, SC_NS);\n        rst.write(false);\n\n        \/\/ Provide the input array and rotation offset (d = 2)\n        int input[7] = { 1, 2, 3, 4, 5, 6, 7 };\n        for (int i = 0; i < 7; i++) {\n            in_array[i].write(input[i]);\n        }\n        d.write(2);\n\n        \/\/ Wait for the rotator to process the new values.\n        wait(10, SC_NS);\n\n        \/\/ Expected output after rotation: {3, 4, 5, 6, 7, 1, 2}\n        int expected[7] = { 3, 4, 5, 6, 7, 1, 2 };\n        std::cout << \"Rotated Array: \";\n        for (int i = 0; i < 7; i++) {\n            int out_val = out_array[i].read();\n            \/\/ Assert that the output is as expected.\n            assert(out_val == expected[i]);\n            std::cout << out_val << \" \";\n        }\n        std::cout << \"All tests passed successfully.\" << std::endl;\n\n        sc_stop(); \/\/ End simulation.\n    }\n\n    SC_CTOR(Testbench) {\n        rotator_inst = new Rotator(\"Rotator\");\n        \/\/ Connect testbench signals to Rotator ports.\n        rotator_inst->clk(clk);\n        rotator_inst->rst(rst);\n        rotator_inst->d(d);\n        for (int i = 0; i < 7; i++) {\n            rotator_inst->in_array[i](in_array[i]);\n            rotator_inst->out_array[i](out_array[i]);\n        }\n        SC_THREAD(run_tests);\n        SC_THREAD(generate_clock);\n    }\n\n    ~Testbench() {\n        delete rotator_inst;\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\");\n    sc_start();\n    return 0;\n}\n",
        "signal":"sc_in<bool> clk;\nsc_in<bool> rst;\nsc_in<int> d;\nsc_in<int> in_array[7];\nsc_out<int> out_array[7];",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input. \n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<bool> clk;\nsc_in<bool> rst;\nsc_in<int> d;\nsc_in<int> in_array[7];\nsc_out<int> out_array[7];\n> **Note**: Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n\n**C++\/C Code**:\n```\n#include <bits\/stdc++.h>\nusing namespace std;\n\n\/\/ Function to rotate array\nvoid Rotate(int arr[], int d, int n)\n{\n\t\/\/ Storing rotated version of array\n\tint temp[n];\n\n\t\/\/ Keeping track of the current index\n\t\/\/ of temp[]\n\tint k = 0;\n\n\t\/\/ Storing the n - d elements of\n\t\/\/ array arr[] to the front of temp[]\n\tfor (int i = d; i < n; i++) {\n\t\ttemp[k] = arr[i];\n\t\tk++;\n\t}\n\n\t\/\/ Storing the first d elements of array arr[]\n\t\/\/ into temp\n\tfor (int i = 0; i < d; i++) {\n\t\ttemp[k] = arr[i];\n\t\tk++;\n\t}\n\n\t\/\/ Copying the elements of temp[] in arr[]\n\t\/\/ to get the final rotated array\n\tfor (int i = 0; i < n; i++) {\n\t\tarr[i] = temp[i];\n\t}\n}\n\n\/\/ Function to print elements of array\nvoid PrintTheArray(int arr[], int n)\n{\n\tfor (int i = 0; i < n; i++) {\n\t\tcout << arr[i] << \" \";\n\t}\n}\n\n\/\/ Driver code\nint main()\n{\n\tint arr[] = { 1, 2, 3, 4, 5, 6, 7 };\n\tint N = sizeof(arr) \/ sizeof(arr[0]);\n\tint d = 2;\n\n\t\/\/ Function calling\n\tRotate(arr, d, N);\n\tPrintTheArray(arr, N);\n\n\treturn 0;\n}\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\n#include <systemc.h>\n\n\/\/ BubbleSort Module: Implements the bubble sort algorithm\nSC_MODULE(BubbleSort) {\n    sc_in<bool> clk;      \/\/ Clock input\n    sc_in<bool> start;    \/\/ Signal to start sorting\n    sc_out<bool> done;    \/\/ Signal to indicate sorting is complete\n\n    \/\/ Internal storage for the array (fixed size of 4 elements)\n    int arr[4];\n\n    \/\/ Constructor: register the process\n    SC_CTOR(BubbleSort) {\n        SC_THREAD(sort_process);\n        sensitive << clk.pos();\n    }\n\n    \/\/ Process that waits for the start signal and performs sorting\n    void sort_process() {\n        while (true) {\n            wait(); \/\/ wait for a clock cycle\n            if (start.read() == true) {\n                bubbleSort(); \/\/ perform sorting\n                done.write(true);\n                wait(); \/\/ wait for one cycle to signal completion\n                done.write(false);\n            }\n        }\n    }\n\n    \/\/ Bubble sort algorithm implementation (sorts the internal array)\n    void bubbleSort() {\n        \/\/ Number of elements is fixed at 4\n        const int n = 4;\n        for (int i = 0; i < n - 1; i++) {\n            for (int j = 0; j < n - i - 1; j++) {\n                if (arr[j] > arr[j + 1]) {\n                    \/\/ Swap arr[j] and arr[j+1]\n                    int temp = arr[j];\n                    arr[j] = arr[j + 1];\n                    arr[j + 1] = temp;\n                }\n            }\n        }\n    }\n\n    \/\/ Helper method to load an input array into the module\n    void load_array(const int input[4]) {\n        for (int i = 0; i < 4; i++) {\n            arr[i] = input[i];\n        }\n    }\n\n    \/\/ Helper method to read the sorted array from the module\n    void read_array(int output[4]) {\n        for (int i = 0; i < 4; i++) {\n            output[i] = arr[i];\n        }\n    }\n};\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":54,
        "task":"FindCompoundInterest",
        "code":"\/\/ C++ program to find compound interest for given values.\n#include <bits\/stdc++.h>\nusing namespace std;\n\n\/\/ Driver code\nint main()\n{\n    double principal = 10000, rate = 5, time = 2;\n\n    \/\/ Calculate compound interest\n    double A = principal * ((pow((1 + rate \/ 100), time)));\n    double CI = A - principal;\n\n    cout << \"Compound interest is \" << CI;\n\n    return 0;\n}\n\/\/ This Code is Contributed by Sahil Rai.\n",
        "category":"Basic Math Operations",
        "sub_category":"Basic Math Operations",
        "adoption":true,
        "reason":null,
        "module_name":"CompoundInterestCalculator",
        "testbench":"SC_MODULE(Testbench) {\n    sc_signal<double> principal_sig; \/\/ Signal for principal amount\n    sc_signal<double> rate_sig;      \/\/ Signal for interest rate\n    sc_signal<double> time_sig;      \/\/ Signal for time period\n    sc_signal<double> ci_sig;        \/\/ Signal for compound interest\n\n    \/\/ Instance of the CompoundInterestCalculator module\n    CompoundInterestCalculator ci_inst;\n\n    \/\/ Constructor: Initialize the module and run the test thread\n    SC_CTOR(Testbench)\n    : ci_inst(\"ci_inst\") {\n        \/\/ Connect signals to module ports\n        ci_inst.principal(principal_sig);\n        ci_inst.rate(rate_sig);\n        ci_inst.time(time_sig);\n        ci_inst.ci(ci_sig);\n\n        \/\/ Create a test thread to provide stimulus and check the result\n        SC_THREAD(run_tests);\n    }\n\n    \/\/ Thread to run test cases\n    void run_tests() {\n        \/\/ Test Case 1: Principal = 10000, Rate = 5%, Time = 2 years\n        principal_sig = 10000;\n        rate_sig = 5;\n        time_sig = 2;\n        wait(1, SC_NS); \/\/ Wait for the process to update\n        \n        \/\/ Read and print the compound interest\n        double result = ci_sig.read();\n        \/\/ Check if the result is as expected (allowing a small tolerance)\n        assert(fabs(result - 1025) < 1e-6);\n        \n        \/\/ Test Case 2: Principal = 20000, Rate = 10%, Time = 5 years\n        principal_sig = 20000;\n        rate_sig = 10;\n        time_sig = 5;\n        wait(1, SC_NS); \/\/ Wait for the process to update\n        \n        result = ci_sig.read(); \/\/ Reuse the already declared variable\n        \/\/ The correct expected compound interest should be around 12210.2\n        assert(fabs(result - 12210.2) < 1e-6);\n        \n        std::cout << \"All tests passed successfully!\" << std::endl;\n        \/\/ End simulation after successful test\n        sc_stop();\n    }    \n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); \/\/ Instantiate the testbench module\n    sc_start();         \/\/ Start the simulation\n    return 0;\n}\n",
        "signal":"sc_in<double> principal;\nsc_in<double> rate;\nsc_in<double> time;\nsc_out<double> ci;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input. \n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<double> principal;\nsc_in<double> rate;\nsc_in<double> time;\nsc_out<double> ci;\n> **Note**: Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n\n**C++\/C Code**:\n```\n\/\/ C++ program to find compound interest for given values.\n#include <bits\/stdc++.h>\nusing namespace std;\n\n\/\/ Driver code\nint main()\n{\n    double principal = 10000, rate = 5, time = 2;\n\n    \/\/ Calculate compound interest\n    double A = principal * ((pow((1 + rate \/ 100), time)));\n    double CI = A - principal;\n\n    cout << \"Compound interest is \" << CI;\n\n    return 0;\n}\n\/\/ This Code is Contributed by Sahil Rai.\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":55,
        "task":"CheckiftwoArraysareEqualornot",
        "code":"\/\/ C++ program to implement the approach\n\n#include <bits\/stdc++.h>\nusing namespace std;\n\n\/\/ Function to check if both arrays are equal\nbool checkArrays(int arr1[], int arr2[],\n\t\t\t\tint n, int m)\n{\n\t\/\/ If lengths of array are not equal\n\t\/\/ means array are not equal\n\tif (n != m)\n\t\treturn false;\n\n\t\/\/ Sort both arrays\n\tsort(arr1, arr1 + n);\n\tsort(arr2, arr2 + m);\n\n\t\/\/ Linearly compare elements\n\tfor (int i = 0; i < n; i++)\n\t\tif (arr1[i] != arr2[i])\n\t\t\treturn false;\n\n\t\/\/ If elements are same\n\treturn true;\n}\n\n\/\/ Driver Code\nint main()\n{\n\tint arr1[] = { 1, 2, 3, 4, 5 };\n\tint arr2[] = { 5, 4, 3, 2, 1 };\n\tint N = sizeof(arr1) \/ sizeof(int);\n\tint M = sizeof(arr2) \/ sizeof(int);\n\n\t\/\/ Function call\n\tif (checkArrays(arr1, arr2, N, M))\n\t\tcout << \"Equal\";\n\telse\n\t\tcout << \"Not Equal\";\n\treturn 0;\n}\n",
        "category":"Miscellaneous",
        "sub_category":"Miscellaneous",
        "adoption":false,
        "reason":null,
        "module_name":null,
        "testbench":null,
        "signal":null,
        "prompt":null
    },
    {
        "task_id":56,
        "task":"HexadecimaltoDecimalConversion",
        "code":"\/\/ C++ program to convert hexadecimal \n\/\/ to decimal \n#include <bits\/stdc++.h> \nusing namespace std; \n\n\/\/ Function to convert hexadecimal \n\/\/ to decimal \nint hexadecimalToDecimal(string hexVal) \n{ \n\tint len = hexVal.size(); \n\n\t\/\/ Initializing base value to 1, \n\t\/\/ i.e 16^0 \n\tint base = 1; \n\n\tint dec_val = 0; \n\n\t\/\/ Extracting characters as digits \n\t\/\/ from last character \n\tfor (int i = len - 1; i >= 0; i--) { \n\t\t\/\/ If character lies in '0'-'9', \n\t\t\/\/ converting it to integral 0-9 \n\t\t\/\/ by subtracting 48 from ASCII value \n\t\tif (hexVal[i] >= '0' && hexVal[i] <= '9') { \n\t\t\tdec_val += (int(hexVal[i]) - 48) * base; \n\n\t\t\t\/\/ incrementing base by power \n\t\t\tbase = base * 16; \n\t\t} \n\n\t\t\/\/ If character lies in 'A'-'F' , converting \n\t\t\/\/ it to integral 10 - 15 by subtracting 55 \n\t\t\/\/ from ASCII value \n\t\telse if (hexVal[i] >= 'A' && hexVal[i] <= 'F') { \n\t\t\tdec_val += (int(hexVal[i]) - 55) * base; \n\n\t\t\t\/\/ Incrementing base by power \n\t\t\tbase = base * 16; \n\t\t} \n\t} \n\treturn dec_val; \n} \n\n\/\/ Driver code \nint main() \n{ \n\tstring hexNum = \"1A\"; \n\tcout << (hexadecimalToDecimal(hexNum)); \n\n\treturn 0; \n}\n",
        "category":"Basic Math Operations",
        "sub_category":"Number Base Conversion",
        "adoption":false,
        "reason":"Involves string",
        "module_name":null,
        "testbench":null,
        "signal":null,
        "prompt":null
    },
    {
        "task_id":57,
        "task":"CheckArmstrongNumber",
        "code":"\/\/ C++ program to implement the above approach\n#include <iostream>\nusing namespace std;\n\n\/\/ Driver code\nint main()\n{\n\tint n = 153;\n\tint temp = n;\n\tint p = 0;\n\n\t\/\/ Function to calculate\n\t\/\/ the sum of individual digits\n\twhile (n > 0) {\n\t\tint rem = n % 10;\n\t\tp = (p) + (rem * rem * rem);\n\t\tn = n \/ 10;\n\t}\n\n\t\/\/ Condition to check whether\n\t\/\/ the value of P equals\n\t\/\/ to user input or not.\n\tif (temp == p) {\n\t\tcout << (\"Yes. It is Armstrong No.\");\n\t}\n\telse {\n\t\tcout << (\"No. It is not an Armstrong No.\");\n\t}\n\treturn 0;\n}\n",
        "category":"Basic Math Operations",
        "sub_category":"Decision",
        "adoption":true,
        "reason":null,
        "module_name":"ArmstrongChecker",
        "testbench":"SC_MODULE(Testbench) {\n    sc_signal<int> num_sig;       \/\/ Signal for the number input\n    sc_signal<bool> armstrong_sig; \/\/ Signal for the Armstrong check result\n\n    \/\/ Instance of the ArmstrongChecker module\n    ArmstrongChecker armstrong_checker_inst;\n\n    \/\/ Constructor: Initialize the module and run the test thread\n    SC_CTOR(Testbench)\n    : armstrong_checker_inst(\"armstrong_checker_inst\") {\n        \/\/ Connect signals to module ports\n        armstrong_checker_inst.num_in(num_sig);\n        armstrong_checker_inst.is_armstrong(armstrong_sig);\n\n        \/\/ Create a test thread to provide stimulus and check the result\n        SC_THREAD(run_tests);\n    }\n\n    \/\/ Thread to run test cases\n    void run_tests() {\n        \/\/ Test case: n = 153 (expected: Armstrong number)\n        num_sig.write(153);\n        wait(1, SC_NS); \/\/ Wait for the process to update\n        bool result = armstrong_sig.read();\n        std::cout << \"Number: 153 is Armstrong? \" << (result ? \"Yes\" : \"No\") << std::endl;\n        assert(result == true);\n\n        \/\/ Test case: n = 123 (expected: Not an Armstrong number)\n        num_sig.write(123);\n        wait(1, SC_NS); \/\/ Wait for the process to update\n        result = armstrong_sig.read();\n        std::cout << \"Number: 123 is Armstrong? \" << (result ? \"Yes\" : \"No\") << std::endl;\n        assert(result == false);\n\n        \/\/ End simulation after successful test\n        std::cout << \"Tests passed successfully.\" << std::endl;\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); \/\/ Instantiate the testbench module\n    sc_start();         \/\/ Start the simulation\n    return 0;\n}\n",
        "signal":"sc_in<int> num_in;\nsc_out<bool> is_armstrong;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input. \n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<int> num_in;\nsc_out<bool> is_armstrong;\n> **Note**: Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n\n**C++\/C Code**:\n```\n\/\/ C++ program to implement the above approach\n#include <iostream>\nusing namespace std;\n\n\/\/ Driver code\nint main()\n{\n\tint n = 153;\n\tint temp = n;\n\tint p = 0;\n\n\t\/\/ Function to calculate\n\t\/\/ the sum of individual digits\n\twhile (n > 0) {\n\t\tint rem = n % 10;\n\t\tp = (p) + (rem * rem * rem);\n\t\tn = n \/ 10;\n\t}\n\n\t\/\/ Condition to check whether\n\t\/\/ the value of P equals\n\t\/\/ to user input or not.\n\tif (temp == p) {\n\t\tcout << (\"Yes. It is Armstrong No.\");\n\t}\n\telse {\n\t\tcout << (\"No. It is not an Armstrong No.\");\n\t}\n\treturn 0;\n}\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":58,
        "task":"FindtheMaximumandMinimuminanArray",
        "code":"\/\/ C++ program to find minimum (or maximum) element \n\/\/ in an array. \n#include <bits\/stdc++.h> \nusing namespace std; \n\nint getMin(int arr[], int n) \n{ \n\treturn *min_element(arr, arr + n); \n} \n\nint getMax(int arr[], int n) \n{ \n\treturn *max_element(arr, arr + n); \n} \n\nint main() \n{ \n\tint arr[] = { 12, 1234, 45, 67, 1 }; \n\tint n = sizeof(arr) \/ sizeof(arr[0]); \n\tcout << \"Minimum element of array: \" << getMin(arr, n) << \" \"; \n\tcout << \"Maximum element of array: \" << getMax(arr, n); \n\treturn 0; \n} \n",
        "category":"Array Operations",
        "sub_category":"Array Operations",
        "adoption":true,
        "reason":null,
        "module_name":"MinMax",
        "testbench":"SC_MODULE(Testbench) {\n    sc_clock clk;           \/\/ Clock signal for synchronization\n    sc_signal<bool> start;  \/\/ Signal to trigger the computation\n    sc_signal<bool> done;   \/\/ Signal indicating computation completion\n    sc_signal<int> min_val; \/\/ Signal for minimum element output\n    sc_signal<int> max_val; \/\/ Signal for maximum element output\n\n    \/\/ Instance of the MinMax module\n    MinMax* minmax_inst;\n\n    SC_CTOR(Testbench)\n        : clk(\"clk\", 1, SC_NS) \/\/ 1 ns clock period\n    {\n        minmax_inst = new MinMax(\"minmax_inst\");\n        minmax_inst->clk(clk);\n        minmax_inst->start(start);\n        minmax_inst->done(done);\n        minmax_inst->min_val(min_val);\n        minmax_inst->max_val(max_val);\n\n        SC_THREAD(run_tests);\n    }\n\n    \/\/ Process to run the test case\n    void run_tests() {\n        \/\/ Define and load the input array\n        int input_arr[5] = {12, 1234, 45, 67, 1};\n        minmax_inst->load_array(input_arr);\n\n        \/\/ Start the computation by asserting the start signal\n        start.write(true);\n        wait(1, SC_NS);\n        start.write(false);\n\n        \/\/ Wait until the MinMax module signals that computation is done\n        while (done.read() == false) {\n            wait(1, SC_NS);\n        }\n\n        \/\/ Retrieve computed results\n        int computed_min = min_val.read();\n        int computed_max = max_val.read();\n\n        \/\/ Expected results: minimum = 1, maximum = 1234\n        assert(computed_min == 1);\n        assert(computed_max == 1234);\n\n        std::cout << \"Computed minimum: \" << computed_min << std::endl;\n        std::cout << \"Computed maximum: \" << computed_max << std::endl;\n        std::cout << \"Test passed successfully.\" << std::endl;\n\n        sc_stop(); \/\/ End the simulation\n    }\n};\n\n\/\/ sc_main: Entry point for the SystemC simulation\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); \/\/ Create the testbench instance\n    sc_start();         \/\/ Start the simulation\n    return 0;\n}\n",
        "signal":"sc_in<bool> clk;\nsc_in<bool> start;\nsc_out<bool> done;\nsc_out<int> min_val;\nsc_out<int> max_val;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input. \n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<bool> clk;\nsc_in<bool> start;\nsc_out<bool> done;\nsc_out<int> min_val;\nsc_out<int> max_val;\n> **Note**: Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n\n**C++\/C Code**:\n```\n\/\/ C++ program to find minimum (or maximum) element \n\/\/ in an array. \n#include <bits\/stdc++.h> \nusing namespace std; \n\nint getMin(int arr[], int n) \n{ \n\treturn *min_element(arr, arr + n); \n} \n\nint getMax(int arr[], int n) \n{ \n\treturn *max_element(arr, arr + n); \n} \n\nint main() \n{ \n\tint arr[] = { 12, 1234, 45, 67, 1 }; \n\tint n = sizeof(arr) \/ sizeof(arr[0]); \n\tcout << \"Minimum element of array: \" << getMin(arr, n) << \" \"; \n\tcout << \"Maximum element of array: \" << getMax(arr, n); \n\treturn 0; \n} \n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\n#include <systemc.h>\n\n\/\/ BubbleSort Module: Implements the bubble sort algorithm\nSC_MODULE(BubbleSort) {\n    sc_in<bool> clk;      \/\/ Clock input\n    sc_in<bool> start;    \/\/ Signal to start sorting\n    sc_out<bool> done;    \/\/ Signal to indicate sorting is complete\n\n    \/\/ Internal storage for the array (fixed size of 4 elements)\n    int arr[4];\n\n    \/\/ Constructor: register the process\n    SC_CTOR(BubbleSort) {\n        SC_THREAD(sort_process);\n        sensitive << clk.pos();\n    }\n\n    \/\/ Process that waits for the start signal and performs sorting\n    void sort_process() {\n        while (true) {\n            wait(); \/\/ wait for a clock cycle\n            if (start.read() == true) {\n                bubbleSort(); \/\/ perform sorting\n                done.write(true);\n                wait(); \/\/ wait for one cycle to signal completion\n                done.write(false);\n            }\n        }\n    }\n\n    \/\/ Bubble sort algorithm implementation (sorts the internal array)\n    void bubbleSort() {\n        \/\/ Number of elements is fixed at 4\n        const int n = 4;\n        for (int i = 0; i < n - 1; i++) {\n            for (int j = 0; j < n - i - 1; j++) {\n                if (arr[j] > arr[j + 1]) {\n                    \/\/ Swap arr[j] and arr[j+1]\n                    int temp = arr[j];\n                    arr[j] = arr[j + 1];\n                    arr[j + 1] = temp;\n                }\n            }\n        }\n    }\n\n    \/\/ Helper method to load an input array into the module\n    void load_array(const int input[4]) {\n        for (int i = 0; i < 4; i++) {\n            arr[i] = input[i];\n        }\n    }\n\n    \/\/ Helper method to read the sorted array from the module\n    void read_array(int output[4]) {\n        for (int i = 0; i < 4; i++) {\n            output[i] = arr[i];\n        }\n    }\n};\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":59,
        "task":"ComputetheSumofDiagonalsofaMatrix",
        "code":"\/\/ A simple C++ program to find sum of diagonals \n#include <bits\/stdc++.h> \nusing namespace std; \n\nconst int MAX = 100; \n\nvoid printDiagonalSums(int mat[][MAX], int n) \n{ \n\tint principal = 0, secondary = 0; \n\tfor (int i = 0; i < n; i++) \n\t{ \n\t\tfor (int j = 0; j < n; j++)\t \n\t\t{ \n\t\t\t\/\/ Condition for principal diagonal \n\t\t\tif (i == j) \n\t\t\t\tprincipal += mat[i][j]; \n\n\t\t\t\/\/ Condition for secondary diagonal \n\t\t\tif ((i + j) == (n - 1)) \n\t\t\t\tsecondary += mat[i][j]; \n\t\t} \n\t} \n\n\tcout << \"Principal Diagonal:\" << \n\t\t\tprincipal << endl; \n\tcout << \"Secondary Diagonal:\" << \n\t\t\tsecondary << endl; \n} \n\n\/\/ Driver code \nint main() \n{ \n\tint a[][MAX] = {{1, 2, 3, 4}, \n\t\t\t\t\t{5, 6, 7, 8}, \n\t\t\t\t\t{1, 2, 3, 4}, \n\t\t\t\t\t{5, 6, 7, 8}}; \n\tprintDiagonalSums(a, 4); \n\treturn 0; \n} \n",
        "category":"Matrix Operations",
        "sub_category":"Matrix Operations",
        "adoption":true,
        "reason":null,
        "module_name":"DiagonalSum",
        "testbench":"SC_MODULE(Testbench) {\n    \/\/ Define constants for matrix dimensions\n    static const int N = 4;\n    static const int SIZE = N * N;\n    \/\/ Signals for the flattened matrix and the outputs\n    sc_signal<int> matrix[SIZE];\n    sc_signal<int> principal;\n    sc_signal<int> secondary;\n\n    \/\/ Instance of the DiagonalSum module\n    DiagonalSum* diagSum;\n\n    SC_CTOR(Testbench) {\n        \/\/ Instantiate the DiagonalSum module\n        diagSum = new DiagonalSum(\"diagSum\");\n        \/\/ Connect the matrix signals and outputs\n        for (int i = 0; i < SIZE; i++) {\n            diagSum->matrix[i](matrix[i]);\n        }\n        diagSum->principal(principal);\n        diagSum->secondary(secondary);\n\n        \/\/ Start the test thread\n        SC_THREAD(run_tests);\n    }\n\n    \/\/ Thread to initialize inputs, check outputs, and assert correctness\n    void run_tests() {\n        \/\/ Initialize the matrix as defined in the original C++ code:\n        \/\/  Matrix:\n        \/\/      {1, 2, 3, 4},\n        \/\/      {5, 6, 7, 8},\n        \/\/      {1, 2, 3, 4},\n        \/\/      {5, 6, 7, 8}\n        int mat[N][N] = {\n            {1, 2, 3, 4},\n            {5, 6, 7, 8},\n            {1, 2, 3, 4},\n            {5, 6, 7, 8}\n        };\n\n        \/\/ Write the matrix values to the flattened signal array\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                int index = i * N + j;\n                matrix[index].write(mat[i][j]);\n            }\n        }\n\n        \/\/ Wait for a small time to let the combinational logic settle\n        wait(1, SC_NS);\n\n        \/\/ Expected sums computed manually:\n        \/\/ Principal diagonal: 1 + 6 + 3 + 8 = 18\n        \/\/ Secondary diagonal: 4 + 7 + 2 + 5 = 18\n        int expected_principal = 18;\n        int expected_secondary = 18;\n\n        \/\/ Read the computed outputs\n        int computed_principal = principal.read();\n        int computed_secondary = secondary.read();\n\n        \/\/ Print the results\n        std::cout << \"Principal Diagonal Sum: \" << computed_principal << std::endl;\n        std::cout << \"Secondary Diagonal Sum: \" << computed_secondary << std::endl;\n\n        \/\/ Assert that the computed sums match the expected values\n        assert(computed_principal == expected_principal);\n        assert(computed_secondary == expected_secondary);\n        std::cout << \"All tests passed successfully.\" << std::endl;\n\n        sc_stop(); \/\/ Stop the simulation\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); \/\/ Create the testbench instance\n    sc_start();         \/\/ Start simulation\n    return 0;\n}\n",
        "signal":"sc_in<int> matrix[SIZE];\nsc_out<int> principal;\nsc_out<int> secondary;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input. \n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<int> matrix[SIZE];\nsc_out<int> principal;\nsc_out<int> secondary;\n> **Note**: Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n\n**C++\/C Code**:\n```\n\/\/ A simple C++ program to find sum of diagonals \n#include <bits\/stdc++.h> \nusing namespace std; \n\nconst int MAX = 100; \n\nvoid printDiagonalSums(int mat[][MAX], int n) \n{ \n\tint principal = 0, secondary = 0; \n\tfor (int i = 0; i < n; i++) \n\t{ \n\t\tfor (int j = 0; j < n; j++)\t \n\t\t{ \n\t\t\t\/\/ Condition for principal diagonal \n\t\t\tif (i == j) \n\t\t\t\tprincipal += mat[i][j]; \n\n\t\t\t\/\/ Condition for secondary diagonal \n\t\t\tif ((i + j) == (n - 1)) \n\t\t\t\tsecondary += mat[i][j]; \n\t\t} \n\t} \n\n\tcout << \"Principal Diagonal:\" << \n\t\t\tprincipal << endl; \n\tcout << \"Secondary Diagonal:\" << \n\t\t\tsecondary << endl; \n} \n\n\/\/ Driver code \nint main() \n{ \n\tint a[][MAX] = {{1, 2, 3, 4}, \n\t\t\t\t\t{5, 6, 7, 8}, \n\t\t\t\t\t{1, 2, 3, 4}, \n\t\t\t\t\t{5, 6, 7, 8}}; \n\tprintDiagonalSums(a, 4); \n\treturn 0; \n} \n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\n#include <systemc.h>\n\n\/\/ Use static const for constants instead of #define\nstatic const int N = 4;\nstatic const int SIZE = N * N;\n\n\/\/ Module that performs matrix addition\nSC_MODULE(MatrixAdder) {\n    \/\/ Input ports for matrices A and B (flattened as 1D arrays)\n    sc_in<int> A[SIZE];\n    sc_in<int> B[SIZE];\n    \/\/ Output ports for matrix C (flattened as 1D array)\n    sc_out<int> C[SIZE];\n\n    SC_CTOR(MatrixAdder) {\n        \/\/ Use an SC_METHOD to perform combinational matrix addition\n        SC_METHOD(do_add);\n        for (int i = 0; i < SIZE; i++) {\n            sensitive << A[i] << B[i];\n        }\n    }\n\n    \/\/ Method that adds corresponding elements of A and B\n    void do_add() {\n        for (int i = 0; i < SIZE; i++) {\n            C[i].write(A[i].read() + B[i].read());\n        }\n    }\n};\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":60,
        "task":"DisplayFactorsofaNaturalNumber",
        "code":"\/\/ C++ implementation of Naive method to print all divisors \n#include <iostream> \nusing namespace std; \n\n\/\/ Function to print the divisors \nvoid printDivisors(int n) \n{ \n\tfor (int i = 1; i <= n; i++) \n\t\tif (n % i == 0) \n\t\t\tcout <<\" \" << i; \n} \n\n\/\/ Driver code \nint main() \n{ \n\tcout <<\"The divisors of 100 are: \"; \n\tprintDivisors(100); \n\treturn 0; \n} \n\n\/\/ This code is contributed by shivanisinghss2110\n",
        "category":"Basic Math Operations",
        "sub_category":"Basic Math Operations",
        "adoption":false,
        "reason":"Unknown output length",
        "module_name":null,
        "testbench":null,
        "signal":null,
        "prompt":null
    },
    {
        "task_id":61,
        "task":"SearchanElementinanArray_LinearSearch",
        "code":"\/\/ C++ Program to implement linear search \n\/\/ algorithm iteratively\n#include <bits\/stdc++.h>\nusing namespace std;\n\nint linearSearch(vector<int> v, int key) {\n      \n      \/\/ We test all the elements of the vector\n      \/\/ v against the given key\n      for (int i = 0; i < v.size(); i++) {\n      \n          \/\/ If the KEY IS FOUND\n          if (v[i] == key) {\n              return i;\n        }\n    }\n      \n      \/\/ Return some value denoting KEY NOT FOUND\n      return -1;\n}\n\nint main() {\n    vector<int> v = {1, 2, 3, 4, 5, 8, 9, 11};\n  \n    \/\/ Value to search\n      int key = 8;\n\n    \/\/ Searching the key in the vector v\n      int i = linearSearch(v, key);\n      \n      \/\/ Checking if element is found or not\n    if (i != -1)\n        cout << key << \" Found at Position: \" <<\n              i + 1;\n    else\n        cout << key << \" NOT found.\";\n    return 0;\n}\n",
        "category":"Array Operations",
        "sub_category":"Array Searching",
        "adoption":true,
        "reason":null,
        "module_name":"LinearSearch",
        "testbench":"SC_MODULE(Testbench) {\n    sc_signal<int> key_sig;       \/\/ Signal for the search key\n    sc_signal<int> index_sig;     \/\/ Signal for the search result index\n    sc_vector< sc_signal<int> > data_signals; \/\/ Vector of signals for the data array\n\n    LinearSearch* ls_inst;        \/\/ Instance of the LinearSearch module\n\n    SC_CTOR(Testbench) : data_signals(\"data_signals\", 8) {\n        \/\/ Instantiate LinearSearch with an array size of 8\n        ls_inst = new LinearSearch(\"ls_inst\", 8);\n        ls_inst->key(key_sig);\n        ls_inst->index(index_sig);\n        for (int i = 0; i < 8; i++) {\n            ls_inst->data[i](data_signals[i]);\n        }\n\n        \/\/ Initialize the data array in the testbench (no test data inside LinearSearch)\n        data_signals[0].write(1);\n        data_signals[1].write(2);\n        data_signals[2].write(3);\n        data_signals[3].write(4);\n        data_signals[4].write(5);\n        data_signals[5].write(8);\n        data_signals[6].write(9);\n        data_signals[7].write(11);\n\n        SC_THREAD(run_tests);\n    }\n\n    \/\/ Thread that applies test cases and checks the outputs\n    void run_tests() {\n        \/\/ Test Case 1: key = 8; expected index = 5\n        key_sig.write(8);\n        wait(1, SC_NS);\n        assert(index_sig.read() == 5);\n        std::cout << \"Test 1 Passed: 8 found at index \" << index_sig.read() << std::endl;\n\n        \/\/ Test Case 2: key = 10; expected index = -1 (not found)\n        key_sig.write(10);\n        wait(1, SC_NS);\n        assert(index_sig.read() == -1);\n        std::cout << \"Test 2 Passed: 10 not found (index: \" << index_sig.read() << \")\" << std::endl;\n\n        \/\/ Test Case 3: key = 1; expected index = 0\n        key_sig.write(1);\n        wait(1, SC_NS);\n        assert(index_sig.read() == 0);\n        std::cout << \"Test 3 Passed: 1 found at index \" << index_sig.read() << std::endl;\n\n        std::cout << \"All tests completed successfully.\" << std::endl;\n        \n        \/\/ End simulation after tests\n        sc_stop();\n    }\n\n    \/\/ Destructor to clean up dynamically allocated memory\n    ~Testbench() {\n        delete ls_inst;\n    }\n};\n\n\/\/ sc_main: entry point for the SystemC simulation\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\");\n    sc_start();  \/\/ Start the simulation\n    return 0;\n}\n",
        "signal":"sc_in<int> key;\nsc_out<int> index;\nsc_vector< sc_in<int> > data;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input. \n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<int> key;\nsc_out<int> index;\nsc_vector< sc_in<int> > data;\n> **Note**: Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n\n**C++\/C Code**:\n```\n\/\/ C++ Program to implement linear search \n\/\/ algorithm iteratively\n#include <bits\/stdc++.h>\nusing namespace std;\n\nint linearSearch(vector<int> v, int key) {\n      \n      \/\/ We test all the elements of the vector\n      \/\/ v against the given key\n      for (int i = 0; i < v.size(); i++) {\n      \n          \/\/ If the KEY IS FOUND\n          if (v[i] == key) {\n              return i;\n        }\n    }\n      \n      \/\/ Return some value denoting KEY NOT FOUND\n      return -1;\n}\n\nint main() {\n    vector<int> v = {1, 2, 3, 4, 5, 8, 9, 11};\n  \n    \/\/ Value to search\n      int key = 8;\n\n    \/\/ Searching the key in the vector v\n      int i = linearSearch(v, key);\n      \n      \/\/ Checking if element is found or not\n    if (i != -1)\n        cout << key << \" Found at Position: \" <<\n              i + 1;\n    else\n        cout << key << \" NOT found.\";\n    return 0;\n}\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\n#include <systemc.h>\n\n\/\/ BubbleSort Module: Implements the bubble sort algorithm\nSC_MODULE(BubbleSort) {\n    sc_in<bool> clk;      \/\/ Clock input\n    sc_in<bool> start;    \/\/ Signal to start sorting\n    sc_out<bool> done;    \/\/ Signal to indicate sorting is complete\n\n    \/\/ Internal storage for the array (fixed size of 4 elements)\n    int arr[4];\n\n    \/\/ Constructor: register the process\n    SC_CTOR(BubbleSort) {\n        SC_THREAD(sort_process);\n        sensitive << clk.pos();\n    }\n\n    \/\/ Process that waits for the start signal and performs sorting\n    void sort_process() {\n        while (true) {\n            wait(); \/\/ wait for a clock cycle\n            if (start.read() == true) {\n                bubbleSort(); \/\/ perform sorting\n                done.write(true);\n                wait(); \/\/ wait for one cycle to signal completion\n                done.write(false);\n            }\n        }\n    }\n\n    \/\/ Bubble sort algorithm implementation (sorts the internal array)\n    void bubbleSort() {\n        \/\/ Number of elements is fixed at 4\n        const int n = 4;\n        for (int i = 0; i < n - 1; i++) {\n            for (int j = 0; j < n - i - 1; j++) {\n                if (arr[j] > arr[j + 1]) {\n                    \/\/ Swap arr[j] and arr[j+1]\n                    int temp = arr[j];\n                    arr[j] = arr[j + 1];\n                    arr[j + 1] = temp;\n                }\n            }\n        }\n    }\n\n    \/\/ Helper method to load an input array into the module\n    void load_array(const int input[4]) {\n        for (int i = 0; i < 4; i++) {\n            arr[i] = input[i];\n        }\n    }\n\n    \/\/ Helper method to read the sorted array from the module\n    void read_array(int output[4]) {\n        for (int i = 0; i < 4; i++) {\n            output[i] = arr[i];\n        }\n    }\n};\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":62,
        "task":"ReverseaNumber",
        "code":"\/\/ C++ program to implement \n\/\/ the above approach \n#include <bits\/stdc++.h> \nusing namespace std; \n\n\/\/ Iterative function to \n\/\/ reverse digits of num \nint reverseDigits(int num) \n{ \n\tint rev_num = 0; \n\twhile (num > 0) { \n\t\trev_num = rev_num * 10 + num % 10; \n\t\tnum = num \/ 10; \n\t} \n\treturn rev_num; \n} \n\n\/\/ Driver code \nint main() \n{ \n\tint num = 4562; \n\tcout << \"Reverse of num is \" << reverseDigits(num); \n\n\tgetchar(); \n\n\treturn 0; \n}\n",
        "category":"Miscellaneous",
        "sub_category":"Miscellaneous",
        "adoption":false,
        "reason":null,
        "module_name":null,
        "testbench":null,
        "signal":null,
        "prompt":null
    },
    {
        "task_id":63,
        "task":"MultiplyTwoMatrices",
        "code":"\/\/ C++ program to multiply two matrices\n\n#include <bits\/stdc++.h>\nusing namespace std;\n\n\/\/ Edit MACROs here, according to your Matrix Dimensions for\n\/\/ mat1[R1][C1] and mat2[R2][C2]\n#define R1 2 \/\/ number of rows in Matrix-1\n#define C1 2 \/\/ number of columns in Matrix-1\n#define R2 2 \/\/ number of rows in Matrix-2\n#define C2 3 \/\/ number of columns in Matrix-2\n\nvoid mulMat(int mat1[][C1], int mat2[][C2])\n{\n\tint rslt[R1][C2];\n\n\tcout << \"Multiplication of given two matrices is:\\n\";\n\n\tfor (int i = 0; i < R1; i++) {\n\t\tfor (int j = 0; j < C2; j++) {\n\t\t\trslt[i][j] = 0;\n\n\t\t\tfor (int k = 0; k < R2; k++) {\n\t\t\t\trslt[i][j] += mat1[i][k] * mat2[k][j];\n\t\t\t}\n\n\t\t\tcout << rslt[i][j] << \"\\t\";\n\t\t}\n\n\t\tcout << endl;\n\t}\n}\n\n\/\/ Driver code\nint main()\n{\n\t\/\/ R1 = 4, C1 = 4 and R2 = 4, C2 = 4 (Update these\n\t\/\/ values in MACROs)\n\tint mat1[R1][C1] = { { 1, 1 }, { 2, 2 } };\n\n\tint mat2[R2][C2] = { { 1, 1, 1 }, { 2, 2, 2 } };\n\n\tif (C1 != R2) {\n\t\tcout << \"The number of columns in Matrix-1 must \"\n\t\t\t\t\"be equal to the number of rows in \"\n\t\t\t\t\"Matrix-2\"\n\t\t\t<< endl;\n\t\tcout << \"Please update MACROs according to your \"\n\t\t\t\t\"array dimension in #define section\"\n\t\t\t<< endl;\n\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t\/\/ Function call\n\tmulMat(mat1, mat2);\n\n\treturn 0;\n}\n",
        "category":"Matrix Operations",
        "sub_category":"Matrix Operations",
        "adoption":true,
        "reason":null,
        "module_name":"MatrixMultiplier",
        "testbench":"SC_MODULE(Testbench) {\n    \/\/ Use static const for matrix dimensions\n    static const int R1 = 2;      \/\/ Rows in Matrix-1\n    static const int C1 = 2;      \/\/ Columns in Matrix-1\n    static const int R2 = 2;      \/\/ Rows in Matrix-2\n    static const int C2 = 3;      \/\/ Columns in Matrix-2\n\n    static const int SIZE_A = R1 * C1;      \/\/ Total elements in Matrix-1\n    static const int SIZE_B = R2 * C2;      \/\/ Total elements in Matrix-2\n    static const int SIZE_RESULT = R1 * C2; \/\/ Total elements in the Result matrix\n    \n    \/\/ Signals to connect to the MatrixMultiplier ports\n    sc_signal<int> A[SIZE_A];\n    sc_signal<int> B[SIZE_B];\n    sc_signal<int> C[SIZE_RESULT];\n\n    MatrixMultiplier* mm;\n\n    SC_CTOR(Testbench) {\n        \/\/ Instantiate the MatrixMultiplier module\n        mm = new MatrixMultiplier(\"mm\");\n        \/\/ Connect signals to the module's ports\n        for (int i = 0; i < SIZE_A; i++) {\n            mm->A[i](A[i]);\n        }\n        for (int i = 0; i < SIZE_B; i++) {\n            mm->B[i](B[i]);\n        }\n        for (int i = 0; i < SIZE_RESULT; i++) {\n            mm->C[i](C[i]);\n        }\n        \/\/ Create a thread to run the test cases\n        SC_THREAD(run_tests);\n    }\n\n    \/\/ Thread that initializes inputs, checks outputs, and asserts correctness\n    void run_tests() {\n        \/\/ Initialize Matrix A (2x2):\n        \/\/ { {1, 1},\n        \/\/   {2, 2} }\n        A[0].write(1); \/\/ Row 0, Column 0\n        A[1].write(1); \/\/ Row 0, Column 1\n        A[2].write(2); \/\/ Row 1, Column 0\n        A[3].write(2); \/\/ Row 1, Column 1\n\n        \/\/ Initialize Matrix B (2x3):\n        \/\/ { {1, 1, 1},\n        \/\/   {2, 2, 2} }\n        B[0].write(1); \/\/ Row 0, Column 0\n        B[1].write(1); \/\/ Row 0, Column 1\n        B[2].write(1); \/\/ Row 0, Column 2\n        B[3].write(2); \/\/ Row 1, Column 0\n        B[4].write(2); \/\/ Row 1, Column 1\n        B[5].write(2); \/\/ Row 1, Column 2\n\n        \/\/ Wait for the signals to propagate\n        wait(1, SC_NS);\n\n        \/\/ Expected result after multiplication:\n        \/\/ For result[0][0]: 1*1 + 1*2 = 3\n        \/\/ For result[0][1]: 1*1 + 1*2 = 3\n        \/\/ For result[0][2]: 1*1 + 1*2 = 3\n        \/\/ For result[1][0]: 2*1 + 2*2 = 6\n        \/\/ For result[1][1]: 2*1 + 2*2 = 6\n        \/\/ For result[1][2]: 2*1 + 2*2 = 6\n        int expected[SIZE_RESULT] = {3, 3, 3, 6, 6, 6};\n\n        std::cout << \"Matrix multiplication result:\" << std::endl;\n        for (int i = 0; i < SIZE_RESULT; i++) {\n            int res = C[i].read();\n            std::cout << res << \" \";\n            \/\/ Assert the computed result matches the expected value\n            assert(res == expected[i]);\n        }\n        std::cout << std::endl;\n        std::cout << \"All tests passed successfully.\" << std::endl;\n\n        sc_stop(); \/\/ Stop the simulation\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); \/\/ Instantiate the testbench\n    sc_start();         \/\/ Start simulation\n    return 0;\n}\n",
        "signal":"sc_in<int> A[SIZE_A];\nsc_in<int> B[SIZE_B];\nsc_out<int> C[SIZE_RESULT];",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input. \n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<int> A[SIZE_A];\nsc_in<int> B[SIZE_B];\nsc_out<int> C[SIZE_RESULT];\n> **Note**: Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n\n**C++\/C Code**:\n```\n\/\/ C++ program to multiply two matrices\n\n#include <bits\/stdc++.h>\nusing namespace std;\n\n\/\/ Edit MACROs here, according to your Matrix Dimensions for\n\/\/ mat1[R1][C1] and mat2[R2][C2]\n#define R1 2 \/\/ number of rows in Matrix-1\n#define C1 2 \/\/ number of columns in Matrix-1\n#define R2 2 \/\/ number of rows in Matrix-2\n#define C2 3 \/\/ number of columns in Matrix-2\n\nvoid mulMat(int mat1[][C1], int mat2[][C2])\n{\n\tint rslt[R1][C2];\n\n\tcout << \"Multiplication of given two matrices is:\\n\";\n\n\tfor (int i = 0; i < R1; i++) {\n\t\tfor (int j = 0; j < C2; j++) {\n\t\t\trslt[i][j] = 0;\n\n\t\t\tfor (int k = 0; k < R2; k++) {\n\t\t\t\trslt[i][j] += mat1[i][k] * mat2[k][j];\n\t\t\t}\n\n\t\t\tcout << rslt[i][j] << \"\\t\";\n\t\t}\n\n\t\tcout << endl;\n\t}\n}\n\n\/\/ Driver code\nint main()\n{\n\t\/\/ R1 = 4, C1 = 4 and R2 = 4, C2 = 4 (Update these\n\t\/\/ values in MACROs)\n\tint mat1[R1][C1] = { { 1, 1 }, { 2, 2 } };\n\n\tint mat2[R2][C2] = { { 1, 1, 1 }, { 2, 2, 2 } };\n\n\tif (C1 != R2) {\n\t\tcout << \"The number of columns in Matrix-1 must \"\n\t\t\t\t\"be equal to the number of rows in \"\n\t\t\t\t\"Matrix-2\"\n\t\t\t<< endl;\n\t\tcout << \"Please update MACROs according to your \"\n\t\t\t\t\"array dimension in #define section\"\n\t\t\t<< endl;\n\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t\/\/ Function call\n\tmulMat(mat1, mat2);\n\n\treturn 0;\n}\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\n#include <systemc.h>\n\n\/\/ Use static const for constants instead of #define\nstatic const int N = 4;\nstatic const int SIZE = N * N;\n\n\/\/ Module that performs matrix addition\nSC_MODULE(MatrixAdder) {\n    \/\/ Input ports for matrices A and B (flattened as 1D arrays)\n    sc_in<int> A[SIZE];\n    sc_in<int> B[SIZE];\n    \/\/ Output ports for matrix C (flattened as 1D array)\n    sc_out<int> C[SIZE];\n\n    SC_CTOR(MatrixAdder) {\n        \/\/ Use an SC_METHOD to perform combinational matrix addition\n        SC_METHOD(do_add);\n        for (int i = 0; i < SIZE; i++) {\n            sensitive << A[i] << B[i];\n        }\n    }\n\n    \/\/ Method that adds corresponding elements of A and B\n    void do_add() {\n        for (int i = 0; i < SIZE; i++) {\n            C[i].write(A[i].read() + B[i].read());\n        }\n    }\n};\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":64,
        "task":"MergeTwoArrays",
        "code":"\/\/ C++ program to merge two sorted arrays\/ \n#include<bits\/stdc++.h> \nusing namespace std; \n\nvoid mergeArrays(int arr1[], int arr2[], int n1, \n\t\t\t\t\t\t\tint n2, int arr3[]) \n{ \n\tint i = 0, j = 0, k = 0; \n\t\/\/ traverse the arr1 and insert its element in arr3 \n\twhile(i < n1){ \n\tarr3[k++] = arr1[i++]; \n\t} \n\t\t\n\t\/\/ now traverse arr2 and insert in arr3 \n\twhile(j < n2){ \n\tarr3[k++] = arr2[j++]; \n\t} \n\t\t\n\t\/\/ sort the whole array arr3 \n\tsort(arr3, arr3+n1+n2); \n} \n\n\/\/ Driver code \nint main() \n{ \n\tint arr1[] = {1, 3, 5, 7}; \n\tint n1 = sizeof(arr1) \/ sizeof(arr1[0]); \n\n\tint arr2[] = {2, 4, 6, 8}; \n\tint n2 = sizeof(arr2) \/ sizeof(arr2[0]); \n\n\tint arr3[n1+n2]; \n\tmergeArrays(arr1, arr2, n1, n2, arr3); \n\n\tcout << \"Array after merging\" <<endl; \n\tfor (int i=0; i < n1+n2; i++) \n\t\tcout << arr3[i] << \" \"; \n\n\treturn 0; \n} \n",
        "category":"Array Operations",
        "sub_category":"Array Processing",
        "adoption":false,
        "reason":"Too many signals",
        "module_name":null,
        "testbench":null,
        "signal":null,
        "prompt":null
    },
    {
        "task_id":65,
        "task":"RemoveDuplicateElementsFromanArray",
        "code":"\/\/ Simple C++ program to remove duplicates \n#include <iostream> \nusing namespace std; \n\n\/\/ Function to remove duplicate \n\/\/ elements This function returns \n\/\/ new size of modified array. \nint removeDuplicates(int arr[], int n) \n{ \n\t\/\/ Return, if array is empty or \n\t\/\/ contains a single element \n\tif (n == 0 || n == 1) \n\t\treturn n; \n\n\tint temp[n]; \n\n\t\/\/ Start traversing elements \n\tint j = 0; \n\n\t\/\/ If current element is not equal \n\t\/\/ to next element then store that \n\t\/\/ current element \n\tfor (int i = 0; i < n - 1; i++) \n\t\tif (arr[i] != arr[i + 1]) \n\t\t\ttemp[j++] = arr[i]; \n\n\t\/\/ Store the last element as whether \n\t\/\/ it is unique or repeated, it hasn't \n\t\/\/ stored previously \n\ttemp[j++] = arr[n - 1]; \n\n\t\/\/ Modify original array \n\tfor (int i = 0; i < j; i++) \n\t\tarr[i] = temp[i]; \n\n\treturn j; \n} \n\n\/\/ Driver code \nint main() \n{ \n\tint arr[] = {1, 2, 2, 3, 4, \n\t\t\t\t4, 4, 5, 5}; \n\tint n = sizeof(arr) \/ sizeof(arr[0]); \n\n\t\/\/ RemoveDuplicates() returns \n\t\/\/ new size of array. \n\tn = removeDuplicates(arr, n); \n\n\t\/\/ Print updated array \n\tfor (int i = 0; i < n; i++) \n\t\tcout << arr[i] << \" \"; \n\n\treturn 0; \n} \n\n\/\/ This code is contributed by Aditya Kumar (adityakumar129)\n",
        "category":"Array Operations",
        "sub_category":"Array Processing",
        "adoption":false,
        "reason":"Unknown output length",
        "module_name":null,
        "testbench":null,
        "signal":null,
        "prompt":null
    },
    {
        "task_id":66,
        "task":"RemoveAllOccurrencesofanElementinanArray",
        "code":"\/\/ C++ program to remove all the \n\/\/ occurrences \n#include <iostream>\nusing namespace std;\n\nvoid remove_all_occurrence(int arr[],\n\t\t\t\t\t\tint target,\n\t\t\t\t\t\tint n)\n{\nint cnt = 0;\n\n\/\/ Counting all occurrence of \n\/\/ target element\nfor(int i = 0; i < n; i++)\n{\n\tif(arr[i] == target) \n\tcnt++;\n}\n\t\n\/\/ Creating new array of \n\/\/ size = original size - \n\/\/ no. of target element\nint new_arr[n - cnt];\nint ind = 0;\nfor(int i = 0; i < n; i++)\n{\n\tif(arr[i] != target)\n\t{\n\tnew_arr[ind] = arr[i];\n\tind++;\n\t}\n}\n\t\n\/\/ Printing the new array \nint m = (sizeof(new_arr) \/ \n\t\tsizeof(new_arr[0]));\nfor(int i = 0; i < m; i++)\n{\n\tcout << new_arr[i] << \" \"; \n}\nreturn;\n}\n\n\/\/ Driver code\nint main() \n{\nint arr[]={1, 4, 3, 6, 8,\n\t\t\t3, 9, 10, 3, 3, 7};\nint target = 3;\nint n = (sizeof(arr) \/ \n\t\tsizeof(arr[0]));\nremove_all_occurrence(arr, target, n);\nreturn 0;\n}\n",
        "category":"Array Operations",
        "sub_category":"Array Processing",
        "adoption":false,
        "reason":"Unknown output length",
        "module_name":null,
        "testbench":null,
        "signal":null,
        "prompt":null
    },
    {
        "task_id":67,
        "task":"MultiplyTwoFloating-PointNumbers",
        "code":"\/\/ C++ program to multiply two \n\/\/ floating point numbers \n#include <iostream> \nusing namespace std; \n\n\/\/ Creating a user-defined function \n\/\/ called mul_floatnumbers that \n\/\/ multiplies the numbers passed to \n\/\/ it as an input. It gives you the \n\/\/ product of these numbers. \nfloat mul_floatnumbers(float a, float b) { return a * b; } \n\n\/\/ Driver code \nint main() \n{ \n\tfloat A = 1.2, B = 3.0, product; \n\n\t\/\/ Calling mul_floatnumbers function \n\tproduct = mul_floatnumbers(A, B); \n\n\t\/\/ Printing the output \n\tcout << product; \n\n\treturn 0; \n}\n",
        "category":"Basic Math Operations",
        "sub_category":"Basic Math Operations",
        "adoption":true,
        "reason":null,
        "module_name":"Multiplier",
        "testbench":"SC_MODULE(Testbench) {\n    \/\/ Signals to connect to the Multiplier module ports\n    sc_signal<float> a;\n    sc_signal<float> b;\n    sc_signal<float> product;\n\n    \/\/ Instance of the Multiplier module\n    Multiplier multiplier_inst;\n\n    \/\/ Constructor that sets up the testbench\n    SC_CTOR(Testbench)\n    : multiplier_inst(\"multiplier_inst\") {\n        \/\/ Connect signals to the multiplier's ports\n        multiplier_inst.a(a);\n        multiplier_inst.b(b);\n        multiplier_inst.product(product);\n\n        \/\/ Create a thread to run the test cases\n        SC_THREAD(run_tests);\n    }\n\n    \/\/ Thread that runs test cases for the Multiplier module\n    void run_tests() {\n        const float epsilon = 1e-6;\n\n        \/\/ Test case 1: Multiply 1.2 and 3.0 (Expected product: 3.6)\n        a.write(1.2);\n        b.write(3.0);\n        wait(1, SC_NS);\n        float result = product.read();\n        std::cout << \"1.2 * 3.0 = \" << result << std::endl;\n        assert(std::fabs(result - 3.6) < epsilon);\n\n        \/\/ Test case 2: Multiply 2.5 and 4.0 (Expected product: 10.0)\n        a.write(2.5);\n        b.write(4.0);\n        wait(1, SC_NS);\n        result = product.read();\n        std::cout << \"2.5 * 4.0 = \" << result << std::endl;\n        assert(std::fabs(result - 10.0) < epsilon);\n\n        std::cout << \"All tests passed successfully.\" << std::endl;\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    \/\/ Instantiate the testbench module\n    Testbench tb(\"tb\");\n\n    \/\/ Start the simulation\n    sc_start();\n\n    return 0;\n}\n",
        "signal":"sc_in<float> a;\nsc_in<float> b;\nsc_out<float> product;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input. \n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<float> a;\nsc_in<float> b;\nsc_out<float> product;\n> **Note**: Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n\n**C++\/C Code**:\n```\n\/\/ C++ program to multiply two \n\/\/ floating point numbers \n#include <iostream> \nusing namespace std; \n\n\/\/ Creating a user-defined function \n\/\/ called mul_floatnumbers that \n\/\/ multiplies the numbers passed to \n\/\/ it as an input. It gives you the \n\/\/ product of these numbers. \nfloat mul_floatnumbers(float a, float b) { return a * b; } \n\n\/\/ Driver code \nint main() \n{ \n\tfloat A = 1.2, B = 3.0, product; \n\n\t\/\/ Calling mul_floatnumbers function \n\tproduct = mul_floatnumbers(A, B); \n\n\t\/\/ Printing the output \n\tcout << product; \n\n\treturn 0; \n}\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":68,
        "task":"BinarytoOctalConversion",
        "code":"\/\/ C++ program to convert octal to decimal\n#include <iostream>\nusing namespace std;\n\n\/\/ Function to convert octal \n\/\/ to decimal\nint octalToDecimal(int n)\n{\n\tint num = n;\n\tint dec_value = 0;\n\n\t\/\/ Initializing base value to 1, \n\t\/\/ i.e 8^0\n\tint base = 1;\n\n\tint temp = num;\n\twhile (temp) \n\t{\n\t\t\/\/ Extracting last digit\n\t\tint last_digit = temp % 10;\n\t\ttemp = temp \/ 10;\n\n\t\t\/\/ Multiplying last digit with \n\t\t\/\/ appropriate base value and adding \n\t\t\/\/ it to dec_value\n\t\tdec_value += last_digit * base;\n\n\t\tbase = base * 8;\n\t}\n\n\treturn dec_value;\n}\n\n\/\/ Driver code\nint main()\n{\n\tint num = 67;\n\n\tcout << octalToDecimal(num) << endl;\n}\n",
        "category":"Basic Math Operations",
        "sub_category":"Number Base Conversion",
        "adoption":true,
        "reason":null,
        "module_name":"OctalToDecimalConverter",
        "testbench":"SC_MODULE(Testbench) {\n    sc_signal<int> octal_input; \/\/ Signal for the octal number\n    sc_signal<int> decimal_output; \/\/ Signal for the decimal number\n\n    OctalToDecimalConverter converter_inst; \/\/ Instance of the converter module\n\n    \/\/ Constructor\n    SC_CTOR(Testbench) : converter_inst(\"converter\") {\n        \/\/ Connect signals to ports\n        converter_inst.octal_input(octal_input);\n        converter_inst.decimal_output(decimal_output);\n\n        \/\/ Process to run tests\n        SC_THREAD(run_tests);\n    }\n\n    \/\/ Thread to run test cases\n    void run_tests() {\n        \/\/ Test case 1: Octal 67\n        octal_input = 67;\n        wait(1, SC_NS); \/\/ Wait for the converter to process\n        assert(decimal_output.read() == 55);\n        cout << \"Octal 67 -> Decimal \" << decimal_output.read() << endl;\n\n        \/\/ Test case 2: Octal 123\n        octal_input = 123;\n        wait(1, SC_NS);\n        assert(decimal_output.read() == 83);\n        cout << \"Octal 123 -> Decimal \" << decimal_output.read() << endl;\n\n        \/\/ Test case 3: Octal 0\n        octal_input = 0;\n        wait(1, SC_NS);\n        assert(decimal_output.read() == 0);\n        cout << \"Octal 0 -> Decimal \" << decimal_output.read() << endl;\n\n        \/\/ Test case 4: Octal 10\n        octal_input = 10;\n        wait(1, SC_NS);\n        assert(decimal_output.read() == 8);\n        cout << \"Octal 10 -> Decimal \" << decimal_output.read() << endl;\n\n        \/\/ Print success message\n        cout << \"All tests passed successfully.\" << endl;\n\n        sc_stop(); \/\/ Stop the simulation\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); \/\/ Create an instance of the Testbench\n\n    \/\/ Start the simulation\n    sc_start();\n\n    return 0;\n}\n",
        "signal":"sc_in<int> octal_input;\nsc_out<int> decimal_output;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input. \n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<int> octal_input;\nsc_out<int> decimal_output;\n> **Note**: Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n\n**C++\/C Code**:\n```\n\/\/ C++ program to convert octal to decimal\n#include <iostream>\nusing namespace std;\n\n\/\/ Function to convert octal \n\/\/ to decimal\nint octalToDecimal(int n)\n{\n\tint num = n;\n\tint dec_value = 0;\n\n\t\/\/ Initializing base value to 1, \n\t\/\/ i.e 8^0\n\tint base = 1;\n\n\tint temp = num;\n\twhile (temp) \n\t{\n\t\t\/\/ Extracting last digit\n\t\tint last_digit = temp % 10;\n\t\ttemp = temp \/ 10;\n\n\t\t\/\/ Multiplying last digit with \n\t\t\/\/ appropriate base value and adding \n\t\t\/\/ it to dec_value\n\t\tdec_value += last_digit * base;\n\n\t\tbase = base * 8;\n\t}\n\n\treturn dec_value;\n}\n\n\/\/ Driver code\nint main()\n{\n\tint num = 67;\n\n\tcout << octalToDecimal(num) << endl;\n}\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":69,
        "task":"AddTwoBinaryStrings",
        "code":"\/\/ C++ program to add two binary strings \n#include <bits\/stdc++.h> \nusing namespace std; \n\n\/\/ This function adds two binary strings and return result as a third string \nstring addBinary(string A, string B) \n{ \n\t\/\/ If the length of string A is greater \n\t\/\/ than the length of B then just swap \n\t\/\/ the string by calling the same \n\t\/\/ function and make sure to return \n\t\/\/ the function otherwise recursion \n\t\/\/ will occur which leads to calling \n\t\/\/ the same function twice \n\tif (A.length() > B.length()) \n\t\treturn addBinary(B, A); \n\n\t\/\/ Calculating the difference between \n\t\/\/ the length of the two strings. \n\tint diff = B.length() - A.length(); \n\n\t\/\/ Initialise the padding string which \n\t\/\/ is used to store zeroes that should \n\t\/\/ be added as prefix to the string which \n\t\/\/ has length smaller than the other string. \n\tstring padding; \n\tfor (int i = 0; i < diff; i++) \n\t\tpadding.push_back('0'); \n\n\tA = padding + A; \n\tstring res; \n\tchar carry = '0'; \n\n\tfor (int i = A.length() - 1; i >= 0; i--) \n\t{ \n\t\t\/\/ This if condition solves 110 111 \n\t\t\/\/ possible cases \n\t\tif (A[i] == '1' && B[i] == '1') \n\t\t{ \n\t\t\tif (carry == '1') \n\t\t\t\tres.push_back('1'), carry = '1'; \n\t\t\telse\n\t\t\t\tres.push_back('0'), carry = '1'; \n\t\t} \n\n\t\t\/\/ This if condition solves 000 001 \n\t\t\/\/ possible cases \n\t\telse if (A[i] == '0' && B[i] == '0') \n\t\t{ \n\t\t\tif (carry == '1') \n\t\t\t\tres.push_back('1'), carry = '0'; \n\t\t\telse\n\t\t\t\tres.push_back('0'), carry = '0'; \n\t\t} \n\n\t\t\/\/ This if condition solves 100 101 010 \n\t\t\/\/ 011 possible cases \n\t\telse if (A[i] != B[i]) \n\t\t{ \n\t\t\tif (carry == '1') \n\t\t\t\tres.push_back('0'), carry = '1'; \n\t\t\telse\n\t\t\t\tres.push_back('1'), carry = '0'; \n\t\t} \n\t} \n\n\t\/\/ If at the end their is carry then just \n\t\/\/ add it to the result \n\tif (carry == '1') \n\t\tres.push_back(carry); \n\t\/\/ reverse the result \n\treverse(res.begin(), res.end()); \n\n\t\/\/ To remove leading zeroes \n\tint index = 0; \n\twhile (index + 1 < res.length() && \n\t\tres[index] == '0') \n\t\tindex++; \n\treturn (res.substr(index)); \n} \n\n\/\/ Driver code \nint main() \n{ \n\tstring a = \"1101\", b = \"100\"; \n\tcout << addBinary(a, b) << endl; \n\treturn 0; \n}\n",
        "category":"Basic Math Operations",
        "sub_category":"Basic Math Operations",
        "adoption":true,
        "reason":null,
        "module_name":"BinaryAdder",
        "testbench":"SC_MODULE(Testbench) {\n    sc_signal<std::string> a; \/\/ Signal for the first binary string\n    sc_signal<std::string> b; \/\/ Signal for the second binary string\n    sc_signal<std::string> sum; \/\/ Signal for the sum of the binary strings\n\n    BinaryAdder adder_inst; \/\/ Instance of the BinaryAdder module\n\n    \/\/ Constructor\n    SC_CTOR(Testbench) : adder_inst(\"adder\") {\n        \/\/ Connect signals to ports\n        adder_inst.A(a);\n        adder_inst.B(b);\n        adder_inst.sum(sum);\n\n        \/\/ Process to run tests\n        SC_THREAD(run_tests);\n    }\n\n    \/\/ Thread to run test cases\n    void run_tests() {\n        \/\/ Test case 1: Simple addition\n        a = \"1101\"; b = \"100\";\n        wait(1, SC_NS); \/\/ Wait for the adder to process\n        assert(sum.read() == \"10001\");\n        std::cout << \"Sum: \" << sum.read() << std::endl;\n\n        \/\/ Test case 2: Different lengths\n        a = \"1010\"; b = \"11010\";\n        wait(1, SC_NS);\n        assert(sum.read() == \"100100\");\n        std::cout << \"Sum: \" << sum.read() << std::endl;\n\n        \/\/ Test case 3: Leading zeros in result\n        a = \"0\"; b = \"0\";\n        wait(1, SC_NS);\n        assert(sum.read() == \"0\");\n        std::cout << \"Sum: \" << sum.read() << std::endl;\n\n        \/\/ Test case 4: Different values\n        a = \"1111\"; b = \"1\";\n        wait(1, SC_NS);\n        assert(sum.read() == \"10000\");\n        std::cout << \"Sum: \" << sum.read() << std::endl;\n\n        \/\/ Print success message\n        std::cout << \"All tests passed successfully.\" << std::endl;\n\n        sc_stop(); \/\/ Stop the simulation\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); \/\/ Create an instance of the Testbench\n\n    \/\/ Start the simulation\n    sc_start();\n\n    return 0;\n}\n",
        "signal":"sc_in<std::string> A;\nsc_in<std::string> B;\nsc_out<std::string> sum;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input. \n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<std::string> A;\nsc_in<std::string> B;\nsc_out<std::string> sum;\n> **Note**: Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n\n**C++\/C Code**:\n```\n\/\/ C++ program to add two binary strings \n#include <bits\/stdc++.h> \nusing namespace std; \n\n\/\/ This function adds two binary strings and return result as a third string \nstring addBinary(string A, string B) \n{ \n\t\/\/ If the length of string A is greater \n\t\/\/ than the length of B then just swap \n\t\/\/ the string by calling the same \n\t\/\/ function and make sure to return \n\t\/\/ the function otherwise recursion \n\t\/\/ will occur which leads to calling \n\t\/\/ the same function twice \n\tif (A.length() > B.length()) \n\t\treturn addBinary(B, A); \n\n\t\/\/ Calculating the difference between \n\t\/\/ the length of the two strings. \n\tint diff = B.length() - A.length(); \n\n\t\/\/ Initialise the padding string which \n\t\/\/ is used to store zeroes that should \n\t\/\/ be added as prefix to the string which \n\t\/\/ has length smaller than the other string. \n\tstring padding; \n\tfor (int i = 0; i < diff; i++) \n\t\tpadding.push_back('0'); \n\n\tA = padding + A; \n\tstring res; \n\tchar carry = '0'; \n\n\tfor (int i = A.length() - 1; i >= 0; i--) \n\t{ \n\t\t\/\/ This if condition solves 110 111 \n\t\t\/\/ possible cases \n\t\tif (A[i] == '1' && B[i] == '1') \n\t\t{ \n\t\t\tif (carry == '1') \n\t\t\t\tres.push_back('1'), carry = '1'; \n\t\t\telse\n\t\t\t\tres.push_back('0'), carry = '1'; \n\t\t} \n\n\t\t\/\/ This if condition solves 000 001 \n\t\t\/\/ possible cases \n\t\telse if (A[i] == '0' && B[i] == '0') \n\t\t{ \n\t\t\tif (carry == '1') \n\t\t\t\tres.push_back('1'), carry = '0'; \n\t\t\telse\n\t\t\t\tres.push_back('0'), carry = '0'; \n\t\t} \n\n\t\t\/\/ This if condition solves 100 101 010 \n\t\t\/\/ 011 possible cases \n\t\telse if (A[i] != B[i]) \n\t\t{ \n\t\t\tif (carry == '1') \n\t\t\t\tres.push_back('0'), carry = '1'; \n\t\t\telse\n\t\t\t\tres.push_back('1'), carry = '0'; \n\t\t} \n\t} \n\n\t\/\/ If at the end their is carry then just \n\t\/\/ add it to the result \n\tif (carry == '1') \n\t\tres.push_back(carry); \n\t\/\/ reverse the result \n\treverse(res.begin(), res.end()); \n\n\t\/\/ To remove leading zeroes \n\tint index = 0; \n\twhile (index + 1 < res.length() && \n\t\tres[index] == '0') \n\t\tindex++; \n\treturn (res.substr(index)); \n} \n\n\/\/ Driver code \nint main() \n{ \n\tstring a = \"1101\", b = \"100\"; \n\tcout << addBinary(a, b) << endl; \n\treturn 0; \n}\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":70,
        "task":"FindLargestAmong3Numbers",
        "code":"\/\/ C++ Program to find largest among three numbers using if-else-if ladder\n#include <iostream>\nusing namespace std;\n\nint main() {\n    int a = 1, b = 2, c = 11;\n\n    \/\/ Finding the largest by comparing using\n      \/\/ relational operators with if-else\n    if (a >= b) {\n        if (a >= c)\n            cout << a;\n        else\n            cout << c;\n    }\n    else {\n        if (b >= c)\n            cout << b;\n        else\n            cout << c;\n    }\n\n    return 0;\n}\n",
        "category":"Basic Math Operations",
        "sub_category":"Basic Math Operations",
        "adoption":true,
        "reason":null,
        "module_name":"LargestFinder",
        "testbench":"SC_MODULE(Testbench) {\n    sc_signal<int> a; \/\/ Signal for the first number\n    sc_signal<int> b; \/\/ Signal for the second number\n    sc_signal<int> c; \/\/ Signal for the third number\n    sc_signal<int> largest; \/\/ Signal for the largest number\n\n    LargestFinder largest_finder_inst; \/\/ Instance of the LargestFinder module\n\n    \/\/ Constructor\n    SC_CTOR(Testbench) : largest_finder_inst(\"largest_finder\") {\n        \/\/ Connect signals to ports\n        largest_finder_inst.a(a);\n        largest_finder_inst.b(b);\n        largest_finder_inst.c(c);\n        largest_finder_inst.largest(largest);\n\n        \/\/ Process to run tests\n        SC_THREAD(run_tests);\n    }\n\n    \/\/ Thread to run test cases\n    void run_tests() {\n        \/\/ Test case 1: Basic test\n        a = 1; b = 2; c = 11;\n        wait(1, SC_NS); \/\/ Wait for the largest_finder to process\n        assert(largest.read() == 11);\n        cout << \"Largest: \" << largest.read() << endl;\n\n        \/\/ Test case 2: All numbers are the same\n        a = 5; b = 5; c = 5;\n        wait(1, SC_NS);\n        assert(largest.read() == 5);\n        cout << \"Largest: \" << largest.read() << endl;\n\n        \/\/ Test case 3: Two numbers are the same, one is larger\n        a = 7; b = 7; c = 8;\n        wait(1, SC_NS);\n        assert(largest.read() == 8);\n        cout << \"Largest: \" << largest.read() << endl;\n\n        \/\/ Test case 4: Two numbers are the same, one is smaller\n        a = 9; b = 9; c = 1;\n        wait(1, SC_NS);\n        assert(largest.read() == 9);\n        cout << \"Largest: \" << largest.read() << endl;\n\n        \/\/ Test case 5: All different numbers\n        a = 3; b = 15; c = 9;\n        wait(1, SC_NS);\n        assert(largest.read() == 15);\n        cout << \"Largest: \" << largest.read() << endl;\n\n        \/\/ Print success message\n        cout << \"All tests passed successfully.\" << endl;\n\n        sc_stop(); \/\/ Stop the simulation\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); \/\/ Create an instance of the Testbench\n\n    \/\/ Start the simulation\n    sc_start();\n\n    return 0;\n}\n",
        "signal":"sc_in<int> a;\nsc_in<int> b;\nsc_in<int> c;\nsc_out<int> largest;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input. \n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<int> a;\nsc_in<int> b;\nsc_in<int> c;\nsc_out<int> largest;\n> **Note**: Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n\n**C++\/C Code**:\n```\n\/\/ C++ Program to find largest among three numbers using if-else-if ladder\n#include <iostream>\nusing namespace std;\n\nint main() {\n    int a = 1, b = 2, c = 11;\n\n    \/\/ Finding the largest by comparing using\n      \/\/ relational operators with if-else\n    if (a >= b) {\n        if (a >= c)\n            cout << a;\n        else\n            cout << c;\n    }\n    else {\n        if (b >= c)\n            cout << b;\n        else\n            cout << c;\n    }\n\n    return 0;\n}\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":71,
        "task":"FindtheTransposeofaMatrix",
        "code":"\/\/ C++ Program to find the transpose \n\/\/ of a matrix\n#include <bits\/stdc++.h> \nusing namespace std; \n#define N 4\n\n\/\/ This function stores transpose \n\/\/ of A[][] in B[][]\nvoid transpose(int A[][N], \n\t\t\tint B[][N])\n{\n\tint i, j;\n\tfor (i = 0; i < N; i++)\n\t\tfor (j = 0; j < N; j++)\n\t\t\tB[i][j] = A[j][i];\n}\n\n\/\/ Driver code\nint main()\n{\n\tint A[N][N] = {{1, 1, 1, 1},\n\t\t\t\t{2, 2, 2, 2},\n\t\t\t\t{3, 3, 3, 3},\n\t\t\t\t{4, 4, 4, 4}};\n\n\tint B[N][N], i, j;\n\n\ttranspose(A, B);\n\n\tcout << \"Result matrix is \\n\";\n\tfor (i = 0; i < N; i++)\n\t{\n\t\tfor (j = 0; j < N; j++)\n\t\tcout << \" \" << B[i][j];\n\t\tcout <<\"\\n\";\n\t}\n\treturn 0;\n}\n",
        "category":"Matrix Operations",
        "sub_category":"Matrix Operations",
        "adoption":true,
        "reason":null,
        "module_name":"MatrixTranspose",
        "testbench":"SC_MODULE(Testbench) {\n    \/\/ Use static const for constants instead of #define\n    static const int N = 4;\n    static const int SIZE = N * N;\n    \n    \/\/ Signals to connect to the MatrixTranspose ports\n    sc_signal<int> A[SIZE];\n    sc_signal<int> B[SIZE];\n\n    MatrixTranspose* transpose_inst;\n\n    SC_CTOR(Testbench) {\n        \/\/ Instantiate the MatrixTranspose module\n        transpose_inst = new MatrixTranspose(\"MatrixTranspose\");\n        \/\/ Connect the signals to the module's ports\n        for (int i = 0; i < SIZE; i++) {\n            transpose_inst->A[i](A[i]);\n            transpose_inst->B[i](B[i]);\n        }\n        \/\/ Create a thread to run the test cases\n        SC_THREAD(run_tests);\n    }\n\n    \/\/ Thread that initializes inputs, checks outputs, and asserts correctness\n    void run_tests() {\n        \/\/ Initialize matrix A as defined in the original C++ code:\n        \/\/ A = { {1, 1, 1, 1},\n        \/\/       {2, 2, 2, 2},\n        \/\/       {3, 3, 3, 3},\n        \/\/       {4, 4, 4, 4} }\n        for (int row = 0; row < N; row++) {\n            for (int col = 0; col < N; col++) {\n                int index = row * N + col;\n                A[index].write(row + 1); \/\/ row 0 -> 1, row 1 -> 2, etc.\n            }\n        }\n\n        \/\/ Wait for the signals to propagate and the combinational logic to settle.\n        wait(1, SC_NS);\n\n        \/\/ Check the result transposed matrix B and print the output\n        std::cout << \"Result matrix is:\" << std::endl;\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                int index = i * N + j;\n                \/\/ Expected value: since B[i][j] = A[j][i] and each row j of A is (j+1)\n                int expected = j + 1;\n                int result = B[index].read();\n                \/\/ Validate the result using assert\n                assert(result == expected);\n                std::cout << result << \" \";\n            }\n            std::cout << std::endl;\n        }\n        std::cout << \"All tests passed successfully.\" << std::endl;\n\n        sc_stop(); \/\/ Stop the simulation\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); \/\/ Create an instance of the Testbench\n    sc_start();         \/\/ Start the simulation\n    return 0;\n}\n",
        "signal":"sc_in<int> A[SIZE];\nsc_out<int> B[SIZE];",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input. \n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<int> A[SIZE];\nsc_out<int> B[SIZE];\n> **Note**: Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n\n**C++\/C Code**:\n```\n\/\/ C++ Program to find the transpose \n\/\/ of a matrix\n#include <bits\/stdc++.h> \nusing namespace std; \n#define N 4\n\n\/\/ This function stores transpose \n\/\/ of A[][] in B[][]\nvoid transpose(int A[][N], \n\t\t\tint B[][N])\n{\n\tint i, j;\n\tfor (i = 0; i < N; i++)\n\t\tfor (j = 0; j < N; j++)\n\t\t\tB[i][j] = A[j][i];\n}\n\n\/\/ Driver code\nint main()\n{\n\tint A[N][N] = {{1, 1, 1, 1},\n\t\t\t\t{2, 2, 2, 2},\n\t\t\t\t{3, 3, 3, 3},\n\t\t\t\t{4, 4, 4, 4}};\n\n\tint B[N][N], i, j;\n\n\ttranspose(A, B);\n\n\tcout << \"Result matrix is \\n\";\n\tfor (i = 0; i < N; i++)\n\t{\n\t\tfor (j = 0; j < N; j++)\n\t\tcout << \" \" << B[i][j];\n\t\tcout <<\"\\n\";\n\t}\n\treturn 0;\n}\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\n#include <systemc.h>\n\n\/\/ Use static const for constants instead of #define\nstatic const int N = 4;\nstatic const int SIZE = N * N;\n\n\/\/ Module that performs matrix addition\nSC_MODULE(MatrixAdder) {\n    \/\/ Input ports for matrices A and B (flattened as 1D arrays)\n    sc_in<int> A[SIZE];\n    sc_in<int> B[SIZE];\n    \/\/ Output ports for matrix C (flattened as 1D array)\n    sc_out<int> C[SIZE];\n\n    SC_CTOR(MatrixAdder) {\n        \/\/ Use an SC_METHOD to perform combinational matrix addition\n        SC_METHOD(do_add);\n        for (int i = 0; i < SIZE; i++) {\n            sensitive << A[i] << B[i];\n        }\n    }\n\n    \/\/ Method that adds corresponding elements of A and B\n    void do_add() {\n        for (int i = 0; i < SIZE; i++) {\n            C[i].write(A[i].read() + B[i].read());\n        }\n    }\n};\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    }
]