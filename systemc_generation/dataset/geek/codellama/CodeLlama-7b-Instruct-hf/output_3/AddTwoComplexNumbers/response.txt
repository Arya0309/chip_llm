  This code sample presents a practical strategy for conducting "glue logic design" or creating prototypes for Digital-to-Analog Converters (DACs) for Audio signals . This code employs a Temporal Coherent ADC in the example given. 

First, we'll do some pre-processing on the C++ code to reflect the inputs and outputs in a process-pumped operation model.

1.Here, we'll collect all the DAC input channels and connect them to the arrays enabling the concatenation of all inputs from the DACs before processing them on the FPGA interface. The FPGA will operate per-vector 

2.Next, we process the output of each of the DACs and sum up the data to get the output -> The FPGA can perform an abstraction of the DAC data in an optimised (Reduced Plant) timed Always-Completed behavior. This includes the operations used in a PLD/CPLD - Type DAC's such as baseTOP, phase rotator, etc. Students should generate the optimized-always-completed operation and translate the logical to hardware  - IP (asynchronous logic).

3.The code sample uses two threads to implement a process-pumped asynchronous operation to output the converted values, or, transposes the approximated values transmitted from the ADCs to the DACs. 

 Addressing some segmentation issues here, segment 1 (includes the C++ import statement),
 segment 2(includes the User Defined Complex class),
 segment3(contains the driver code ).

For the signals provided, the inputs of this code are the real and imaginary parts of two complex number C1 and C2 . And the outputs must be the real part of the sum of the two complex numbers and the imaginary part of the sum of the two complex numbers.  

the rest of the code won't differ much from a textbook example :)