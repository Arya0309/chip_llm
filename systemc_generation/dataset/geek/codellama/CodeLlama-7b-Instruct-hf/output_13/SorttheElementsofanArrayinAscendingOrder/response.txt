  To distill the functionality of the given C++ program into SystemC code, we'll employ a roadmap that starts with identifying the inputs and outputs of the code. Once we have a clear understanding of both aspects, we can proceed to identifying the major parts of the code and their purposes. The resulting SystemC code will mirror the logic of the original C++/C source.

**Inputs:**

The inputs to the program are the array `num[]` and its size, `len`. The array `num[]` holds the array input, and `len` stores the length of the input.

**Outputs:**

The output of the program is the sorted array `num[]`.

**Block-by-block Analysis:**

1. The program starts with the following line:
	* `// C++ program to sort array in ascending order using Brute-force approach using bubble sort`.
This comment serves as an introduction for the program, providing context for the functionality it exhibits.
2. The following line initializes the `nums` array and calculates its length:
   
   `int nums[] = { 1, 12, 6, 8, 10 };`  
   `int size_nums = (sizeof(nums) / sizeof(nums[0]));`
	
	These instructions represent the initial inputs that serve as seed data for the sorting process. 
3. Then, the user-defined `sort()` function is called on the input array `nums`. 
	
   `sort(nums, size_nums);`
It takes two inputs: the array `nums` and its length `len`. 
4. The `sort()` function makes all the necessary arrangements and modifies the input array by way of the `swapNums()` function. 

   `void sort(int num[], int len)`
   ```C++
   for (int i = len - 1; i >= 0; i--) {
   for (int j = 0; j < i; j++) {
   if (num[j] > num[j + 1]) swapNums(num, j, j + 1);
}
}
   ```
 It iterates through the `nums` array and checks each number against the subsequent numbers. If a number is greater than its predecessor, its position is swapped with the value of the preceding number. The Number of iterations in this function is mainly governed by the length of `nums`.
5. The final output of the program is obtained when the user-defined `checkorder()` function detects whether `nums` is properly sorted and, if necessary, finishes the sorting process. 

   ` bool checkorder(int *nums, int size_nums);`
   ```C++
   for (i = 0; i < size_nums - 1; i++) {
   if (nums[i] > nums[i+1]) return false;
}
return true;
   ```
6. The final output of the program is successfully generated when `checkorder()` returns true.

**SystemC Code Snippet:**

To create a comparable piece of code in SystemC, we'll be using the specified signals, `clk`, `start`, `done`, and `num`, a vector<int> with roughly the same size as the array `nums` in the given program. The signal `done` will switch to `1` after the array processing is finished, indicating that the program is complete.

\begin{pre}

#include <systemc.h>

// Module that sorts array in ascending order using bubble sort

SC_MODULE(BubbleSort) {
    // Signal definition
    sc_in<bool> clk;
    sc_in<bool> start;
    sc_out<bool> done;
    sc_vector<int> num;

    // Constructor
    SC_CTOR(BubbleSort) {
        // Process to sort array
        SC_METHOD(sort);
        sensitive << start << clk.pos();
	}

    // sort function
    void sort();
    {
      int len = num.size();

      for (i = len - 1; i >= 0; i--) {
       for (j = 0; j < i; j++) {
       if (num[j] > num[j + 1]) swapNums(num, j, j + 1);
}
}
      done.write(true);
    }

    // swapNums function 
    void swapNums(int num, int j, int j1){
      int temp = num[j];
      num[j] = num[j + 1];
      num[j + 1] = temp;
    } 
};
```
The sort function sorts an array using bubble sort. It takes two inputs: the array `num` and its size `len`. It iterates through `nums` backwards and inside the inner loop, it iterates through its immediate neighbors. If a specified position declaration is greater than the following one, then the values are passed through `swapNums()`.  

Finally, the `sort()` function will flag `done` once execution is complete. Unfortunately, the function can't check the sorted array efficiently, so we've chosen not to include that in the sort function's code.