  Output the decimal value of the octal input.

Input: Octal number to convert.

The given code from the C++/C++ source is intended to convert any octal number input and output the same octal value in decimal. A good example of this logic would be if something broadcasts an octal number, you would want to find that same octal number but in decimal form so that it can be given to something more suitable.

Declarations: The first portion of this code is a "using namespace std;" it allows you to "import" the standard C++ header file in order to access the STL. "namespace" is a way of grouping things together in C++. 
The second portion is "using namespace std;. This line imports the standard C++ library. In particular, this line imports the cin, cout, cin.get, and more. std is commonly used object namespaces in C++. 
The third portion "int octal_input;". This creates a variable name, octal_input. Each variable can hold a unique piece of information. In this case it is a singular only piece of information in the form of an integer.
This is a "function" and the text states this further down in the document.
"int octalToDecimal(int n)". The integers are passed into this function as an argument for the "integer" n. This acts as an equal sign.
"int decimal_output;". This is used to create a "local variable" that is NOT the same level as the function. The variable is used as an "output" with a "finished" value from the function.
Within the parenthesis, the function takes the number determined as integer n and makes a variable called num that is equivalent to n.
"int temp = num;" and then assigns temp to the variable num that was treated earlier, indicating the number determined a moment ago.
The next two lines implement a new integer variable n being labelled base, which is initialized to 0. This is referred to as a "promotion." Two lines later, the integer n is labeled "temp" to compare and store the number for later comparison and use.
The next 8 lines implement a block of a loop. The first portion of this line is "while (temp)" which will run each line inside the loops block since the condition stated is true. 
In the first line "int last_digit = temp % 10;" this acts like a function within the main function in the first part of the equation. This takes a line and uses every object within that line as an "input". The command that is in the parenthesis is equal to the "number" but it only has 8 objects comprising the number. It is taking the last listed object that appears to be a "list" made of lists and returns the last octal list, because the code is looping through what appears to be 4 lists, but the one on the last line of the base number is the 8 objcet that is equivalent to the object which would be produced in C++/C++ if the numbers were just treated as a whole. 
"temp = temp / 10;" is a similar function although it dynamically finds out what the last number was that appears when ran, this then "divides" the "function" which is the camerafe as more than the division is unique. This tells the code that there are 8 digits and not room for 4 digits used in the previous step. You must divide by 10 in order to halt the "power" or to be more accurate, not to divide by 10. 
" dec_value += last_digit * base;" is assigning dec_value the value of last_digit * base. The dec_value is determined via an equilateral equation where the previous equation and the next two object are the base and last digit for all digits shown.

"base = base * 8;" is where the code takes the last digit and multiplies it by 8 in this case becuase it is the largest. The total of "base" is n and last_digit. Because this is the highest number with all digits it can look at in the "truth" of the code and why we would want last_digit to be the maximum octal code.

Within the while loop you find the following:
"int num = n;", this statement determines that an "integer" with the name "num" is augmented or given a larger integer "n" that the previous integer was augmented, or has larger power and dimensions, if that makes sense. This is made obvious in next line.
"int base = 1;". This is used because it is the first integer used when almost everything is an octal number, not a decimal number hence the reason why base was made earlier on in the lines.
Since the first line obtains the value for the first octal digit and the value of the "base", an addition is made, here you can see that the geneal logic is to make the base with a 1, which is a unique octal number also.

Within the while loop: "int temp = num;" is a function which returns num, because it is a block within a block.
Since num has power and dimensions the code is going to check if there is another variable that is equal to num, this is more evident in this command for next line: "int last_digit = temp % 10;". This line actually obtains num % 0.
If anything were to be obtained, it would be a kind of unique object unique power and width like: 32 % 0. And if it was equal to 0, the code would be terminated. 
"temp = temp / 10" would thus cancel for this for-while loop to take place. 
The code is originally stated to run "while (temp);", and if the statement were true, the code will be added up like normal, using the declaration of last_digit. This is because the code operates similarly if the last_digit returns as x, and the code increments until it is run for its maximum, which is 15 power.

"dec_value += last_digit * base;" this line is where the analysis and actual execution is seperated. The code operates so that each number from (1-8) is calculated, and each number "multiplies" on its own base, with a power of 8 vigor added on each iteration, which is quickly noticed by the number, because 8 * 1 = 8, 8 * 8 = 64 and so or latter on with each calculation. This is why the whole realation behind the code is always another unique, but higher octal translation of the number for each case.
Continuing with this, it is true that base *= 8 is stopping the code from continuing more, because the code picks for the base the highest value, which is 8 in this case. .

The next thing the code is intented to do is take "dec_value" and "sum" which are both "buckets" for storing the data from the octal input value.
The value after this is 
"sum != 0;", which makes total or added value of sum for that integer become 96.
The last few results that are ï¿½ï¿½gets, copy, oncopyx called in the next window shows that the output of this is 360, from a 67 in octal. >> done, to check if correct.

So to summarize the translation is 67, is equal to 360, //(360 x 8^0) / 10,base NOT ACCURATE SINCE N IS NULL, 67 / 8 || 8 x 8 
67, N could be "698", 698 x 8 = 5888. 
698 / 1000 = 0. X istnot defined, 

Sure it is equal to base = 1, if it is properly calculated. 

67, N could be "698", steps written above.

>> 64
>> 5888
>> not defined
>> 62
>> 120 only if (sum != 26;) isn't written.