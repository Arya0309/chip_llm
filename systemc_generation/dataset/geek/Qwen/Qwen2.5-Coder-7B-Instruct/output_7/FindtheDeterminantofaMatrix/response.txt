### Input and Output Analysis

**Inputs:**
1. A square matrix of size `n x n`. This is passed through the `matrix` signal in the SystemC code.

**Outputs:**
1. The determinant of the input matrix. This is passed through the `det` signal in the SystemC code.

### Detailed Line-by-Line Explanation

1. **Header Inclusions and Namespace Declaration:**
   ```cpp
   #include <iostream>
   #include <cmath>
   using namespace std;
   ```
   - `#include <iostream>`: Includes the standard I/O library for input and output operations.
   - `#include <cmath>`: Includes the mathematical functions library.
   - `using namespace std;`: Uses the standard namespace to avoid prefixing standard library names with `std::`.

2. **Constants and Array Declaration:**
   ```cpp
   const int MAXN = 105;
   double a[MAXN][MAXN];
   ```
   - `const int MAXN = 105;`: Defines a constant `MAXN` which is set to 105. This is used to define the maximum size of the matrix.
   - `double a[MAXN][MAXN];`: Declares a 2D array `a` of type `double` to store the matrix elements.

3. **Function to Calculate Determinant:**
   ```cpp
   double determinant(int n) {
       double det = 1.0;
       for (int i = 0; i < n; i++) {
           int pivot = i;
           for (int j = i + 1; j < n; j++) {
               if (abs(a[j][i]) > abs(a[pivot][i])) {
                   pivot = j;
               }
           }
           if (pivot != i) {
               swap(a[i], a[pivot]);
               det *= -1;
           }
           if (a[i][i] == 0) {
               return 0;
           }
           det *= a[i][i];
           for (int j = i + 1; j < n; j++) {
               double factor = a[j][i] / a[i][i];
               for (int k = i + 1; k < n; k++) {
                   a[j][k] -= factor * a[i][k];
               }
           }
       }
       return det;
   }
   ```
   - **Line-by-Line Explanation:**
     - `double det = 1.0;`: Initializes the determinant `det` to 1.0.
     - `for (int i = 0; i < n; i++) { ... }`: Outer loop to iterate over each row.
     - `int pivot = i;`: Sets the current row index as the pivot.
     - `for (int j = i + 1; j < n; j++) { ... }`: Inner loop to find the row with the maximum absolute value in the current column.
     - `if (abs(a[j][i]) > abs(a[pivot][i])) { pivot = j; }`: Updates the pivot if a larger element is found.
     - `if (pivot != i) { swap(a[i], a[pivot]); det *= -1; }`: Swaps rows if necessary and updates the determinant sign.
     - `if (a[i][i] == 0) { return 0; }`: Checks if the pivot element is zero, indicating a singular matrix.
     - `det *= a[i][i];`: Multiplies the determinant by the pivot element.
     - `for (int j = i + 1; j < n; j++) { ... }`: Inner loop to eliminate elements below the pivot.
     - `double factor = a[j][i] / a[i][i];`: Calculates the factor to eliminate the current element.
     - `for (int k = i + 1; k < n; k++) { a[j][k] -= factor * a[i][k]; }`: Updates the elements below the pivot.

4. **Main Function:**
   ```cpp
   int main() {
       int n = 4;
       double matrix[4][4] = {{1, 0, 2, -1},
                               {3, 0, 0, 5},
                               {2, 1, 4, -3},
                               {1, 0, 5, 0}};
       for (int i = 0; i < n; i++) {
           for (int j = 0; j < n; j++) {
               a[i][j] = matrix[i][j];
           }
       }
       double det = determinant(n);
       cout << "Determinant = " << det << endl;
       return 0;
   }
   ```
   - **Line-by-Line Explanation:**
     - `int n = 4;`: Defines the size of the matrix.
     - `double matrix[4][4] = { ... };`: Initializes the matrix with given values.
     - `for (int i = 0; i < n; i++) { ... }`: Copies the matrix values into the `a` array.
     - `double det = determinant(n);`: Calls the `determinant` function to calculate the determinant.
     - `cout << "Determinant = " << det << endl;`: Outputs the determinant.

### Equivalent SystemC Code

```cpp
#include <systemc.h>

SC_MODULE(DeterminantCalculator) {
    sc_in<double> matrix[4];  // Input port for the matrix
    sc_out<double> det;       // Output port for the determinant

    SC_CTOR(DeterminantCalculator) {
        SC_METHOD(calculate_determinant);
        sensitive << matrix;
    }

    void calculate_determinant() {
        double a[4][4];
        for (int i = 0; i < 4; i++) {
            for (int j = 0; j < 4; j++) {
                a[i][j] = matrix[i].read();
            }
        }

        double det = 1.0;
        for (int i = 0; i < 4; i++) {
            int pivot = i;
            for (int j = i + 1; j < 4; j++) {
                if (abs(a[j][i]) > abs(a[pivot][i])) {
                    pivot = j;
                }
            }
            if (pivot != i) {
                for (int k = 0; k < 4; k++) {
                    swap(a[i][k], a[pivot][k]);
                }
                det *= -1;
            }
            if (a[i][i] == 0) {
                det = 0;
                break;
            }
            det *= a[i][i];
            for (int j = i + 1; j < 4; j++) {
                double factor = a[j][i] / a[i][i];
                for (int k = i + 1; k < 4; k++) {
                    a[j][k] -= factor * a[i][k];
                }
            }
        }
        this->det.write(det);
    }
};
```

### Explanation of the SystemC Code

- **Module Definition:**
  - `SC_MODULE(DeterminantCalculator)`: Defines a SystemC module named `DeterminantCalculator`.
  
- **Input and Output Ports:**
  - `sc_in<double> matrix[4];`: An input port for the matrix.
  - `sc_out<double> det;`: An output port for the determinant.
  
- **Constructor:**
  - `SC_CTOR(DeterminantCalculator)`: Constructor initializes the module and binds the method `calculate_determinant` to the input port `matrix`.

- **Method to Calculate Determinant:**
  - `void calculate_determinant()`: Method to calculate the determinant of the input matrix.
  - The method reads the matrix values from the input port and stores them in the `a` array.
  - It then follows the same logic as the original C++ code to compute the determinant.
  - The result is written to the output port `det`.

This SystemC code faithfully captures the logic of the original C++ code and can be integrated into a high-level synthesis flow.