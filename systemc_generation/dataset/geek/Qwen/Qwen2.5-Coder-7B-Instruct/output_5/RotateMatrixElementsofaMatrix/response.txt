### C++/C Code Analysis

**Inputs:**
1. `int mat[R][C]`: A 2D array representing the matrix to be rotated.
2. `int m`: The number of rows in the matrix.
3. `int n`: The number of columns in the matrix.

**Outputs:**
1. The rotated matrix is printed to the console.

**Explanation:**
The code rotates a given matrix in-place by 90 degrees clockwise. The rotation is done layer by layer, starting from the outermost layer and moving towards the inner layers. The rotation involves four steps:
1. Moving the top row to the right column.
2. Moving the right column to the bottom row.
3. Moving the bottom row to the left column.
4. Moving the left column to the top row.

This process is repeated until all layers are rotated.

### SystemC Code Snippet

To integrate the rotation logic into a SystemC module, we need to create a module that takes in a 2D array of integers and outputs the rotated matrix. We will use the provided signals `in[SIZE]` and `out[SIZE]` to handle the input and output of the matrix.

Here is the equivalent SystemC code:

```cpp
#include <systemc.h>

// Define the size of the matrix
const int SIZE = 4;

// Module to rotate a matrix
SC_MODULE(MatrixRotator) {
    sc_in<int> in[SIZE * SIZE];  // Input port for the matrix
    sc_out<int> out[SIZE * SIZE]; // Output port for the rotated matrix

    // Constructor
    SC_CTOR(MatrixRotator) {
        // Process to perform matrix rotation
        SC_METHOD(rotate_matrix);
        sensitive << in;
    }

    // Method to rotate the matrix
    void rotate_matrix() {
        int mat[SIZE][SIZE];

        // Convert input vector to 2D array
        for (int i = 0; i < SIZE; ++i) {
            for (int j = 0; j < SIZE; ++j) {
                mat[i][j] = in[i * SIZE + j].read();
            }
        }

        int m = SIZE;
        int n = SIZE;
        int row = 0, col = 0;
        int prev, curr;

        while (row < m && col < n) {
            if (row + 1 == m || col + 1 == n) break;

            prev = mat[row + 1][col];

            // Move elements of first row from the remaining rows
            for (int i = col; i < n; ++i) {
                curr = mat[row][i];
                mat[row][i] = prev;
                prev = curr;
            }
            row++;

            // Move elements of last column from the remaining columns
            for (int i = row; i < m; ++i) {
                curr = mat[i][n - 1];
                mat[i][n - 1] = prev;
                prev = curr;
            }
            n--;

            // Move elements of last row from the remaining rows
            if (row < m) {
                for (int i = n - 1; i >= col; --i) {
                    curr = mat[m - 1][i];
                    mat[m - 1][i] = prev;
                    prev = curr;
                }
            }
            m--;

            // Move elements of first column from the remaining rows
            if (col < n) {
                for (int i = m - 1; i >= row; --i) {
                    curr = mat[i][col];
                    mat[i][col] = prev;
                    prev = curr;
                }
            }
            col++;
        }

        // Convert 2D array back to output vector
        for (int i = 0; i < SIZE; ++i) {
            for (int j = 0; j < SIZE; ++j) {
                out[i * SIZE + j].write(mat[i][j]);
            }
        }
    }
};
```

### Explanation of SystemC Code
1. **Module Declaration**: The `MatrixRotator` module is declared with input and output ports.
2. **Constructor**: The constructor initializes the `rotate_matrix` method to be sensitive to changes on the input ports.
3. **rotate_matrix Method**: This method performs the following steps:
   - Converts the input vector to a 2D array.
   - Rotates the matrix using the same logic as the original C++ code.
   - Converts the rotated 2D array back to a vector and writes it to the output ports.

This SystemC code snippet faithfully captures the logic of the original C++/C source code and can be integrated with the provided signals for testbench integration.