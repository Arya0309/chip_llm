[
    {
        "task_id":1,
        "task":"AddTwoBinaryStrings",
        "code":"\/\/ C++ program to add two binary strings \n#include <bits\/stdc++.h> \nusing namespace std; \n\n\/\/ This function adds two binary strings and return result as a third string \nstring addBinary(string A, string B) \n{ \n\t\/\/ If the length of string A is greater \n\t\/\/ than the length of B then just swap \n\t\/\/ the string by calling the same \n\t\/\/ function and make sure to return \n\t\/\/ the function otherwise recursion \n\t\/\/ will occur which leads to calling \n\t\/\/ the same function twice \n\tif (A.length() > B.length()) \n\t\treturn addBinary(B, A); \n\n\t\/\/ Calculating the difference between \n\t\/\/ the length of the two strings. \n\tint diff = B.length() - A.length(); \n\n\t\/\/ Initialise the padding string which \n\t\/\/ is used to store zeroes that should \n\t\/\/ be added as prefix to the string which \n\t\/\/ has length smaller than the other string. \n\tstring padding; \n\tfor (int i = 0; i < diff; i++) \n\t\tpadding.push_back('0'); \n\n\tA = padding + A; \n\tstring res; \n\tchar carry = '0'; \n\n\tfor (int i = A.length() - 1; i >= 0; i--) \n\t{ \n\t\t\/\/ This if condition solves 110 111 \n\t\t\/\/ possible cases \n\t\tif (A[i] == '1' && B[i] == '1') \n\t\t{ \n\t\t\tif (carry == '1') \n\t\t\t\tres.push_back('1'), carry = '1'; \n\t\t\telse\n\t\t\t\tres.push_back('0'), carry = '1'; \n\t\t} \n\n\t\t\/\/ This if condition solves 000 001 \n\t\t\/\/ possible cases \n\t\telse if (A[i] == '0' && B[i] == '0') \n\t\t{ \n\t\t\tif (carry == '1') \n\t\t\t\tres.push_back('1'), carry = '0'; \n\t\t\telse\n\t\t\t\tres.push_back('0'), carry = '0'; \n\t\t} \n\n\t\t\/\/ This if condition solves 100 101 010 \n\t\t\/\/ 011 possible cases \n\t\telse if (A[i] != B[i]) \n\t\t{ \n\t\t\tif (carry == '1') \n\t\t\t\tres.push_back('0'), carry = '1'; \n\t\t\telse\n\t\t\t\tres.push_back('1'), carry = '0'; \n\t\t} \n\t} \n\n\t\/\/ If at the end their is carry then just \n\t\/\/ add it to the result \n\tif (carry == '1') \n\t\tres.push_back(carry); \n\t\/\/ reverse the result \n\treverse(res.begin(), res.end()); \n\n\t\/\/ To remove leading zeroes \n\tint index = 0; \n\twhile (index + 1 < res.length() && \n\t\tres[index] == '0') \n\t\tindex++; \n\treturn (res.substr(index)); \n} \n\n\/\/ Driver code \nint main() \n{ \n\tstring a = \"1101\", b = \"100\"; \n\tcout << addBinary(a, b) << endl; \n\treturn 0; \n}\n",
        "category":"Basic Math",
        "adoption":true,
        "reason":null,
        "module_name":"BinaryAdderBV",
        "testbench":"SC_MODULE(Testbench) {\n    sc_signal< sc_dt::sc_bv<8> > sig_a, sig_b;\n    sc_signal< sc_dt::sc_bv<9> > sig_sum;\n\n    BinaryAdderBV adder;  \/\/ 實例化加法器\n\n    SC_CTOR(Testbench)\n    : adder(\"adder\") {\n        adder.A(sig_a);\n        adder.B(sig_b);\n        adder.SUM(sig_sum);\n        SC_THREAD(run_tests);\n    }\n\n    void run_tests() {\n        auto trim = [&](const std::string &bv) {\n            auto pos = bv.find('1');\n            if (pos == std::string::npos) return std::string(\"0\");\n            return bv.substr(pos);\n        };\n\n        \/\/ Test case 1: \"1101\" + \"100\" => \"10001\"\n        sig_a.write(\"00001101\");\n        sig_b.write(\"00000100\");\n        wait(1, SC_NS);\n        {\n            std::string s = sig_sum.read().to_string();\n            std::string output = trim(s);\n            std::cout << \"1101 + 100 = 10001\" << std::endl;\n            std::cout << \"Output: \" << output << std::endl;\n            assert(output == \"10001\");\n        }\n\n        \/\/ Test case 2: \"1010\" + \"11010\" => \"100100\"\n        sig_a.write(\"00001010\");\n        sig_b.write(\"00011010\");\n        wait(1, SC_NS);\n        {\n            std::string s = sig_sum.read().to_string();\n            std::string output = trim(s);\n            std::cout << \"Test case 2: 1010 + 11010 = 100100\" << std::endl;\n            std::cout << \"Output: \" << output << std::endl;\n            assert(output == \"100100\");\n        }\n\n        \/\/ Test case 3: \"0\" + \"0\" => \"0\"\n        sig_a.write(\"00000000\");\n        sig_b.write(\"00000000\");\n        wait(1, SC_NS);\n        {\n            std::string s = sig_sum.read().to_string();\n            std::string t = trim(s);\n            std::cout << \"0 + 0 = \" << t << std::endl;\n            assert(t == \"0\");\n        }\n\n        \/\/ Test case 4: \"1111\" + \"1\" => \"10000\"\n        sig_a.write(\"00001111\");\n        sig_b.write(\"00000001\");\n        wait(1, SC_NS);\n        {\n            std::string s = sig_sum.read().to_string();\n            std::string t = trim(s);\n            std::cout << \"1111 + 1 = \" << t << std::endl;\n            assert(t == \"10000\");\n        }\n\n        std::cout << \"All tests passed successfully.\" << std::endl;\n        sc_stop();\n    }\n};\n\n\/\/ sc_main\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\");\n    sc_start();\n    return 0;\n}\n",
        "signal":"sc_in< sc_dt::sc_bv<8> > A;\nsc_in< sc_dt::sc_bv<8> > B;\nsc_out< sc_dt::sc_bv<9> > SUM;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input.\n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in< sc_dt::sc_bv<8> > A;\nsc_in< sc_dt::sc_bv<8> > B;\nsc_out< sc_dt::sc_bv<9> > SUM;\n> **Note**:\n   - Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n   - If the static const are provided, insure to write them in the SystemC code as well.\n\n**C++\/C Code**:\n```\n\/\/ C++ program to add two binary strings \n#include <bits\/stdc++.h> \nusing namespace std; \n\n\/\/ This function adds two binary strings and return result as a third string \nstring addBinary(string A, string B) \n{ \n\t\/\/ If the length of string A is greater \n\t\/\/ than the length of B then just swap \n\t\/\/ the string by calling the same \n\t\/\/ function and make sure to return \n\t\/\/ the function otherwise recursion \n\t\/\/ will occur which leads to calling \n\t\/\/ the same function twice \n\tif (A.length() > B.length()) \n\t\treturn addBinary(B, A); \n\n\t\/\/ Calculating the difference between \n\t\/\/ the length of the two strings. \n\tint diff = B.length() - A.length(); \n\n\t\/\/ Initialise the padding string which \n\t\/\/ is used to store zeroes that should \n\t\/\/ be added as prefix to the string which \n\t\/\/ has length smaller than the other string. \n\tstring padding; \n\tfor (int i = 0; i < diff; i++) \n\t\tpadding.push_back('0'); \n\n\tA = padding + A; \n\tstring res; \n\tchar carry = '0'; \n\n\tfor (int i = A.length() - 1; i >= 0; i--) \n\t{ \n\t\t\/\/ This if condition solves 110 111 \n\t\t\/\/ possible cases \n\t\tif (A[i] == '1' && B[i] == '1') \n\t\t{ \n\t\t\tif (carry == '1') \n\t\t\t\tres.push_back('1'), carry = '1'; \n\t\t\telse\n\t\t\t\tres.push_back('0'), carry = '1'; \n\t\t} \n\n\t\t\/\/ This if condition solves 000 001 \n\t\t\/\/ possible cases \n\t\telse if (A[i] == '0' && B[i] == '0') \n\t\t{ \n\t\t\tif (carry == '1') \n\t\t\t\tres.push_back('1'), carry = '0'; \n\t\t\telse\n\t\t\t\tres.push_back('0'), carry = '0'; \n\t\t} \n\n\t\t\/\/ This if condition solves 100 101 010 \n\t\t\/\/ 011 possible cases \n\t\telse if (A[i] != B[i]) \n\t\t{ \n\t\t\tif (carry == '1') \n\t\t\t\tres.push_back('0'), carry = '1'; \n\t\t\telse\n\t\t\t\tres.push_back('1'), carry = '0'; \n\t\t} \n\t} \n\n\t\/\/ If at the end their is carry then just \n\t\/\/ add it to the result \n\tif (carry == '1') \n\t\tres.push_back(carry); \n\t\/\/ reverse the result \n\treverse(res.begin(), res.end()); \n\n\t\/\/ To remove leading zeroes \n\tint index = 0; \n\twhile (index + 1 < res.length() && \n\t\tres[index] == '0') \n\t\tindex++; \n\treturn (res.substr(index)); \n} \n\n\/\/ Driver code \nint main() \n{ \n\tstring a = \"1101\", b = \"100\"; \n\tcout << addBinary(a, b) << endl; \n\treturn 0; \n}\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\nFew_shot_example_1:\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        dont_initialize();\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n\nFew_shot_example_2:\n#include <systemc.h>\n\n\/\/ Module: BubbleSort\n\/\/ Sorts a small fixed-size array of integers using the bubble sort algorithm.\nSC_MODULE(BubbleSort) {\n    sc_in<bool>  clk;      \/\/ Clock signal\n    sc_in<bool>  start;    \/\/ Start signal to begin sorting\n    sc_out<bool> done;     \/\/ Signal asserted when sorting is complete\n\n    sc_in<int>   in_arr[4];  \/\/ Input array of 4 integers to be sorted\n    sc_out<int>  out_arr[4]; \/\/ Output array of 4 sorted integers\n\n    int buf[4];  \/\/ Internal buffer to hold array elements during sorting\n\n    \/\/ Constructor: registers the sorting process with the clock\n    SC_CTOR(BubbleSort) {\n        SC_THREAD(sort_proc);\n        sensitive << clk.pos();\n    }\n\n    \/\/ Thread: waits for start, performs bubble sort, writes results, toggles done\n    void sort_proc() {\n        const int N = 4;\n        while (true) {\n            wait();  \/\/ wait for next clock edge\n            if (start.read()) {\n                \/\/ Read inputs into internal buffer\n                for (int i = 0; i < N; ++i)\n                    buf[i] = in_arr[i].read();\n\n                \/\/ Perform bubble sort on buffer[]\n                for (int i = 0; i < N - 1; ++i)\n                    for (int j = 0; j < N - i - 1; ++j)\n                        if (buf[j] > buf[j + 1])\n                            std::swap(buf[j], buf[j + 1]);\n\n                \/\/ Write sorted results to output ports\n                for (int i = 0; i < N; ++i)\n                    out_arr[i].write(buf[i]);\n\n                \/\/ Signal done for one cycle\n                done.write(true);\n                wait();\n                done.write(false);\n            }\n        }\n    }\n};\n\nFew_shot_example_3:\n#include <systemc.h>\n\n\/\/ Module: MatrixAdder\n\/\/ Adds two 4×4 matrices of integers element-wise.\nSC_MODULE(MatrixAdder) {\n    sc_in<int> A[4*4];   \/\/ Flattened 4×4 input matrix A (16 elements)\n    sc_in<int> B[4*4];   \/\/ Flattened 4×4 input matrix B (16 elements)\n    sc_out<int> C[4*4];  \/\/ Flattened 4×4 output matrix C = A + B\n\n    \/\/ Constructor: registers a combinational add method sensitive to all inputs\n    SC_CTOR(MatrixAdder) {\n        SC_METHOD(do_add);\n        \/\/ Make the add method sensitive to every element of A and B\n        for (int i = 0; i < 4*4; i++) {\n            sensitive << A[i] << B[i];\n        }\n    }\n\n    \/\/ Method: reads A[i] and B[i], writes sum into C[i] for all 16 positions\n    void do_add() {\n        for (int i = 0; i < 4*4; i++) {\n            C[i].write(A[i].read() + B[i].read());\n        }\n    }\n};\n\n\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":2,
        "task":"AddTwoComplexNumbers",
        "code":"\/\/ C++ Program to Add Two Complex Numbers\n\n\/\/ Importing all libraries\n#include<bits\/stdc++.h>\nusing namespace std;\n\n\/\/ User Defined Complex class\nclass Complex \n{ \n\t\/\/ Declaring variables\n\tpublic: int real, imaginary;\n\n\t\/\/ Constructor to accept\n\t\/\/ real and imaginary part\n\tComplex(int tempReal = 0, \n\t\t\tint tempImaginary = 0)\n\t{\n\t\treal = tempReal;\n\t\timaginary = tempImaginary;\n\t}\n\n\t\/\/ Defining addComp() method\n\t\/\/ for adding two complex number\n\tComplex addComp(Complex C1, Complex C2)\n\t{\n\t\t\/\/ Creating temporary variable\n\t\tComplex temp;\n\n\t\t\/\/ Adding real part of \n\t\t\/\/ complex numbers\n\t\ttemp.real = C1.real + C2.real;\n\n\t\t\/\/ Adding Imaginary part of \n\t\t\/\/ complex numbers\n\t\ttemp.imaginary = (C1.imaginary + C2.imaginary);\n\n\t\t\/\/ Returning the sum\n\t\treturn temp;\n\t}\n};\n\n\/\/ Driver code\nint main()\n{\n\t\/\/ First Complex number\n\tComplex C1(3, 2);\n\n\t\/\/ printing first complex number\n\tcout << \"Complex number 1 : \" << \n\t\t\tC1.real << \" + i\" << \n\t\t\tC1.imaginary << endl;\n\n\t\/\/ Second Complex number\n\tComplex C2(9, 5);\n\n\t\/\/ Printing second complex number\n\tcout << \"Complex number 2 : \" << \n\t\t\tC2.real << \" + i\" << \n\t\t\tC2.imaginary << endl;\n\n\t\/\/ For Storing the sum\n\tComplex C3;\n\n\t\/\/ Calling addComp() method\n\tC3 = C3.addComp(C1, C2);\n\n\t\/\/ Printing the sum\n\tcout << \"Sum of complex number : \" << \n\t\t\tC3.real << \" + i\" << \n\t\t\tC3.imaginary;\n}\n",
        "category":"Basic Math",
        "adoption":true,
        "reason":null,
        "module_name":"ComplexAdder",
        "testbench":"SC_MODULE(Testbench) {\n    sc_signal<int> real1;   \/\/ Signal for the real part of the first complex number\n    sc_signal<int> imag1;   \/\/ Signal for the imaginary part of the first complex number\n    sc_signal<int> real2;   \/\/ Signal for the real part of the second complex number\n    sc_signal<int> imag2;   \/\/ Signal for the imaginary part of the second complex number\n    sc_signal<int> real_sum;  \/\/ Signal for the real part of the sum\n    sc_signal<int> imag_sum;  \/\/ Signal for the imaginary part of the sum\n\n    ComplexAdder adder_inst; \/\/ Instance of the ComplexAdder module\n\n    \/\/ Constructor\n    SC_CTOR(Testbench) : adder_inst(\"adder\") {\n        \/\/ Connect signals to ports\n        adder_inst.real1(real1);\n        adder_inst.imag1(imag1);\n        adder_inst.real2(real2);\n        adder_inst.imag2(imag2);\n        adder_inst.real_sum(real_sum);\n        adder_inst.imag_sum(imag_sum);\n\n        \/\/ Process to run tests\n        SC_THREAD(run_tests);\n    }\n\n    \/\/ Thread to run test cases\n    void run_tests() {\n        \/\/ Test case: Adding complex numbers (3 + 2i) and (9 + 5i)\n        real1 = 3; imag1 = 2;\n        real2 = 9; imag2 = 5;\n        wait(1, SC_NS); \/\/ Wait for the adder to process\n        \n        \/\/ Use assertions to check that the sum is as expected\n        assert(real_sum.read() == 12 && \"Real sum is incorrect!\");\n        assert(imag_sum.read() == 7 && \"Imaginary sum is incorrect!\");\n\n        \/\/ Test case: Adding complex numbers (3 - 3i) and (9 + 5i)\n        real1 = 3; imag1 = -3;\n        real2 = 9; imag2 = 5;\n        wait(1, SC_NS); \/\/ Wait for the adder to process\n\n        \/\/ Use assertions to check that the sum is as expected\n        assert(real_sum.read() == 12 && \"Real sum is incorrect!\");\n        assert(imag_sum.read() == 2 && \"Imaginary sum is incorrect!\");\n\n        std::cout << \"All tests passed successfully.\" << std::endl;\n\n        sc_stop(); \/\/ Stop the simulation\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); \/\/ Create an instance of the Testbench\n\n    \/\/ Start the simulation\n    sc_start();\n\n    return 0;\n}\n",
        "signal":"sc_in<int> real1;\nsc_in<int> imag1;\nsc_in<int> real2;\nsc_in<int> imag2;\nsc_out<int> real_sum;\nsc_out<int> imag_sum;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input.\n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<int> real1;\nsc_in<int> imag1;\nsc_in<int> real2;\nsc_in<int> imag2;\nsc_out<int> real_sum;\nsc_out<int> imag_sum;\n> **Note**:\n   - Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n   - If the static const are provided, insure to write them in the SystemC code as well.\n\n**C++\/C Code**:\n```\n\/\/ C++ Program to Add Two Complex Numbers\n\n\/\/ Importing all libraries\n#include<bits\/stdc++.h>\nusing namespace std;\n\n\/\/ User Defined Complex class\nclass Complex \n{ \n\t\/\/ Declaring variables\n\tpublic: int real, imaginary;\n\n\t\/\/ Constructor to accept\n\t\/\/ real and imaginary part\n\tComplex(int tempReal = 0, \n\t\t\tint tempImaginary = 0)\n\t{\n\t\treal = tempReal;\n\t\timaginary = tempImaginary;\n\t}\n\n\t\/\/ Defining addComp() method\n\t\/\/ for adding two complex number\n\tComplex addComp(Complex C1, Complex C2)\n\t{\n\t\t\/\/ Creating temporary variable\n\t\tComplex temp;\n\n\t\t\/\/ Adding real part of \n\t\t\/\/ complex numbers\n\t\ttemp.real = C1.real + C2.real;\n\n\t\t\/\/ Adding Imaginary part of \n\t\t\/\/ complex numbers\n\t\ttemp.imaginary = (C1.imaginary + C2.imaginary);\n\n\t\t\/\/ Returning the sum\n\t\treturn temp;\n\t}\n};\n\n\/\/ Driver code\nint main()\n{\n\t\/\/ First Complex number\n\tComplex C1(3, 2);\n\n\t\/\/ printing first complex number\n\tcout << \"Complex number 1 : \" << \n\t\t\tC1.real << \" + i\" << \n\t\t\tC1.imaginary << endl;\n\n\t\/\/ Second Complex number\n\tComplex C2(9, 5);\n\n\t\/\/ Printing second complex number\n\tcout << \"Complex number 2 : \" << \n\t\t\tC2.real << \" + i\" << \n\t\t\tC2.imaginary << endl;\n\n\t\/\/ For Storing the sum\n\tComplex C3;\n\n\t\/\/ Calling addComp() method\n\tC3 = C3.addComp(C1, C2);\n\n\t\/\/ Printing the sum\n\tcout << \"Sum of complex number : \" << \n\t\t\tC3.real << \" + i\" << \n\t\t\tC3.imaginary;\n}\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\nFew_shot_example_1:\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        dont_initialize();\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n\nFew_shot_example_2:\n#include <systemc.h>\n\n\/\/ Module: BubbleSort\n\/\/ Sorts a small fixed-size array of integers using the bubble sort algorithm.\nSC_MODULE(BubbleSort) {\n    sc_in<bool>  clk;      \/\/ Clock signal\n    sc_in<bool>  start;    \/\/ Start signal to begin sorting\n    sc_out<bool> done;     \/\/ Signal asserted when sorting is complete\n\n    sc_in<int>   in_arr[4];  \/\/ Input array of 4 integers to be sorted\n    sc_out<int>  out_arr[4]; \/\/ Output array of 4 sorted integers\n\n    int buf[4];  \/\/ Internal buffer to hold array elements during sorting\n\n    \/\/ Constructor: registers the sorting process with the clock\n    SC_CTOR(BubbleSort) {\n        SC_THREAD(sort_proc);\n        sensitive << clk.pos();\n    }\n\n    \/\/ Thread: waits for start, performs bubble sort, writes results, toggles done\n    void sort_proc() {\n        const int N = 4;\n        while (true) {\n            wait();  \/\/ wait for next clock edge\n            if (start.read()) {\n                \/\/ Read inputs into internal buffer\n                for (int i = 0; i < N; ++i)\n                    buf[i] = in_arr[i].read();\n\n                \/\/ Perform bubble sort on buffer[]\n                for (int i = 0; i < N - 1; ++i)\n                    for (int j = 0; j < N - i - 1; ++j)\n                        if (buf[j] > buf[j + 1])\n                            std::swap(buf[j], buf[j + 1]);\n\n                \/\/ Write sorted results to output ports\n                for (int i = 0; i < N; ++i)\n                    out_arr[i].write(buf[i]);\n\n                \/\/ Signal done for one cycle\n                done.write(true);\n                wait();\n                done.write(false);\n            }\n        }\n    }\n};\n\nFew_shot_example_3:\n#include <systemc.h>\n\n\/\/ Module: MatrixAdder\n\/\/ Adds two 4×4 matrices of integers element-wise.\nSC_MODULE(MatrixAdder) {\n    sc_in<int> A[4*4];   \/\/ Flattened 4×4 input matrix A (16 elements)\n    sc_in<int> B[4*4];   \/\/ Flattened 4×4 input matrix B (16 elements)\n    sc_out<int> C[4*4];  \/\/ Flattened 4×4 output matrix C = A + B\n\n    \/\/ Constructor: registers a combinational add method sensitive to all inputs\n    SC_CTOR(MatrixAdder) {\n        SC_METHOD(do_add);\n        \/\/ Make the add method sensitive to every element of A and B\n        for (int i = 0; i < 4*4; i++) {\n            sensitive << A[i] << B[i];\n        }\n    }\n\n    \/\/ Method: reads A[i] and B[i], writes sum into C[i] for all 16 positions\n    void do_add() {\n        for (int i = 0; i < 4*4; i++) {\n            C[i].write(A[i].read() + B[i].read());\n        }\n    }\n};\n\n\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":3,
        "task":"AddTwoMatrices",
        "code":"\/\/ C++ program for addition of two matrices\n#include <bits\/stdc++.h>\nusing namespace std;\n#define N 4\n\n\/\/ This function adds A[][] and B[][],\n\/\/ and stores the result in C[][]\nvoid add(int A[][N], int B[][N], int C[][N])\n{\n    int i, j;\n    for (i = 0; i < N; i++)\n        for (j = 0; j < N; j++)\n            C[i][j] = A[i][j] + B[i][j];\n}\n\n\/\/ Driver code\nint main()\n{\n    int A[N][N] = { { 1, 1, 1, 1 },\n                    { 2, 2, 2, 2 },\n                    { 3, 3, 3, 3 },\n                    { 4, 4, 4, 4 } };\n\n    int B[N][N] = { { 1, 1, 1, 1 },\n                    { 2, 2, 2, 2 },\n                    { 3, 3, 3, 3 },\n                    { 4, 4, 4, 4 } };\n\n    \/\/ To store the result\n    int C[N][N];\n    int i, j;\n    add(A, B, C);\n\n    cout << \"Result matrix is \" << endl;\n    for (i = 0; i < N; i++) {\n        for (j = 0; j < N; j++)\n            cout << C[i][j] << \" \";\n        cout << endl;\n    }\n\n    return 0;\n}\n",
        "category":"Matrix Operation",
        "adoption":false,
        "reason":null,
        "module_name":"MatrixAdder",
        "testbench":"SC_MODULE(Testbench) {\n\n    \/\/ Signals to connect to the MatrixAdder ports\n    sc_signal<int> A[4*4];\n    sc_signal<int> B[4*4];\n    sc_signal<int> C[4*4];\n\n    MatrixAdder* matrixAdder;\n\n    SC_CTOR(Testbench) {\n        \/\/ Instantiate the MatrixAdder module\n        matrixAdder = new MatrixAdder(\"matrixAdder\");\n        \/\/ Connect signals to the module's ports\n        for (int i = 0; i < 4*4; i++) {\n            matrixAdder->A[i](A[i]);\n            matrixAdder->B[i](B[i]);\n            matrixAdder->C[i](C[i]);\n        }\n        \/\/ Create a thread to run the test cases\n        SC_THREAD(run_tests);\n    }\n\n    \/\/ Thread that initializes inputs, checks outputs, and asserts correctness\n    void run_tests() {\n        \/\/ Initialize matrices A and B as defined in the original C++ code:\n        \/\/ Matrix A:\n        \/\/   { 1, 1, 1, 1 },\n        \/\/   { 2, 2, 2, 2 },\n        \/\/   { 3, 3, 3, 3 },\n        \/\/   { 4, 4, 4, 4 }\n        \/\/ Matrix B: identical to Matrix A.\n        for (int row = 0; row < 4; row++) {\n            for (int col = 0; col < 4; col++) {\n                int index = row * 4 + col;\n                A[index].write(row + 1); \/\/ row 0 => 1, row 1 => 2, etc.\n                B[index].write(row + 1);\n            }\n        }\n\n        \/\/ Wait for the signals to propagate and the combinational logic to settle.\n        wait(1, SC_NS);\n\n        \/\/ Check the result matrix C and print the output\n        std::cout << \"Result matrix is:\" << std::endl;\n        for (int row = 0; row < 4; row++) {\n            for (int col = 0; col < 4; col++) {\n                int index = row * 4 + col;\n                int expected = (row + 1) + (row + 1); \/\/ Since both matrices have the same values.\n                int result = C[index].read();\n                \/\/ Use assert to validate the result.\n                assert(result == expected);\n                std::cout << result << \" \";\n            }\n            std::cout << std::endl;\n        }\n        std::cout << \"All tests passed successfully.\" << std::endl;\n\n        sc_stop(); \/\/ Stop the simulation\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); \/\/ Create an instance of the Testbench\n    sc_start();         \/\/ Start the simulation\n    return 0;\n}\n",
        "signal":"sc_in<int> A[4*4];\nsc_in<int> B[4*4];\nsc_out<int> C[4*4];",
        "prompt":null
    },
    {
        "task_id":4,
        "task":"AddTwoNumbers",
        "code":"\/\/ C++ program to add two number using addition operator\n#include <bits\/stdc++.h>\nusing namespace std;\n\nint main() {\n    int a = 11, b = 9;\n\n    \/\/ Adding the two numbers and printing\n    \/\/ their sum\n    cout << a + b;\n    return 0;\n}\n",
        "category":"Basic Math",
        "adoption":false,
        "reason":null,
        "module_name":"Adder",
        "testbench":"SC_MODULE(Testbench) {\n    sc_signal<int> a; \/\/ Signal for the first number\n    sc_signal<int> b; \/\/ Signal for the second number\n    sc_signal<int> sum; \/\/ Signal for the sum\n\n    Adder adder_inst; \/\/ Instance of the Adder module\n\n    \/\/ Constructor\n    SC_CTOR(Testbench) : adder_inst(\"adder\") {\n        \/\/ Connect signals to ports\n        adder_inst.a(a);\n        adder_inst.b(b);\n        adder_inst.sum(sum);\n\n        \/\/ Process to run tests\n        SC_THREAD(run_tests);\n    }\n\n    \/\/ Thread to run test cases\n    void run_tests() {\n        \/\/ Test case 1: Simple addition\n        a = 11; b = 9;\n        wait(1, SC_NS); \/\/ Wait for the adder to process\n        assert(sum.read() == 20);\n        cout << \"Sum: \" << sum.read() << endl;\n\n        \/\/ Additional test case: One operand is zero\n        a = 0; b = 5;\n        wait(1, SC_NS);\n        assert(sum.read() == 5);\n        cout << \"Sum: \" << sum.read() << endl;\n\n        \/\/ Additional test case: Both operands are zero\n        a = 0; b = 0;\n        wait(1, SC_NS);\n        assert(sum.read() == 0);\n        cout << \"Sum: \" << sum.read() << endl;\n\n        \/\/ Print success message\n        cout << \"All tests passed successfully.\" << endl;\n\n        sc_stop(); \/\/ Stop the simulation\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); \/\/ Create an instance of the Testbench\n\n    \/\/ Start the simulation\n    sc_start();\n\n    return 0;\n}\n",
        "signal":"sc_in<int> a;\nsc_in<int> b;\nsc_out<int> sum;",
        "prompt":null
    },
    {
        "task_id":5,
        "task":"AreaAndPerimeterofRectangle",
        "code":"\/\/ C++ program to find area\n\/\/ and perimeter of rectangle\n#include<iostream>\nusing namespace std;\n\n\/\/ Utility function\nint areaRectangle(int a, int b)\n{\nint area = a * b;\nreturn area;\n}\n\nint perimeterRectangle(int a, int b)\n{\nint perimeter = 2*(a + b);\nreturn perimeter;\n}\n\n\/\/ Driver code\nint main()\n{\nint a = 5;\nint b = 6;\ncout << \"Area = \" << \n\t\tareaRectangle(a, b) << \n\t\tendl;\ncout << \"Perimeter = \" << \n\t\tperimeterRectangle(a, b);\nreturn 0;\n} \n",
        "category":"Basic Math",
        "adoption":true,
        "reason":null,
        "module_name":"RectangleCalculator",
        "testbench":"SC_MODULE(Testbench) {\n    sc_signal<int> length_sig;\n    sc_signal<int> width_sig;\n    sc_signal<int> area_sig;\n    sc_signal<int> perimeter_sig;\n\n    RectangleCalculator rc_inst;\n\n    SC_CTOR(Testbench) : rc_inst(\"rc_inst\") {\n        rc_inst.length(length_sig);\n        rc_inst.width(width_sig);\n        rc_inst.area(area_sig);\n        rc_inst.perimeter(perimeter_sig);\n\n        SC_THREAD(run_tests);\n    }\n\n    void run_tests() {\n        \/\/ Test case: length = 5, width = 6\n        length_sig = 5;\n        width_sig = 6;\n        wait(1, SC_NS);\n        cout << \"Area: \" << area_sig.read() << endl;\n        cout << \"Perimeter: \" << perimeter_sig.read() << endl;\n\n        \/\/ Optional: add assertions\n        assert(area_sig.read() == 30);\n        assert(perimeter_sig.read() == 22);\n\n        cout << \"Test passed successfully.\" << endl;\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\");\n    sc_start();\n    return 0;\n}\n",
        "signal":"sc_in<int> length;\nsc_in<int> width;\nsc_out<int> area;\nsc_out<int> perimeter;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input.\n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<int> length;\nsc_in<int> width;\nsc_out<int> area;\nsc_out<int> perimeter;\n> **Note**:\n   - Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n   - If the static const are provided, insure to write them in the SystemC code as well.\n\n**C++\/C Code**:\n```\n\/\/ C++ program to find area\n\/\/ and perimeter of rectangle\n#include<iostream>\nusing namespace std;\n\n\/\/ Utility function\nint areaRectangle(int a, int b)\n{\nint area = a * b;\nreturn area;\n}\n\nint perimeterRectangle(int a, int b)\n{\nint perimeter = 2*(a + b);\nreturn perimeter;\n}\n\n\/\/ Driver code\nint main()\n{\nint a = 5;\nint b = 6;\ncout << \"Area = \" << \n\t\tareaRectangle(a, b) << \n\t\tendl;\ncout << \"Perimeter = \" << \n\t\tperimeterRectangle(a, b);\nreturn 0;\n} \n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\nFew_shot_example_1:\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        dont_initialize();\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n\nFew_shot_example_2:\n#include <systemc.h>\n\n\/\/ Module: BubbleSort\n\/\/ Sorts a small fixed-size array of integers using the bubble sort algorithm.\nSC_MODULE(BubbleSort) {\n    sc_in<bool>  clk;      \/\/ Clock signal\n    sc_in<bool>  start;    \/\/ Start signal to begin sorting\n    sc_out<bool> done;     \/\/ Signal asserted when sorting is complete\n\n    sc_in<int>   in_arr[4];  \/\/ Input array of 4 integers to be sorted\n    sc_out<int>  out_arr[4]; \/\/ Output array of 4 sorted integers\n\n    int buf[4];  \/\/ Internal buffer to hold array elements during sorting\n\n    \/\/ Constructor: registers the sorting process with the clock\n    SC_CTOR(BubbleSort) {\n        SC_THREAD(sort_proc);\n        sensitive << clk.pos();\n    }\n\n    \/\/ Thread: waits for start, performs bubble sort, writes results, toggles done\n    void sort_proc() {\n        const int N = 4;\n        while (true) {\n            wait();  \/\/ wait for next clock edge\n            if (start.read()) {\n                \/\/ Read inputs into internal buffer\n                for (int i = 0; i < N; ++i)\n                    buf[i] = in_arr[i].read();\n\n                \/\/ Perform bubble sort on buffer[]\n                for (int i = 0; i < N - 1; ++i)\n                    for (int j = 0; j < N - i - 1; ++j)\n                        if (buf[j] > buf[j + 1])\n                            std::swap(buf[j], buf[j + 1]);\n\n                \/\/ Write sorted results to output ports\n                for (int i = 0; i < N; ++i)\n                    out_arr[i].write(buf[i]);\n\n                \/\/ Signal done for one cycle\n                done.write(true);\n                wait();\n                done.write(false);\n            }\n        }\n    }\n};\n\nFew_shot_example_3:\n#include <systemc.h>\n\n\/\/ Module: MatrixAdder\n\/\/ Adds two 4×4 matrices of integers element-wise.\nSC_MODULE(MatrixAdder) {\n    sc_in<int> A[4*4];   \/\/ Flattened 4×4 input matrix A (16 elements)\n    sc_in<int> B[4*4];   \/\/ Flattened 4×4 input matrix B (16 elements)\n    sc_out<int> C[4*4];  \/\/ Flattened 4×4 output matrix C = A + B\n\n    \/\/ Constructor: registers a combinational add method sensitive to all inputs\n    SC_CTOR(MatrixAdder) {\n        SC_METHOD(do_add);\n        \/\/ Make the add method sensitive to every element of A and B\n        for (int i = 0; i < 4*4; i++) {\n            sensitive << A[i] << B[i];\n        }\n    }\n\n    \/\/ Method: reads A[i] and B[i], writes sum into C[i] for all 16 positions\n    void do_add() {\n        for (int i = 0; i < 4*4; i++) {\n            C[i].write(A[i].read() + B[i].read());\n        }\n    }\n};\n\n\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":6,
        "task":"ArrayRotation",
        "code":"#include <bits\/stdc++.h>\nusing namespace std;\n\n\/\/ Function to rotate array\nvoid Rotate(int arr[], int d, int n)\n{\n\t\/\/ Storing rotated version of array\n\tint temp[n];\n\n\t\/\/ Keeping track of the current index\n\t\/\/ of temp[]\n\tint k = 0;\n\n\t\/\/ Storing the n - d elements of\n\t\/\/ array arr[] to the front of temp[]\n\tfor (int i = d; i < n; i++) {\n\t\ttemp[k] = arr[i];\n\t\tk++;\n\t}\n\n\t\/\/ Storing the first d elements of array arr[]\n\t\/\/ into temp\n\tfor (int i = 0; i < d; i++) {\n\t\ttemp[k] = arr[i];\n\t\tk++;\n\t}\n\n\t\/\/ Copying the elements of temp[] in arr[]\n\t\/\/ to get the final rotated array\n\tfor (int i = 0; i < n; i++) {\n\t\tarr[i] = temp[i];\n\t}\n}\n\n\/\/ Function to print elements of array\nvoid PrintTheArray(int arr[], int n)\n{\n\tfor (int i = 0; i < n; i++) {\n\t\tcout << arr[i] << \" \";\n\t}\n}\n\n\/\/ Driver code\nint main()\n{\n\tint arr[] = { 1, 2, 3, 4, 5, 6, 7 };\n\tint N = sizeof(arr) \/ sizeof(arr[0]);\n\tint d = 2;\n\n\t\/\/ Function calling\n\tRotate(arr, d, N);\n\tPrintTheArray(arr, N);\n\n\treturn 0;\n}\n",
        "category":"Array Operation",
        "adoption":true,
        "reason":null,
        "module_name":"Rotator",
        "testbench":"SC_MODULE(Testbench) {\n    sc_signal<bool> clk;\n    sc_signal<bool> rst;\n    sc_signal<int> d;\n    sc_signal<int> in_array[7];\n    sc_signal<int> out_array[7];\n\n    Rotator* rotator_inst;\n\n    \/\/ Clock generator process\n    void generate_clock() {\n        while (true) {\n            clk.write(false);\n            wait(5, SC_NS);\n            clk.write(true);\n            wait(5, SC_NS);\n        }\n    }\n\n    \/\/ Process to run tests\n    void run_tests() {\n        \/\/ Activate reset for one clock cycle\n        rst.write(true);\n        wait(10, SC_NS);\n        rst.write(false);\n\n        \/\/ Provide the input array and rotation offset (d = 2)\n        int input[7] = { 1, 2, 3, 4, 5, 6, 7 };\n        for (int i = 0; i < 7; i++) {\n            in_array[i].write(input[i]);\n        }\n        d.write(2);\n\n        \/\/ Wait for the rotator to process the new values.\n        wait(10, SC_NS);\n\n        \/\/ Expected output after rotation: {3, 4, 5, 6, 7, 1, 2}\n        int expected[7] = { 3, 4, 5, 6, 7, 1, 2 };\n        std::cout << \"Rotated Array: \";\n        for (int i = 0; i < 7; i++) {\n            int out_val = out_array[i].read();\n            \/\/ Assert that the output is as expected.\n            assert(out_val == expected[i]);\n            std::cout << out_val << \" \";\n        }\n        std::cout << \"All tests passed successfully.\" << std::endl;\n\n        sc_stop(); \/\/ End simulation.\n    }\n\n    SC_CTOR(Testbench) {\n        rotator_inst = new Rotator(\"Rotator\");\n        \/\/ Connect testbench signals to Rotator ports.\n        rotator_inst->clk(clk);\n        rotator_inst->rst(rst);\n        rotator_inst->d(d);\n        for (int i = 0; i < 7; i++) {\n            rotator_inst->in_array[i](in_array[i]);\n            rotator_inst->out_array[i](out_array[i]);\n        }\n        SC_THREAD(run_tests);\n        SC_THREAD(generate_clock);\n    }\n\n    ~Testbench() {\n        delete rotator_inst;\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\");\n    sc_start();\n    return 0;\n}\n",
        "signal":"sc_in<bool> clk;\nsc_in<bool> rst;\nsc_in<int> d;\nsc_in<int> in_array[7];\nsc_out<int> out_array[7];",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input.\n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<bool> clk;\nsc_in<bool> rst;\nsc_in<int> d;\nsc_in<int> in_array[7];\nsc_out<int> out_array[7];\n> **Note**:\n   - Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n   - If the static const are provided, insure to write them in the SystemC code as well.\n\n**C++\/C Code**:\n```\n#include <bits\/stdc++.h>\nusing namespace std;\n\n\/\/ Function to rotate array\nvoid Rotate(int arr[], int d, int n)\n{\n\t\/\/ Storing rotated version of array\n\tint temp[n];\n\n\t\/\/ Keeping track of the current index\n\t\/\/ of temp[]\n\tint k = 0;\n\n\t\/\/ Storing the n - d elements of\n\t\/\/ array arr[] to the front of temp[]\n\tfor (int i = d; i < n; i++) {\n\t\ttemp[k] = arr[i];\n\t\tk++;\n\t}\n\n\t\/\/ Storing the first d elements of array arr[]\n\t\/\/ into temp\n\tfor (int i = 0; i < d; i++) {\n\t\ttemp[k] = arr[i];\n\t\tk++;\n\t}\n\n\t\/\/ Copying the elements of temp[] in arr[]\n\t\/\/ to get the final rotated array\n\tfor (int i = 0; i < n; i++) {\n\t\tarr[i] = temp[i];\n\t}\n}\n\n\/\/ Function to print elements of array\nvoid PrintTheArray(int arr[], int n)\n{\n\tfor (int i = 0; i < n; i++) {\n\t\tcout << arr[i] << \" \";\n\t}\n}\n\n\/\/ Driver code\nint main()\n{\n\tint arr[] = { 1, 2, 3, 4, 5, 6, 7 };\n\tint N = sizeof(arr) \/ sizeof(arr[0]);\n\tint d = 2;\n\n\t\/\/ Function calling\n\tRotate(arr, d, N);\n\tPrintTheArray(arr, N);\n\n\treturn 0;\n}\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\nFew_shot_example_1:\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        dont_initialize();\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n\nFew_shot_example_2:\n#include <systemc.h>\n\n\/\/ Module: BubbleSort\n\/\/ Sorts a small fixed-size array of integers using the bubble sort algorithm.\nSC_MODULE(BubbleSort) {\n    sc_in<bool>  clk;      \/\/ Clock signal\n    sc_in<bool>  start;    \/\/ Start signal to begin sorting\n    sc_out<bool> done;     \/\/ Signal asserted when sorting is complete\n\n    sc_in<int>   in_arr[4];  \/\/ Input array of 4 integers to be sorted\n    sc_out<int>  out_arr[4]; \/\/ Output array of 4 sorted integers\n\n    int buf[4];  \/\/ Internal buffer to hold array elements during sorting\n\n    \/\/ Constructor: registers the sorting process with the clock\n    SC_CTOR(BubbleSort) {\n        SC_THREAD(sort_proc);\n        sensitive << clk.pos();\n    }\n\n    \/\/ Thread: waits for start, performs bubble sort, writes results, toggles done\n    void sort_proc() {\n        const int N = 4;\n        while (true) {\n            wait();  \/\/ wait for next clock edge\n            if (start.read()) {\n                \/\/ Read inputs into internal buffer\n                for (int i = 0; i < N; ++i)\n                    buf[i] = in_arr[i].read();\n\n                \/\/ Perform bubble sort on buffer[]\n                for (int i = 0; i < N - 1; ++i)\n                    for (int j = 0; j < N - i - 1; ++j)\n                        if (buf[j] > buf[j + 1])\n                            std::swap(buf[j], buf[j + 1]);\n\n                \/\/ Write sorted results to output ports\n                for (int i = 0; i < N; ++i)\n                    out_arr[i].write(buf[i]);\n\n                \/\/ Signal done for one cycle\n                done.write(true);\n                wait();\n                done.write(false);\n            }\n        }\n    }\n};\n\nFew_shot_example_3:\n#include <systemc.h>\n\n\/\/ Module: MatrixAdder\n\/\/ Adds two 4×4 matrices of integers element-wise.\nSC_MODULE(MatrixAdder) {\n    sc_in<int> A[4*4];   \/\/ Flattened 4×4 input matrix A (16 elements)\n    sc_in<int> B[4*4];   \/\/ Flattened 4×4 input matrix B (16 elements)\n    sc_out<int> C[4*4];  \/\/ Flattened 4×4 output matrix C = A + B\n\n    \/\/ Constructor: registers a combinational add method sensitive to all inputs\n    SC_CTOR(MatrixAdder) {\n        SC_METHOD(do_add);\n        \/\/ Make the add method sensitive to every element of A and B\n        for (int i = 0; i < 4*4; i++) {\n            sensitive << A[i] << B[i];\n        }\n    }\n\n    \/\/ Method: reads A[i] and B[i], writes sum into C[i] for all 16 positions\n    void do_add() {\n        for (int i = 0; i < 4*4; i++) {\n            C[i].write(A[i].read() + B[i].read());\n        }\n    }\n};\n\n\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":7,
        "task":"BinarytoDecimalConversion",
        "code":"\/\/ C++ program to convert binary to decimal \n#include <iostream> \nusing namespace std; \n\n\/\/ Function to convert binary \n\/\/ to decimal \nint binaryToDecimal(int n) \n{ \n\tint num = n; \n\tint dec_value = 0; \n\n\t\/\/ Initializing base value to \n\t\/\/ 1, i.e 2^0 \n\tint base = 1; \n\n\tint temp = num; \n\twhile (temp) { \n\t\tint last_digit = temp % 10; \n\t\ttemp = temp \/ 10; \n\t\tdec_value += last_digit * base; \n\t\tbase = base * 2; \n\t} \n\n\treturn dec_value; \n} \n\n\/\/ Driver code \nint main() \n{ \n\tint num = 10101001; \n\tcout << binaryToDecimal(num) << endl; \n}\n",
        "category":"Basic Math",
        "adoption":true,
        "reason":null,
        "module_name":"BinaryToDecimalConverter",
        "testbench":"SC_MODULE(Testbench) {\n    sc_signal<int> binary_sig; \/\/ Signal for the binary number\n    sc_signal<int> decimal_sig; \/\/ Signal for the decimal number\n\n    BinaryToDecimalConverter converter_inst; \/\/ Instance of the converter module\n\n    \/\/ Constructor\n    SC_CTOR(Testbench) : converter_inst(\"converter\") {\n        \/\/ Connect signals to ports\n        converter_inst.binary_in(binary_sig);\n        converter_inst.decimal_out(decimal_sig);\n\n        \/\/ Process to run tests\n        SC_THREAD(run_tests);\n    }\n\n    \/\/ Thread to run test cases\n    void run_tests() {\n        \/\/ Test case 1: Convert binary 10101001 to decimal\n        binary_sig = 10101001;\n        wait(1, SC_NS); \/\/ Wait for the conversion to process\n        int result = decimal_sig.read();\n        cout << \"Binary: 10101001 -> Decimal: \" << result << endl;\n        assert(result == 169);\n\n        \/\/ Test case 2: Convert binary 1111 to decimal\n        binary_sig = 1111;\n        wait(1, SC_NS);\n        result = decimal_sig.read();\n        cout << \"Binary: 1111 -> Decimal: \" << result << endl;\n        assert(result == 15);\n\n        \/\/ Test case 3: Convert binary 100000 to decimal\n        binary_sig = 100000;\n        wait(1, SC_NS);\n        result = decimal_sig.read();\n        cout << \"Binary: 100000 -> Decimal: \" << result << endl;\n        assert(result == 32);\n\n        \/\/ Print success message\n        cout << \"All tests passed successfully.\" << endl;\n\n        sc_stop(); \/\/ Stop the simulation\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); \/\/ Create an instance of the Testbench\n\n    \/\/ Start the simulation\n    sc_start();\n\n    return 0;\n}\n",
        "signal":"sc_in<int> binary_in;\nsc_out<int> decimal_out;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input.\n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<int> binary_in;\nsc_out<int> decimal_out;\n> **Note**:\n   - Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n   - If the static const are provided, insure to write them in the SystemC code as well.\n\n**C++\/C Code**:\n```\n\/\/ C++ program to convert binary to decimal \n#include <iostream> \nusing namespace std; \n\n\/\/ Function to convert binary \n\/\/ to decimal \nint binaryToDecimal(int n) \n{ \n\tint num = n; \n\tint dec_value = 0; \n\n\t\/\/ Initializing base value to \n\t\/\/ 1, i.e 2^0 \n\tint base = 1; \n\n\tint temp = num; \n\twhile (temp) { \n\t\tint last_digit = temp % 10; \n\t\ttemp = temp \/ 10; \n\t\tdec_value += last_digit * base; \n\t\tbase = base * 2; \n\t} \n\n\treturn dec_value; \n} \n\n\/\/ Driver code \nint main() \n{ \n\tint num = 10101001; \n\tcout << binaryToDecimal(num) << endl; \n}\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\nFew_shot_example_1:\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        dont_initialize();\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n\nFew_shot_example_2:\n#include <systemc.h>\n\n\/\/ Module: BubbleSort\n\/\/ Sorts a small fixed-size array of integers using the bubble sort algorithm.\nSC_MODULE(BubbleSort) {\n    sc_in<bool>  clk;      \/\/ Clock signal\n    sc_in<bool>  start;    \/\/ Start signal to begin sorting\n    sc_out<bool> done;     \/\/ Signal asserted when sorting is complete\n\n    sc_in<int>   in_arr[4];  \/\/ Input array of 4 integers to be sorted\n    sc_out<int>  out_arr[4]; \/\/ Output array of 4 sorted integers\n\n    int buf[4];  \/\/ Internal buffer to hold array elements during sorting\n\n    \/\/ Constructor: registers the sorting process with the clock\n    SC_CTOR(BubbleSort) {\n        SC_THREAD(sort_proc);\n        sensitive << clk.pos();\n    }\n\n    \/\/ Thread: waits for start, performs bubble sort, writes results, toggles done\n    void sort_proc() {\n        const int N = 4;\n        while (true) {\n            wait();  \/\/ wait for next clock edge\n            if (start.read()) {\n                \/\/ Read inputs into internal buffer\n                for (int i = 0; i < N; ++i)\n                    buf[i] = in_arr[i].read();\n\n                \/\/ Perform bubble sort on buffer[]\n                for (int i = 0; i < N - 1; ++i)\n                    for (int j = 0; j < N - i - 1; ++j)\n                        if (buf[j] > buf[j + 1])\n                            std::swap(buf[j], buf[j + 1]);\n\n                \/\/ Write sorted results to output ports\n                for (int i = 0; i < N; ++i)\n                    out_arr[i].write(buf[i]);\n\n                \/\/ Signal done for one cycle\n                done.write(true);\n                wait();\n                done.write(false);\n            }\n        }\n    }\n};\n\nFew_shot_example_3:\n#include <systemc.h>\n\n\/\/ Module: MatrixAdder\n\/\/ Adds two 4×4 matrices of integers element-wise.\nSC_MODULE(MatrixAdder) {\n    sc_in<int> A[4*4];   \/\/ Flattened 4×4 input matrix A (16 elements)\n    sc_in<int> B[4*4];   \/\/ Flattened 4×4 input matrix B (16 elements)\n    sc_out<int> C[4*4];  \/\/ Flattened 4×4 output matrix C = A + B\n\n    \/\/ Constructor: registers a combinational add method sensitive to all inputs\n    SC_CTOR(MatrixAdder) {\n        SC_METHOD(do_add);\n        \/\/ Make the add method sensitive to every element of A and B\n        for (int i = 0; i < 4*4; i++) {\n            sensitive << A[i] << B[i];\n        }\n    }\n\n    \/\/ Method: reads A[i] and B[i], writes sum into C[i] for all 16 positions\n    void do_add() {\n        for (int i = 0; i < 4*4; i++) {\n            C[i].write(A[i].read() + B[i].read());\n        }\n    }\n};\n\n\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":8,
        "task":"BinarytoOctalConversion",
        "code":"\/\/ C++ program to convert octal to decimal\n#include <iostream>\nusing namespace std;\n\n\/\/ Function to convert octal \n\/\/ to decimal\nint octalToDecimal(int n)\n{\n\tint num = n;\n\tint dec_value = 0;\n\n\t\/\/ Initializing base value to 1, \n\t\/\/ i.e 8^0\n\tint base = 1;\n\n\tint temp = num;\n\twhile (temp) \n\t{\n\t\t\/\/ Extracting last digit\n\t\tint last_digit = temp % 10;\n\t\ttemp = temp \/ 10;\n\n\t\t\/\/ Multiplying last digit with \n\t\t\/\/ appropriate base value and adding \n\t\t\/\/ it to dec_value\n\t\tdec_value += last_digit * base;\n\n\t\tbase = base * 8;\n\t}\n\n\treturn dec_value;\n}\n\n\/\/ Driver code\nint main()\n{\n\tint num = 67;\n\n\tcout << octalToDecimal(num) << endl;\n}\n",
        "category":"Basic Math",
        "adoption":true,
        "reason":null,
        "module_name":"OctalToDecimalConverter",
        "testbench":"SC_MODULE(Testbench) {\n    sc_signal<int> octal_input; \/\/ Signal for the octal number\n    sc_signal<int> decimal_output; \/\/ Signal for the decimal number\n\n    OctalToDecimalConverter converter_inst; \/\/ Instance of the converter module\n\n    \/\/ Constructor\n    SC_CTOR(Testbench) : converter_inst(\"converter\") {\n        \/\/ Connect signals to ports\n        converter_inst.octal_input(octal_input);\n        converter_inst.decimal_output(decimal_output);\n\n        \/\/ Process to run tests\n        SC_THREAD(run_tests);\n    }\n\n    \/\/ Thread to run test cases\n    void run_tests() {\n        \/\/ Test case 1: Octal 67\n        octal_input = 67;\n        wait(1, SC_NS); \/\/ Wait for the converter to process\n        assert(decimal_output.read() == 55);\n        cout << \"Octal 67 -> Decimal \" << decimal_output.read() << endl;\n\n        \/\/ Test case 2: Octal 123\n        octal_input = 123;\n        wait(1, SC_NS);\n        assert(decimal_output.read() == 83);\n        cout << \"Octal 123 -> Decimal \" << decimal_output.read() << endl;\n\n        \/\/ Test case 3: Octal 0\n        octal_input = 0;\n        wait(1, SC_NS);\n        assert(decimal_output.read() == 0);\n        cout << \"Octal 0 -> Decimal \" << decimal_output.read() << endl;\n\n        \/\/ Test case 4: Octal 10\n        octal_input = 10;\n        wait(1, SC_NS);\n        assert(decimal_output.read() == 8);\n        cout << \"Octal 10 -> Decimal \" << decimal_output.read() << endl;\n\n        \/\/ Print success message\n        cout << \"All tests passed successfully.\" << endl;\n\n        sc_stop(); \/\/ Stop the simulation\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); \/\/ Create an instance of the Testbench\n\n    \/\/ Start the simulation\n    sc_start();\n\n    return 0;\n}\n",
        "signal":"sc_in<int> octal_input;\nsc_out<int> decimal_output;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input.\n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<int> octal_input;\nsc_out<int> decimal_output;\n> **Note**:\n   - Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n   - If the static const are provided, insure to write them in the SystemC code as well.\n\n**C++\/C Code**:\n```\n\/\/ C++ program to convert octal to decimal\n#include <iostream>\nusing namespace std;\n\n\/\/ Function to convert octal \n\/\/ to decimal\nint octalToDecimal(int n)\n{\n\tint num = n;\n\tint dec_value = 0;\n\n\t\/\/ Initializing base value to 1, \n\t\/\/ i.e 8^0\n\tint base = 1;\n\n\tint temp = num;\n\twhile (temp) \n\t{\n\t\t\/\/ Extracting last digit\n\t\tint last_digit = temp % 10;\n\t\ttemp = temp \/ 10;\n\n\t\t\/\/ Multiplying last digit with \n\t\t\/\/ appropriate base value and adding \n\t\t\/\/ it to dec_value\n\t\tdec_value += last_digit * base;\n\n\t\tbase = base * 8;\n\t}\n\n\treturn dec_value;\n}\n\n\/\/ Driver code\nint main()\n{\n\tint num = 67;\n\n\tcout << octalToDecimal(num) << endl;\n}\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\nFew_shot_example_1:\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        dont_initialize();\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n\nFew_shot_example_2:\n#include <systemc.h>\n\n\/\/ Module: BubbleSort\n\/\/ Sorts a small fixed-size array of integers using the bubble sort algorithm.\nSC_MODULE(BubbleSort) {\n    sc_in<bool>  clk;      \/\/ Clock signal\n    sc_in<bool>  start;    \/\/ Start signal to begin sorting\n    sc_out<bool> done;     \/\/ Signal asserted when sorting is complete\n\n    sc_in<int>   in_arr[4];  \/\/ Input array of 4 integers to be sorted\n    sc_out<int>  out_arr[4]; \/\/ Output array of 4 sorted integers\n\n    int buf[4];  \/\/ Internal buffer to hold array elements during sorting\n\n    \/\/ Constructor: registers the sorting process with the clock\n    SC_CTOR(BubbleSort) {\n        SC_THREAD(sort_proc);\n        sensitive << clk.pos();\n    }\n\n    \/\/ Thread: waits for start, performs bubble sort, writes results, toggles done\n    void sort_proc() {\n        const int N = 4;\n        while (true) {\n            wait();  \/\/ wait for next clock edge\n            if (start.read()) {\n                \/\/ Read inputs into internal buffer\n                for (int i = 0; i < N; ++i)\n                    buf[i] = in_arr[i].read();\n\n                \/\/ Perform bubble sort on buffer[]\n                for (int i = 0; i < N - 1; ++i)\n                    for (int j = 0; j < N - i - 1; ++j)\n                        if (buf[j] > buf[j + 1])\n                            std::swap(buf[j], buf[j + 1]);\n\n                \/\/ Write sorted results to output ports\n                for (int i = 0; i < N; ++i)\n                    out_arr[i].write(buf[i]);\n\n                \/\/ Signal done for one cycle\n                done.write(true);\n                wait();\n                done.write(false);\n            }\n        }\n    }\n};\n\nFew_shot_example_3:\n#include <systemc.h>\n\n\/\/ Module: MatrixAdder\n\/\/ Adds two 4×4 matrices of integers element-wise.\nSC_MODULE(MatrixAdder) {\n    sc_in<int> A[4*4];   \/\/ Flattened 4×4 input matrix A (16 elements)\n    sc_in<int> B[4*4];   \/\/ Flattened 4×4 input matrix B (16 elements)\n    sc_out<int> C[4*4];  \/\/ Flattened 4×4 output matrix C = A + B\n\n    \/\/ Constructor: registers a combinational add method sensitive to all inputs\n    SC_CTOR(MatrixAdder) {\n        SC_METHOD(do_add);\n        \/\/ Make the add method sensitive to every element of A and B\n        for (int i = 0; i < 4*4; i++) {\n            sensitive << A[i] << B[i];\n        }\n    }\n\n    \/\/ Method: reads A[i] and B[i], writes sum into C[i] for all 16 positions\n    void do_add() {\n        for (int i = 0; i < 4*4; i++) {\n            C[i].write(A[i].read() + B[i].read());\n        }\n    }\n};\n\n\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":9,
        "task":"CalculateFahrenheittoCelsius",
        "code":"\/\/ C++ program to convert Fahrenheit scale to Celsius scale\n#include <bits\/stdc++.h>\nusing namespace std;\n\n\/\/ Function to convert Fahrenheit \n\/\/ to Celsius\nfloat Conversion(float n)\n{\n\treturn (n - 32.0) * 5.0 \/ 9.0;\n}\n\n\/\/ Driver code\nint main()\n{\n\tfloat n = 40;\n\tcout << Conversion(n);\n\treturn 0;\n}\n",
        "category":"Basic Math",
        "adoption":true,
        "reason":null,
        "module_name":"TempConverter",
        "testbench":"SC_MODULE(Testbench) {\n    sc_signal<float> fahrenheit; \/\/ Signal for Fahrenheit temperature\n    sc_signal<float> celsius;    \/\/ Signal for Celsius temperature\n\n    TempConverter converter_inst; \/\/ Instance of the TempConverter module\n\n    \/\/ Constructor\n    SC_CTOR(Testbench) : converter_inst(\"converter\") {\n        \/\/ Connect signals to ports\n        converter_inst.fahrenheit(fahrenheit);\n        converter_inst.celsius(celsius);\n\n        \/\/ Process to run tests\n        SC_THREAD(run_tests);\n    }\n\n    \/\/ Thread to run test cases\n    void run_tests() {\n        \/\/ Test case 1: Convert 40°F to Celsius\n        fahrenheit = 40.0;\n        wait(1, SC_NS); \/\/ Wait for the converter to process\n        float result = celsius.read();\n        cout << \"40°F in Celsius: \" << result << \"°C\" << endl;\n        assert(abs(result - 4.44444) < 0.0001); \/\/ Allow for floating-point precision errors\n\n        \/\/ Test case 2: Convert 100°F to Celsius\n        fahrenheit = 100.0;\n        wait(1, SC_NS);\n        result = celsius.read();\n        cout << \"100°F in Celsius: \" << result << \"°C\" << endl;\n        assert(abs(result - 37.7778) < 0.0001);\n\n        \/\/ Test case 3: Convert 32°F to Celsius (Freezing point of water)\n        fahrenheit = 32.0;\n        wait(1, SC_NS);\n        result = celsius.read();\n        cout << \"32°F in Celsius: \" << result << \"°C\" << endl;\n        assert(abs(result - 0.0) < 0.0001);\n\n        \/\/ Test case 4: Convert 212°F to Celsius (Boiling point of water)\n        fahrenheit = 212.0;\n        wait(1, SC_NS);\n        result = celsius.read();\n        cout << \"212°F in Celsius: \" << result << \"°C\" << endl;\n        assert(abs(result - 100.0) < 0.0001);\n\n        \/\/ Print success message\n        cout << \"All tests passed successfully.\" << endl;\n\n        sc_stop(); \/\/ Stop the simulation\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); \/\/ Create an instance of the Testbench\n\n    \/\/ Start the simulation\n    sc_start();\n\n    return 0;\n}\n",
        "signal":"sc_in<float> fahrenheit;\nsc_out<float> celsius;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input.\n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<float> fahrenheit;\nsc_out<float> celsius;\n> **Note**:\n   - Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n   - If the static const are provided, insure to write them in the SystemC code as well.\n\n**C++\/C Code**:\n```\n\/\/ C++ program to convert Fahrenheit scale to Celsius scale\n#include <bits\/stdc++.h>\nusing namespace std;\n\n\/\/ Function to convert Fahrenheit \n\/\/ to Celsius\nfloat Conversion(float n)\n{\n\treturn (n - 32.0) * 5.0 \/ 9.0;\n}\n\n\/\/ Driver code\nint main()\n{\n\tfloat n = 40;\n\tcout << Conversion(n);\n\treturn 0;\n}\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\nFew_shot_example_1:\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        dont_initialize();\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n\nFew_shot_example_2:\n#include <systemc.h>\n\n\/\/ Module: BubbleSort\n\/\/ Sorts a small fixed-size array of integers using the bubble sort algorithm.\nSC_MODULE(BubbleSort) {\n    sc_in<bool>  clk;      \/\/ Clock signal\n    sc_in<bool>  start;    \/\/ Start signal to begin sorting\n    sc_out<bool> done;     \/\/ Signal asserted when sorting is complete\n\n    sc_in<int>   in_arr[4];  \/\/ Input array of 4 integers to be sorted\n    sc_out<int>  out_arr[4]; \/\/ Output array of 4 sorted integers\n\n    int buf[4];  \/\/ Internal buffer to hold array elements during sorting\n\n    \/\/ Constructor: registers the sorting process with the clock\n    SC_CTOR(BubbleSort) {\n        SC_THREAD(sort_proc);\n        sensitive << clk.pos();\n    }\n\n    \/\/ Thread: waits for start, performs bubble sort, writes results, toggles done\n    void sort_proc() {\n        const int N = 4;\n        while (true) {\n            wait();  \/\/ wait for next clock edge\n            if (start.read()) {\n                \/\/ Read inputs into internal buffer\n                for (int i = 0; i < N; ++i)\n                    buf[i] = in_arr[i].read();\n\n                \/\/ Perform bubble sort on buffer[]\n                for (int i = 0; i < N - 1; ++i)\n                    for (int j = 0; j < N - i - 1; ++j)\n                        if (buf[j] > buf[j + 1])\n                            std::swap(buf[j], buf[j + 1]);\n\n                \/\/ Write sorted results to output ports\n                for (int i = 0; i < N; ++i)\n                    out_arr[i].write(buf[i]);\n\n                \/\/ Signal done for one cycle\n                done.write(true);\n                wait();\n                done.write(false);\n            }\n        }\n    }\n};\n\nFew_shot_example_3:\n#include <systemc.h>\n\n\/\/ Module: MatrixAdder\n\/\/ Adds two 4×4 matrices of integers element-wise.\nSC_MODULE(MatrixAdder) {\n    sc_in<int> A[4*4];   \/\/ Flattened 4×4 input matrix A (16 elements)\n    sc_in<int> B[4*4];   \/\/ Flattened 4×4 input matrix B (16 elements)\n    sc_out<int> C[4*4];  \/\/ Flattened 4×4 output matrix C = A + B\n\n    \/\/ Constructor: registers a combinational add method sensitive to all inputs\n    SC_CTOR(MatrixAdder) {\n        SC_METHOD(do_add);\n        \/\/ Make the add method sensitive to every element of A and B\n        for (int i = 0; i < 4*4; i++) {\n            sensitive << A[i] << B[i];\n        }\n    }\n\n    \/\/ Method: reads A[i] and B[i], writes sum into C[i] for all 16 positions\n    void do_add() {\n        for (int i = 0; i < 4*4; i++) {\n            C[i].write(A[i].read() + B[i].read());\n        }\n    }\n};\n\n\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":10,
        "task":"CalculateSumofFirstnNaturalNumbers",
        "code":"\/\/ C++ program to find sum of first n natural numbers. \n#include <iostream> \nusing namespace std; \n\n\/\/ Returns sum of first n natural \n\/\/ numbers \nint findSum(int n) \n{ \n\tint sum = 0; \n\tfor (int i = 1; i <= n; i++) \n\t\tsum = sum + i; \n\treturn sum; \n} \n\n\/\/ Driver code \nint main() \n{ \n\tint n = 5; \n\tcout << findSum(n); \n\treturn 0; \n}\n",
        "category":"Basic Math",
        "adoption":true,
        "reason":null,
        "module_name":"SumCalculator",
        "testbench":"SC_MODULE(Testbench) {\n    sc_signal<unsigned int> n_sig;    \/\/ Signal for the number of natural numbers\n    sc_signal<unsigned int> result_sig; \/\/ Signal for the sum result\n\n    \/\/ Instance of the SumCalculator module\n    SumCalculator sum_calc_inst;\n\n    \/\/ Constructor\n    SC_CTOR(Testbench) : sum_calc_inst(\"sum_calc_inst\") {\n        \/\/ Connect signals to module ports\n        sum_calc_inst.n(n_sig);\n        sum_calc_inst.result(result_sig);\n\n        \/\/ Create a test thread to provide stimulus and check the result\n        SC_THREAD(run_tests);\n    }\n\n    \/\/ Thread to run test cases\n    void run_tests() {\n        \/\/ Test case: n = 5 (expected sum = 15)\n        n_sig.write(5);\n        wait(1, SC_NS); \/\/ Wait for the process to update\n        unsigned int result = result_sig.read();\n        std::cout << \"Sum of first \" << n_sig.read() << \" natural numbers: \" << result << std::endl;\n        assert(result == 15);\n\n        \/\/ Additional test case: n = 10 (expected sum = 55)\n        n_sig.write(10);\n        wait(1, SC_NS);\n        result = result_sig.read();\n        std::cout << \"Sum of first \" << n_sig.read() << \" natural numbers: \" << result << std::endl;\n        assert(result == 55);\n\n        \/\/ End simulation after successful test\n        std::cout << \"All tests passed successfully.\" << std::endl;\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); \/\/ Instantiate the testbench module\n    sc_start();         \/\/ Start the simulation\n    return 0;\n}\n",
        "signal":"sc_in<unsigned int> n;\nsc_out<unsigned int> result;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input.\n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<unsigned int> n;\nsc_out<unsigned int> result;\n> **Note**:\n   - Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n   - If the static const are provided, insure to write them in the SystemC code as well.\n\n**C++\/C Code**:\n```\n\/\/ C++ program to find sum of first n natural numbers. \n#include <iostream> \nusing namespace std; \n\n\/\/ Returns sum of first n natural \n\/\/ numbers \nint findSum(int n) \n{ \n\tint sum = 0; \n\tfor (int i = 1; i <= n; i++) \n\t\tsum = sum + i; \n\treturn sum; \n} \n\n\/\/ Driver code \nint main() \n{ \n\tint n = 5; \n\tcout << findSum(n); \n\treturn 0; \n}\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\nFew_shot_example_1:\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        dont_initialize();\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n\nFew_shot_example_2:\n#include <systemc.h>\n\n\/\/ Module: BubbleSort\n\/\/ Sorts a small fixed-size array of integers using the bubble sort algorithm.\nSC_MODULE(BubbleSort) {\n    sc_in<bool>  clk;      \/\/ Clock signal\n    sc_in<bool>  start;    \/\/ Start signal to begin sorting\n    sc_out<bool> done;     \/\/ Signal asserted when sorting is complete\n\n    sc_in<int>   in_arr[4];  \/\/ Input array of 4 integers to be sorted\n    sc_out<int>  out_arr[4]; \/\/ Output array of 4 sorted integers\n\n    int buf[4];  \/\/ Internal buffer to hold array elements during sorting\n\n    \/\/ Constructor: registers the sorting process with the clock\n    SC_CTOR(BubbleSort) {\n        SC_THREAD(sort_proc);\n        sensitive << clk.pos();\n    }\n\n    \/\/ Thread: waits for start, performs bubble sort, writes results, toggles done\n    void sort_proc() {\n        const int N = 4;\n        while (true) {\n            wait();  \/\/ wait for next clock edge\n            if (start.read()) {\n                \/\/ Read inputs into internal buffer\n                for (int i = 0; i < N; ++i)\n                    buf[i] = in_arr[i].read();\n\n                \/\/ Perform bubble sort on buffer[]\n                for (int i = 0; i < N - 1; ++i)\n                    for (int j = 0; j < N - i - 1; ++j)\n                        if (buf[j] > buf[j + 1])\n                            std::swap(buf[j], buf[j + 1]);\n\n                \/\/ Write sorted results to output ports\n                for (int i = 0; i < N; ++i)\n                    out_arr[i].write(buf[i]);\n\n                \/\/ Signal done for one cycle\n                done.write(true);\n                wait();\n                done.write(false);\n            }\n        }\n    }\n};\n\nFew_shot_example_3:\n#include <systemc.h>\n\n\/\/ Module: MatrixAdder\n\/\/ Adds two 4×4 matrices of integers element-wise.\nSC_MODULE(MatrixAdder) {\n    sc_in<int> A[4*4];   \/\/ Flattened 4×4 input matrix A (16 elements)\n    sc_in<int> B[4*4];   \/\/ Flattened 4×4 input matrix B (16 elements)\n    sc_out<int> C[4*4];  \/\/ Flattened 4×4 output matrix C = A + B\n\n    \/\/ Constructor: registers a combinational add method sensitive to all inputs\n    SC_CTOR(MatrixAdder) {\n        SC_METHOD(do_add);\n        \/\/ Make the add method sensitive to every element of A and B\n        for (int i = 0; i < 4*4; i++) {\n            sensitive << A[i] << B[i];\n        }\n    }\n\n    \/\/ Method: reads A[i] and B[i], writes sum into C[i] for all 16 positions\n    void do_add() {\n        for (int i = 0; i < 4*4; i++) {\n            C[i].write(A[i].read() + B[i].read());\n        }\n    }\n};\n\n\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":11,
        "task":"CalculatetheAverageofalltheElementsPresentinanArray",
        "code":"\/\/ C++ program to calculate average of array elements\n#include <iostream>\nusing namespace std;\n\n\/\/ Function that return average\n\/\/ of an array.\ndouble average(int a[], int n)\n{\n    \/\/ Find sum of array element\n    int sum = 0;\n    for (int i = 0; i < n; i++)\n        sum += a[i];\n\n    return (double)sum \/ n;\n}\n\n\/\/ Driver code\nint main()\n{\n    int arr[] = { 10, 2, 3, 4, 5, 6, 7, 8, 9 };\n    int n = sizeof(arr) \/ sizeof(arr[0]);\n\n    cout << average(arr, n) << endl;\n    return 0;\n}\n",
        "category":"Array Operation",
        "adoption":true,
        "reason":null,
        "module_name":"AverageCalculator",
        "testbench":"SC_MODULE(Testbench) {\n    sc_signal<int> sig_data0, sig_data1, sig_data2,\n                   sig_data3, sig_data4, sig_data5,\n                   sig_data6, sig_data7, sig_data8;\n    sc_signal<double> avg_sig;\n\n    AverageCalculator avg_calc_inst;\n\n    SC_CTOR(Testbench)\n    : avg_calc_inst(\"avg_calc_inst\")\n    {\n        avg_calc_inst.data0(sig_data0);\n        avg_calc_inst.data1(sig_data1);\n        avg_calc_inst.data2(sig_data2);\n        avg_calc_inst.data3(sig_data3);\n        avg_calc_inst.data4(sig_data4);\n        avg_calc_inst.data5(sig_data5);\n        avg_calc_inst.data6(sig_data6);\n        avg_calc_inst.data7(sig_data7);\n        avg_calc_inst.data8(sig_data8);\n        avg_calc_inst.average_out(avg_sig);\n\n        SC_THREAD(run_test);\n    }\n\n    void run_test() {\n        int test_data1[9] = {10, 2, 3, 4, 5, 6, 7, 8, 9};\n        sig_data0.write(test_data1[0]);\n        sig_data1.write(test_data1[1]);\n        sig_data2.write(test_data1[2]);\n        sig_data3.write(test_data1[3]);\n        sig_data4.write(test_data1[4]);\n        sig_data5.write(test_data1[5]);\n        sig_data6.write(test_data1[6]);\n        sig_data7.write(test_data1[7]);\n        sig_data8.write(test_data1[8]);\n        wait(1, SC_NS);\n        double avg1 = avg_sig.read();\n        std::cout << \"Computed average 1: \" << avg1 << std::endl;\n        assert(fabs(avg1 - 6.0) < 1e-9);\n\n        int test_data2[9] = {1, 2, 3, 4, 5, 6, 7, 8, 10};\n        sig_data0.write(test_data2[0]);\n        sig_data1.write(test_data2[1]);\n        sig_data2.write(test_data2[2]);\n        sig_data3.write(test_data2[3]);\n        sig_data4.write(test_data2[4]);\n        sig_data5.write(test_data2[5]);\n        sig_data6.write(test_data2[6]);\n        sig_data7.write(test_data2[7]);\n        sig_data8.write(test_data2[8]);\n        wait(1, SC_NS);\n        double avg2 = avg_sig.read();\n        std::cout << \"Computed average 2: \" << avg2 << std::endl;\n        assert(fabs(avg2 - 5.11111) < 1e-5);\n\n        std::cout << \"All tests passed successfully.\" << std::endl;\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\");\n    sc_start();\n    return 0;\n}\n",
        "signal":"sc_in<int> data0, data1, data2, data3, data4, data5, data6, data7, data8;\nsc_out<double> average_out;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input.\n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<int> data0, data1, data2, data3, data4, data5, data6, data7, data8;\nsc_out<double> average_out;\n> **Note**:\n   - Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n   - If the static const are provided, insure to write them in the SystemC code as well.\n\n**C++\/C Code**:\n```\n\/\/ C++ program to calculate average of array elements\n#include <iostream>\nusing namespace std;\n\n\/\/ Function that return average\n\/\/ of an array.\ndouble average(int a[], int n)\n{\n    \/\/ Find sum of array element\n    int sum = 0;\n    for (int i = 0; i < n; i++)\n        sum += a[i];\n\n    return (double)sum \/ n;\n}\n\n\/\/ Driver code\nint main()\n{\n    int arr[] = { 10, 2, 3, 4, 5, 6, 7, 8, 9 };\n    int n = sizeof(arr) \/ sizeof(arr[0]);\n\n    cout << average(arr, n) << endl;\n    return 0;\n}\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\nFew_shot_example_1:\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        dont_initialize();\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n\nFew_shot_example_2:\n#include <systemc.h>\n\n\/\/ Module: BubbleSort\n\/\/ Sorts a small fixed-size array of integers using the bubble sort algorithm.\nSC_MODULE(BubbleSort) {\n    sc_in<bool>  clk;      \/\/ Clock signal\n    sc_in<bool>  start;    \/\/ Start signal to begin sorting\n    sc_out<bool> done;     \/\/ Signal asserted when sorting is complete\n\n    sc_in<int>   in_arr[4];  \/\/ Input array of 4 integers to be sorted\n    sc_out<int>  out_arr[4]; \/\/ Output array of 4 sorted integers\n\n    int buf[4];  \/\/ Internal buffer to hold array elements during sorting\n\n    \/\/ Constructor: registers the sorting process with the clock\n    SC_CTOR(BubbleSort) {\n        SC_THREAD(sort_proc);\n        sensitive << clk.pos();\n    }\n\n    \/\/ Thread: waits for start, performs bubble sort, writes results, toggles done\n    void sort_proc() {\n        const int N = 4;\n        while (true) {\n            wait();  \/\/ wait for next clock edge\n            if (start.read()) {\n                \/\/ Read inputs into internal buffer\n                for (int i = 0; i < N; ++i)\n                    buf[i] = in_arr[i].read();\n\n                \/\/ Perform bubble sort on buffer[]\n                for (int i = 0; i < N - 1; ++i)\n                    for (int j = 0; j < N - i - 1; ++j)\n                        if (buf[j] > buf[j + 1])\n                            std::swap(buf[j], buf[j + 1]);\n\n                \/\/ Write sorted results to output ports\n                for (int i = 0; i < N; ++i)\n                    out_arr[i].write(buf[i]);\n\n                \/\/ Signal done for one cycle\n                done.write(true);\n                wait();\n                done.write(false);\n            }\n        }\n    }\n};\n\nFew_shot_example_3:\n#include <systemc.h>\n\n\/\/ Module: MatrixAdder\n\/\/ Adds two 4×4 matrices of integers element-wise.\nSC_MODULE(MatrixAdder) {\n    sc_in<int> A[4*4];   \/\/ Flattened 4×4 input matrix A (16 elements)\n    sc_in<int> B[4*4];   \/\/ Flattened 4×4 input matrix B (16 elements)\n    sc_out<int> C[4*4];  \/\/ Flattened 4×4 output matrix C = A + B\n\n    \/\/ Constructor: registers a combinational add method sensitive to all inputs\n    SC_CTOR(MatrixAdder) {\n        SC_METHOD(do_add);\n        \/\/ Make the add method sensitive to every element of A and B\n        for (int i = 0; i < 4*4; i++) {\n            sensitive << A[i] << B[i];\n        }\n    }\n\n    \/\/ Method: reads A[i] and B[i], writes sum into C[i] for all 16 positions\n    void do_add() {\n        for (int i = 0; i < 4*4; i++) {\n            C[i].write(A[i].read() + B[i].read());\n        }\n    }\n};\n\n\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":12,
        "task":"CalculatethePowerofaNumber",
        "code":"\/\/ C program to illustrate power function\n#include <math.h>\n#include <stdio.h>\n\nint main()\n{\n    double x = 6.1, y = 4.8;\n\n    \/\/ Storing the answer in result.\n    double result = pow(x, y);\n    printf(\"%.2lf\", result);\n\n    return 0;\n}\n",
        "category":"Basic Math",
        "adoption":true,
        "reason":null,
        "module_name":"PowerModule",
        "testbench":"SC_MODULE(Testbench) {\n    sc_signal<double> x_sig, y_sig, result_sig;\n\n    PowerModule power_inst;\n\n    SC_CTOR(Testbench) : power_inst(\"power_inst\") {\n        power_inst.x(x_sig);\n        power_inst.y(y_sig);\n        power_inst.result(result_sig);\n\n        SC_THREAD(run_tests);\n    }\n\n    void run_tests() {\n        x_sig = 6.1;\n        y_sig = 4.8;\n        wait(1, SC_NS); \/\/ wait for method to evaluate\n\n        double expected = std::pow(6.1, 4.8);\n        double computed = result_sig.read();\n\n        cout << \"Result: \" << computed << endl;\n\n        \/\/ Allow small floating-point error\n        assert(std::fabs(computed - expected) < 1e-6);\n\n        cout << \"Test passed successfully.\" << endl;\n\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\");\n    sc_start();\n    return 0;\n}\n",
        "signal":"sc_in<double> x;\nsc_in<double> y;\nsc_out<double> result;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input.\n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<double> x;\nsc_in<double> y;\nsc_out<double> result;\n> **Note**:\n   - Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n   - If the static const are provided, insure to write them in the SystemC code as well.\n\n**C++\/C Code**:\n```\n\/\/ C program to illustrate power function\n#include <math.h>\n#include <stdio.h>\n\nint main()\n{\n    double x = 6.1, y = 4.8;\n\n    \/\/ Storing the answer in result.\n    double result = pow(x, y);\n    printf(\"%.2lf\", result);\n\n    return 0;\n}\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\nFew_shot_example_1:\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        dont_initialize();\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n\nFew_shot_example_2:\n#include <systemc.h>\n\n\/\/ Module: BubbleSort\n\/\/ Sorts a small fixed-size array of integers using the bubble sort algorithm.\nSC_MODULE(BubbleSort) {\n    sc_in<bool>  clk;      \/\/ Clock signal\n    sc_in<bool>  start;    \/\/ Start signal to begin sorting\n    sc_out<bool> done;     \/\/ Signal asserted when sorting is complete\n\n    sc_in<int>   in_arr[4];  \/\/ Input array of 4 integers to be sorted\n    sc_out<int>  out_arr[4]; \/\/ Output array of 4 sorted integers\n\n    int buf[4];  \/\/ Internal buffer to hold array elements during sorting\n\n    \/\/ Constructor: registers the sorting process with the clock\n    SC_CTOR(BubbleSort) {\n        SC_THREAD(sort_proc);\n        sensitive << clk.pos();\n    }\n\n    \/\/ Thread: waits for start, performs bubble sort, writes results, toggles done\n    void sort_proc() {\n        const int N = 4;\n        while (true) {\n            wait();  \/\/ wait for next clock edge\n            if (start.read()) {\n                \/\/ Read inputs into internal buffer\n                for (int i = 0; i < N; ++i)\n                    buf[i] = in_arr[i].read();\n\n                \/\/ Perform bubble sort on buffer[]\n                for (int i = 0; i < N - 1; ++i)\n                    for (int j = 0; j < N - i - 1; ++j)\n                        if (buf[j] > buf[j + 1])\n                            std::swap(buf[j], buf[j + 1]);\n\n                \/\/ Write sorted results to output ports\n                for (int i = 0; i < N; ++i)\n                    out_arr[i].write(buf[i]);\n\n                \/\/ Signal done for one cycle\n                done.write(true);\n                wait();\n                done.write(false);\n            }\n        }\n    }\n};\n\nFew_shot_example_3:\n#include <systemc.h>\n\n\/\/ Module: MatrixAdder\n\/\/ Adds two 4×4 matrices of integers element-wise.\nSC_MODULE(MatrixAdder) {\n    sc_in<int> A[4*4];   \/\/ Flattened 4×4 input matrix A (16 elements)\n    sc_in<int> B[4*4];   \/\/ Flattened 4×4 input matrix B (16 elements)\n    sc_out<int> C[4*4];  \/\/ Flattened 4×4 output matrix C = A + B\n\n    \/\/ Constructor: registers a combinational add method sensitive to all inputs\n    SC_CTOR(MatrixAdder) {\n        SC_METHOD(do_add);\n        \/\/ Make the add method sensitive to every element of A and B\n        for (int i = 0; i < 4*4; i++) {\n            sensitive << A[i] << B[i];\n        }\n    }\n\n    \/\/ Method: reads A[i] and B[i], writes sum into C[i] for all 16 positions\n    void do_add() {\n        for (int i = 0; i < 4*4; i++) {\n            C[i].write(A[i].read() + B[i].read());\n        }\n    }\n};\n\n\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":13,
        "task":"CheckArmstrongNumber",
        "code":"\/\/ C++ program to implement the above approach\n#include <iostream>\nusing namespace std;\n\n\/\/ Driver code\nint main()\n{\n\tint n = 153;\n\tint temp = n;\n\tint p = 0;\n\n\t\/\/ Function to calculate\n\t\/\/ the sum of individual digits\n\twhile (n > 0) {\n\t\tint rem = n % 10;\n\t\tp = (p) + (rem * rem * rem);\n\t\tn = n \/ 10;\n\t}\n\n\t\/\/ Condition to check whether\n\t\/\/ the value of P equals\n\t\/\/ to user input or not.\n\tif (temp == p) {\n\t\tcout << (\"Yes. It is Armstrong No.\");\n\t}\n\telse {\n\t\tcout << (\"No. It is not an Armstrong No.\");\n\t}\n\treturn 0;\n}\n",
        "category":"Basic Math",
        "adoption":true,
        "reason":null,
        "module_name":"ArmstrongChecker",
        "testbench":"SC_MODULE(Testbench) {\n    sc_signal<int> num_sig;       \/\/ Signal for the number input\n    sc_signal<bool> armstrong_sig; \/\/ Signal for the Armstrong check result\n\n    \/\/ Instance of the ArmstrongChecker module\n    ArmstrongChecker armstrong_checker_inst;\n\n    \/\/ Constructor: Initialize the module and run the test thread\n    SC_CTOR(Testbench)\n    : armstrong_checker_inst(\"armstrong_checker_inst\") {\n        \/\/ Connect signals to module ports\n        armstrong_checker_inst.num_in(num_sig);\n        armstrong_checker_inst.is_armstrong(armstrong_sig);\n\n        \/\/ Create a test thread to provide stimulus and check the result\n        SC_THREAD(run_tests);\n    }\n\n    \/\/ Thread to run test cases\n    void run_tests() {\n        \/\/ Test case: n = 153 (expected: Armstrong number)\n        num_sig.write(153);\n        wait(1, SC_NS); \/\/ Wait for the process to update\n        bool result = armstrong_sig.read();\n        std::cout << \"Number: 153 is Armstrong? \" << (result ? \"Yes\" : \"No\") << std::endl;\n        assert(result == true);\n\n        \/\/ Test case: n = 123 (expected: Not an Armstrong number)\n        num_sig.write(123);\n        wait(1, SC_NS); \/\/ Wait for the process to update\n        result = armstrong_sig.read();\n        std::cout << \"Number: 123 is Armstrong? \" << (result ? \"Yes\" : \"No\") << std::endl;\n        assert(result == false);\n\n        \/\/ End simulation after successful test\n        std::cout << \"Tests passed successfully.\" << std::endl;\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); \/\/ Instantiate the testbench module\n    sc_start();         \/\/ Start the simulation\n    return 0;\n}\n",
        "signal":"sc_in<int> num_in;\nsc_out<bool> is_armstrong;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input.\n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<int> num_in;\nsc_out<bool> is_armstrong;\n> **Note**:\n   - Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n   - If the static const are provided, insure to write them in the SystemC code as well.\n\n**C++\/C Code**:\n```\n\/\/ C++ program to implement the above approach\n#include <iostream>\nusing namespace std;\n\n\/\/ Driver code\nint main()\n{\n\tint n = 153;\n\tint temp = n;\n\tint p = 0;\n\n\t\/\/ Function to calculate\n\t\/\/ the sum of individual digits\n\twhile (n > 0) {\n\t\tint rem = n % 10;\n\t\tp = (p) + (rem * rem * rem);\n\t\tn = n \/ 10;\n\t}\n\n\t\/\/ Condition to check whether\n\t\/\/ the value of P equals\n\t\/\/ to user input or not.\n\tif (temp == p) {\n\t\tcout << (\"Yes. It is Armstrong No.\");\n\t}\n\telse {\n\t\tcout << (\"No. It is not an Armstrong No.\");\n\t}\n\treturn 0;\n}\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\nFew_shot_example_1:\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        dont_initialize();\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n\nFew_shot_example_2:\n#include <systemc.h>\n\n\/\/ Module: BubbleSort\n\/\/ Sorts a small fixed-size array of integers using the bubble sort algorithm.\nSC_MODULE(BubbleSort) {\n    sc_in<bool>  clk;      \/\/ Clock signal\n    sc_in<bool>  start;    \/\/ Start signal to begin sorting\n    sc_out<bool> done;     \/\/ Signal asserted when sorting is complete\n\n    sc_in<int>   in_arr[4];  \/\/ Input array of 4 integers to be sorted\n    sc_out<int>  out_arr[4]; \/\/ Output array of 4 sorted integers\n\n    int buf[4];  \/\/ Internal buffer to hold array elements during sorting\n\n    \/\/ Constructor: registers the sorting process with the clock\n    SC_CTOR(BubbleSort) {\n        SC_THREAD(sort_proc);\n        sensitive << clk.pos();\n    }\n\n    \/\/ Thread: waits for start, performs bubble sort, writes results, toggles done\n    void sort_proc() {\n        const int N = 4;\n        while (true) {\n            wait();  \/\/ wait for next clock edge\n            if (start.read()) {\n                \/\/ Read inputs into internal buffer\n                for (int i = 0; i < N; ++i)\n                    buf[i] = in_arr[i].read();\n\n                \/\/ Perform bubble sort on buffer[]\n                for (int i = 0; i < N - 1; ++i)\n                    for (int j = 0; j < N - i - 1; ++j)\n                        if (buf[j] > buf[j + 1])\n                            std::swap(buf[j], buf[j + 1]);\n\n                \/\/ Write sorted results to output ports\n                for (int i = 0; i < N; ++i)\n                    out_arr[i].write(buf[i]);\n\n                \/\/ Signal done for one cycle\n                done.write(true);\n                wait();\n                done.write(false);\n            }\n        }\n    }\n};\n\nFew_shot_example_3:\n#include <systemc.h>\n\n\/\/ Module: MatrixAdder\n\/\/ Adds two 4×4 matrices of integers element-wise.\nSC_MODULE(MatrixAdder) {\n    sc_in<int> A[4*4];   \/\/ Flattened 4×4 input matrix A (16 elements)\n    sc_in<int> B[4*4];   \/\/ Flattened 4×4 input matrix B (16 elements)\n    sc_out<int> C[4*4];  \/\/ Flattened 4×4 output matrix C = A + B\n\n    \/\/ Constructor: registers a combinational add method sensitive to all inputs\n    SC_CTOR(MatrixAdder) {\n        SC_METHOD(do_add);\n        \/\/ Make the add method sensitive to every element of A and B\n        for (int i = 0; i < 4*4; i++) {\n            sensitive << A[i] << B[i];\n        }\n    }\n\n    \/\/ Method: reads A[i] and B[i], writes sum into C[i] for all 16 positions\n    void do_add() {\n        for (int i = 0; i < 4*4; i++) {\n            C[i].write(A[i].read() + B[i].read());\n        }\n    }\n};\n\n\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":14,
        "task":"CheckEvenorOddIntegers",
        "code":"\/\/ C++ program to check if the number is even or odd using modulo operator\n#include <bits\/stdc++.h>\nusing namespace std;\n\nint main() {\n    int n = 11;\n\n    \/\/ If n is completely divisible by 2\n    if (n % 2 == 0)\n        cout << \"Even\";\n\n    \/\/ If n is NOT completely divisible by 2\n    else\n        cout << \"Odd\";\n    return 0;\n}\n",
        "category":"Basic Math",
        "adoption":true,
        "reason":null,
        "module_name":"EvenOddChecker",
        "testbench":"SC_MODULE(Testbench) {\n    sc_signal<int> number_sig;   \/\/ Signal for the input number\n    sc_signal<int> result_sig;   \/\/ Signal for the result\n\n    EvenOddChecker checker_inst; \/\/ Instance of the EvenOddChecker module\n\n    SC_CTOR(Testbench)\n    : checker_inst(\"checker_inst\")\n    {\n        checker_inst.number_in(number_sig);\n        checker_inst.result_out(result_sig);\n        SC_THREAD(run_tests);\n    }\n\n    void run_tests() {\n        \/\/ Test case 1: Number 11 (Odd)\n        number_sig.write(11);\n        wait(1, SC_NS);\n        std::cout << result_sig.read() << std::endl; \/\/ Expected output: 1\n        assert(result_sig.read() == 1);\n\n        \/\/ Test case 2: Number 12 (Even)\n        number_sig.write(12);\n        wait(1, SC_NS);\n        std::cout << result_sig.read() << std::endl; \/\/ Expected output: 0\n        assert(result_sig.read() == 0);\n        \n        std::cout << \"All tests pass successfully!\" << std::endl;\n        \/\/ End simulation\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\");\n    sc_start();\n    return 0;\n}\n",
        "signal":"sc_in<int> number_in;\nsc_out<int> result_out;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input.\n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<int> number_in;\nsc_out<int> result_out;\n> **Note**:\n   - Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n   - If the static const are provided, insure to write them in the SystemC code as well.\n\n**C++\/C Code**:\n```\n\/\/ C++ program to check if the number is even or odd using modulo operator\n#include <bits\/stdc++.h>\nusing namespace std;\n\nint main() {\n    int n = 11;\n\n    \/\/ If n is completely divisible by 2\n    if (n % 2 == 0)\n        cout << \"Even\";\n\n    \/\/ If n is NOT completely divisible by 2\n    else\n        cout << \"Odd\";\n    return 0;\n}\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\nFew_shot_example_1:\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        dont_initialize();\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n\nFew_shot_example_2:\n#include <systemc.h>\n\n\/\/ Module: BubbleSort\n\/\/ Sorts a small fixed-size array of integers using the bubble sort algorithm.\nSC_MODULE(BubbleSort) {\n    sc_in<bool>  clk;      \/\/ Clock signal\n    sc_in<bool>  start;    \/\/ Start signal to begin sorting\n    sc_out<bool> done;     \/\/ Signal asserted when sorting is complete\n\n    sc_in<int>   in_arr[4];  \/\/ Input array of 4 integers to be sorted\n    sc_out<int>  out_arr[4]; \/\/ Output array of 4 sorted integers\n\n    int buf[4];  \/\/ Internal buffer to hold array elements during sorting\n\n    \/\/ Constructor: registers the sorting process with the clock\n    SC_CTOR(BubbleSort) {\n        SC_THREAD(sort_proc);\n        sensitive << clk.pos();\n    }\n\n    \/\/ Thread: waits for start, performs bubble sort, writes results, toggles done\n    void sort_proc() {\n        const int N = 4;\n        while (true) {\n            wait();  \/\/ wait for next clock edge\n            if (start.read()) {\n                \/\/ Read inputs into internal buffer\n                for (int i = 0; i < N; ++i)\n                    buf[i] = in_arr[i].read();\n\n                \/\/ Perform bubble sort on buffer[]\n                for (int i = 0; i < N - 1; ++i)\n                    for (int j = 0; j < N - i - 1; ++j)\n                        if (buf[j] > buf[j + 1])\n                            std::swap(buf[j], buf[j + 1]);\n\n                \/\/ Write sorted results to output ports\n                for (int i = 0; i < N; ++i)\n                    out_arr[i].write(buf[i]);\n\n                \/\/ Signal done for one cycle\n                done.write(true);\n                wait();\n                done.write(false);\n            }\n        }\n    }\n};\n\nFew_shot_example_3:\n#include <systemc.h>\n\n\/\/ Module: MatrixAdder\n\/\/ Adds two 4×4 matrices of integers element-wise.\nSC_MODULE(MatrixAdder) {\n    sc_in<int> A[4*4];   \/\/ Flattened 4×4 input matrix A (16 elements)\n    sc_in<int> B[4*4];   \/\/ Flattened 4×4 input matrix B (16 elements)\n    sc_out<int> C[4*4];  \/\/ Flattened 4×4 output matrix C = A + B\n\n    \/\/ Constructor: registers a combinational add method sensitive to all inputs\n    SC_CTOR(MatrixAdder) {\n        SC_METHOD(do_add);\n        \/\/ Make the add method sensitive to every element of A and B\n        for (int i = 0; i < 4*4; i++) {\n            sensitive << A[i] << B[i];\n        }\n    }\n\n    \/\/ Method: reads A[i] and B[i], writes sum into C[i] for all 16 positions\n    void do_add() {\n        for (int i = 0; i < 4*4; i++) {\n            C[i].write(A[i].read() + B[i].read());\n        }\n    }\n};\n\n\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":15,
        "task":"CheckifaGivenYearisaLeapYear",
        "code":"\/\/ C++ program to check if a given year is a leap year or not\n#include <iostream>\nusing namespace std;\n\n\/\/ Function to check leap year\nbool checkYear(int year)\n{\n\tif (year % 400 == 0) {\n\t\treturn true;\n\t}\n\n\t\/\/ not a leap year if divisible by 100\n\t\/\/ but not divisible by 400\n\telse if (year % 100 == 0) {\n\t\treturn false;\n\t}\n\n\t\/\/ leap year if not divisible by 100\n\t\/\/ but divisible by 4\n\telse if (year % 4 == 0) {\n\t\treturn true;\n\t}\n\n\t\/\/ all other years are not leap years\n\telse {\n\t\treturn false;\n\t}\n}\n\n\/\/ Driver code\nint main()\n{\n\tint year = 2000;\n\n\tcheckYear(year) ? cout << \"Leap Year\"\n\t\t\t\t\t: cout << \"Not a Leap Year\";\n\n\treturn 0;\n}\n",
        "category":"Basic Math",
        "adoption":true,
        "reason":null,
        "module_name":"LeapYearChecker",
        "testbench":"SC_MODULE(Testbench) {\n    sc_signal<int> year;             \/\/ Signal for the year\n    sc_signal<bool> is_leap_year;    \/\/ Signal for the leap year check result\n\n    LeapYearChecker checker_inst;    \/\/ Instance of the LeapYearChecker module\n\n    \/\/ Constructor\n    SC_CTOR(Testbench) : checker_inst(\"checker\") {\n        \/\/ Connect signals to ports\n        checker_inst.year(year);\n        checker_inst.is_leap_year(is_leap_year);\n\n        \/\/ Process to run tests\n        SC_THREAD(run_tests);\n    }\n\n    \/\/ Thread to run test cases\n    void run_tests() {\n        \/\/ Test case 1: Year 2000 (Leap Year)\n        year = 2000;\n        wait(1, SC_NS);\n        assert(is_leap_year.read() == true);\n        cout << \"Year 2000: \" << (is_leap_year.read() ? \"Leap Year\" : \"Not a Leap Year\") << endl;\n\n        \/\/ Test case 2: Year 1900 (Not a Leap Year)\n        year = 1900;\n        wait(1, SC_NS);\n        assert(is_leap_year.read() == false);\n        cout << \"Year 1900: \" << (is_leap_year.read() ? \"Leap Year\" : \"Not a Leap Year\") << endl;\n\n        \/\/ Test case 3: Year 2004 (Leap Year)\n        year = 2004;\n        wait(1, SC_NS);\n        assert(is_leap_year.read() == true);\n        cout << \"Year 2004: \" << (is_leap_year.read() ? \"Leap Year\" : \"Not a Leap Year\") << endl;\n\n        \/\/ Test case 4: Year 2001 (Not a Leap Year)\n        year = 2001;\n        wait(1, SC_NS);\n        assert(is_leap_year.read() == false);\n        cout << \"Year 2001: \" << (is_leap_year.read() ? \"Leap Year\" : \"Not a Leap Year\") << endl;\n\n        \/\/ Print success message\n        cout << \"All tests passed successfully.\" << endl;\n\n        sc_stop(); \/\/ Stop the simulation\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); \/\/ Create an instance of the Testbench\n\n    \/\/ Start the simulation\n    sc_start();\n\n    return 0;\n}\n",
        "signal":"sc_in<int> year;\nsc_out<bool> is_leap_year;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input.\n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<int> year;\nsc_out<bool> is_leap_year;\n> **Note**:\n   - Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n   - If the static const are provided, insure to write them in the SystemC code as well.\n\n**C++\/C Code**:\n```\n\/\/ C++ program to check if a given year is a leap year or not\n#include <iostream>\nusing namespace std;\n\n\/\/ Function to check leap year\nbool checkYear(int year)\n{\n\tif (year % 400 == 0) {\n\t\treturn true;\n\t}\n\n\t\/\/ not a leap year if divisible by 100\n\t\/\/ but not divisible by 400\n\telse if (year % 100 == 0) {\n\t\treturn false;\n\t}\n\n\t\/\/ leap year if not divisible by 100\n\t\/\/ but divisible by 4\n\telse if (year % 4 == 0) {\n\t\treturn true;\n\t}\n\n\t\/\/ all other years are not leap years\n\telse {\n\t\treturn false;\n\t}\n}\n\n\/\/ Driver code\nint main()\n{\n\tint year = 2000;\n\n\tcheckYear(year) ? cout << \"Leap Year\"\n\t\t\t\t\t: cout << \"Not a Leap Year\";\n\n\treturn 0;\n}\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\nFew_shot_example_1:\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        dont_initialize();\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n\nFew_shot_example_2:\n#include <systemc.h>\n\n\/\/ Module: BubbleSort\n\/\/ Sorts a small fixed-size array of integers using the bubble sort algorithm.\nSC_MODULE(BubbleSort) {\n    sc_in<bool>  clk;      \/\/ Clock signal\n    sc_in<bool>  start;    \/\/ Start signal to begin sorting\n    sc_out<bool> done;     \/\/ Signal asserted when sorting is complete\n\n    sc_in<int>   in_arr[4];  \/\/ Input array of 4 integers to be sorted\n    sc_out<int>  out_arr[4]; \/\/ Output array of 4 sorted integers\n\n    int buf[4];  \/\/ Internal buffer to hold array elements during sorting\n\n    \/\/ Constructor: registers the sorting process with the clock\n    SC_CTOR(BubbleSort) {\n        SC_THREAD(sort_proc);\n        sensitive << clk.pos();\n    }\n\n    \/\/ Thread: waits for start, performs bubble sort, writes results, toggles done\n    void sort_proc() {\n        const int N = 4;\n        while (true) {\n            wait();  \/\/ wait for next clock edge\n            if (start.read()) {\n                \/\/ Read inputs into internal buffer\n                for (int i = 0; i < N; ++i)\n                    buf[i] = in_arr[i].read();\n\n                \/\/ Perform bubble sort on buffer[]\n                for (int i = 0; i < N - 1; ++i)\n                    for (int j = 0; j < N - i - 1; ++j)\n                        if (buf[j] > buf[j + 1])\n                            std::swap(buf[j], buf[j + 1]);\n\n                \/\/ Write sorted results to output ports\n                for (int i = 0; i < N; ++i)\n                    out_arr[i].write(buf[i]);\n\n                \/\/ Signal done for one cycle\n                done.write(true);\n                wait();\n                done.write(false);\n            }\n        }\n    }\n};\n\nFew_shot_example_3:\n#include <systemc.h>\n\n\/\/ Module: MatrixAdder\n\/\/ Adds two 4×4 matrices of integers element-wise.\nSC_MODULE(MatrixAdder) {\n    sc_in<int> A[4*4];   \/\/ Flattened 4×4 input matrix A (16 elements)\n    sc_in<int> B[4*4];   \/\/ Flattened 4×4 input matrix B (16 elements)\n    sc_out<int> C[4*4];  \/\/ Flattened 4×4 output matrix C = A + B\n\n    \/\/ Constructor: registers a combinational add method sensitive to all inputs\n    SC_CTOR(MatrixAdder) {\n        SC_METHOD(do_add);\n        \/\/ Make the add method sensitive to every element of A and B\n        for (int i = 0; i < 4*4; i++) {\n            sensitive << A[i] << B[i];\n        }\n    }\n\n    \/\/ Method: reads A[i] and B[i], writes sum into C[i] for all 16 positions\n    void do_add() {\n        for (int i = 0; i < 4*4; i++) {\n            C[i].write(A[i].read() + B[i].read());\n        }\n    }\n};\n\n\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":16,
        "task":"CheckiftwoArraysareEqualornot",
        "code":"\/\/ C++ program to implement the approach\n\n#include <bits\/stdc++.h>\nusing namespace std;\n\n\/\/ Function to check if both arrays are equal\nbool checkArrays(int arr1[], int arr2[],\n\t\t\t\tint n, int m)\n{\n\t\/\/ If lengths of array are not equal\n\t\/\/ means array are not equal\n\tif (n != m)\n\t\treturn false;\n\n\t\/\/ Sort both arrays\n\tsort(arr1, arr1 + n);\n\tsort(arr2, arr2 + m);\n\n\t\/\/ Linearly compare elements\n\tfor (int i = 0; i < n; i++)\n\t\tif (arr1[i] != arr2[i])\n\t\t\treturn false;\n\n\t\/\/ If elements are same\n\treturn true;\n}\n\n\/\/ Driver Code\nint main()\n{\n\tint arr1[] = { 1, 2, 3, 4, 5 };\n\tint arr2[] = { 5, 4, 3, 2, 1 };\n\tint N = sizeof(arr1) \/ sizeof(int);\n\tint M = sizeof(arr2) \/ sizeof(int);\n\n\t\/\/ Function call\n\tif (checkArrays(arr1, arr2, N, M))\n\t\tcout << \"Equal\";\n\telse\n\t\tcout << \"Not Equal\";\n\treturn 0;\n}\n",
        "category":"Array Operation",
        "adoption":true,
        "reason":null,
        "module_name":"CheckArraysEqual",
        "testbench":"SC_MODULE(Testbench) {\n    sc_clock clk{\"clk\", 1, SC_NS};\n    sc_signal<bool> start, done, result;\n    sc_signal<int> sig_arr1[5], sig_arr2[5];\n\n    CheckArraysEqual* dut;\n\n    SC_CTOR(Testbench) {\n        dut = new CheckArraysEqual(\"CheckArraysEqual\");\n        dut->clk(clk);\n        dut->start(start);\n        dut->done(done);\n        dut->result(result);\n        for (int i = 0; i < 5; ++i) {\n            dut->in_arr1[i](sig_arr1[i]);\n            dut->in_arr2[i](sig_arr2[i]);\n        }\n\n        SC_THREAD(run_tests);\n    }\n\n    void run_tests() {\n        int A[5] = {1, 2, 3, 4, 5};\n        int B[5] = {5, 4, 3, 2, 1};\n\n        for (int i = 0; i < 5; ++i) {\n            sig_arr1[i].write(A[i]);\n            sig_arr2[i].write(B[i]);\n        }\n\n        wait(clk.posedge_event());\n        start.write(true);\n        wait(clk.posedge_event());\n        start.write(false);\n\n        wait(done.posedge_event());\n\n        bool res = result.read();\n        std::cout << \"Arrays are \" << (res ? \"Equal\" : \"Not Equal\") << std::endl;\n        assert(res == true);\n\n        std::cout << \"Test passed successfully.\\n\";\n        sc_stop();\n    }\n};\n\nint sc_main(int, char*[]) {\n    Testbench tb{\"tb\"};\n    sc_start();\n    return 0;\n}",
        "signal":"sc_in<bool>  clk;\nsc_in<bool>  start;\nsc_out<bool> done;\nsc_out<bool> result;\nsc_in<int>   in_arr1[5];\nsc_in<int>   in_arr2[5];",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input.\n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<bool>  clk;\nsc_in<bool>  start;\nsc_out<bool> done;\nsc_out<bool> result;\nsc_in<int>   in_arr1[5];\nsc_in<int>   in_arr2[5];\n> **Note**:\n   - Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n   - If the static const are provided, insure to write them in the SystemC code as well.\n\n**C++\/C Code**:\n```\n\/\/ C++ program to implement the approach\n\n#include <bits\/stdc++.h>\nusing namespace std;\n\n\/\/ Function to check if both arrays are equal\nbool checkArrays(int arr1[], int arr2[],\n\t\t\t\tint n, int m)\n{\n\t\/\/ If lengths of array are not equal\n\t\/\/ means array are not equal\n\tif (n != m)\n\t\treturn false;\n\n\t\/\/ Sort both arrays\n\tsort(arr1, arr1 + n);\n\tsort(arr2, arr2 + m);\n\n\t\/\/ Linearly compare elements\n\tfor (int i = 0; i < n; i++)\n\t\tif (arr1[i] != arr2[i])\n\t\t\treturn false;\n\n\t\/\/ If elements are same\n\treturn true;\n}\n\n\/\/ Driver Code\nint main()\n{\n\tint arr1[] = { 1, 2, 3, 4, 5 };\n\tint arr2[] = { 5, 4, 3, 2, 1 };\n\tint N = sizeof(arr1) \/ sizeof(int);\n\tint M = sizeof(arr2) \/ sizeof(int);\n\n\t\/\/ Function call\n\tif (checkArrays(arr1, arr2, N, M))\n\t\tcout << \"Equal\";\n\telse\n\t\tcout << \"Not Equal\";\n\treturn 0;\n}\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\nFew_shot_example_1:\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        dont_initialize();\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n\nFew_shot_example_2:\n#include <systemc.h>\n\n\/\/ Module: BubbleSort\n\/\/ Sorts a small fixed-size array of integers using the bubble sort algorithm.\nSC_MODULE(BubbleSort) {\n    sc_in<bool>  clk;      \/\/ Clock signal\n    sc_in<bool>  start;    \/\/ Start signal to begin sorting\n    sc_out<bool> done;     \/\/ Signal asserted when sorting is complete\n\n    sc_in<int>   in_arr[4];  \/\/ Input array of 4 integers to be sorted\n    sc_out<int>  out_arr[4]; \/\/ Output array of 4 sorted integers\n\n    int buf[4];  \/\/ Internal buffer to hold array elements during sorting\n\n    \/\/ Constructor: registers the sorting process with the clock\n    SC_CTOR(BubbleSort) {\n        SC_THREAD(sort_proc);\n        sensitive << clk.pos();\n    }\n\n    \/\/ Thread: waits for start, performs bubble sort, writes results, toggles done\n    void sort_proc() {\n        const int N = 4;\n        while (true) {\n            wait();  \/\/ wait for next clock edge\n            if (start.read()) {\n                \/\/ Read inputs into internal buffer\n                for (int i = 0; i < N; ++i)\n                    buf[i] = in_arr[i].read();\n\n                \/\/ Perform bubble sort on buffer[]\n                for (int i = 0; i < N - 1; ++i)\n                    for (int j = 0; j < N - i - 1; ++j)\n                        if (buf[j] > buf[j + 1])\n                            std::swap(buf[j], buf[j + 1]);\n\n                \/\/ Write sorted results to output ports\n                for (int i = 0; i < N; ++i)\n                    out_arr[i].write(buf[i]);\n\n                \/\/ Signal done for one cycle\n                done.write(true);\n                wait();\n                done.write(false);\n            }\n        }\n    }\n};\n\nFew_shot_example_3:\n#include <systemc.h>\n\n\/\/ Module: MatrixAdder\n\/\/ Adds two 4×4 matrices of integers element-wise.\nSC_MODULE(MatrixAdder) {\n    sc_in<int> A[4*4];   \/\/ Flattened 4×4 input matrix A (16 elements)\n    sc_in<int> B[4*4];   \/\/ Flattened 4×4 input matrix B (16 elements)\n    sc_out<int> C[4*4];  \/\/ Flattened 4×4 output matrix C = A + B\n\n    \/\/ Constructor: registers a combinational add method sensitive to all inputs\n    SC_CTOR(MatrixAdder) {\n        SC_METHOD(do_add);\n        \/\/ Make the add method sensitive to every element of A and B\n        for (int i = 0; i < 4*4; i++) {\n            sensitive << A[i] << B[i];\n        }\n    }\n\n    \/\/ Method: reads A[i] and B[i], writes sum into C[i] for all 16 positions\n    void do_add() {\n        for (int i = 0; i < 4*4; i++) {\n            C[i].write(A[i].read() + B[i].read());\n        }\n    }\n};\n\n\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":17,
        "task":"CheckWhetheraNumberCanbeExpressedasSumofTwoPrimeNumbers",
        "code":"\/\/ C++ program to check if a prime number can be expressed as sum of two Prime Numbers \n#include <bits\/stdc++.h> \nusing namespace std; \n\n\/\/ Function to check whether \n\/\/ a number is prime or not \nbool isPrime(int n) \n{ \n\tif (n <= 1) \n\t\treturn false; \n\n\tfor (int i = 2; i <= sqrt(n); i++) \n\t{ \n\t\tif (n % i == 0) \n\t\t\treturn false; \n\t} \n\n\treturn true; \n} \n\n\/\/ Function to check if a prime number \n\/\/ can be expressed as sum of \n\/\/ two Prime Numbers \nbool isPossible(int N) \n{ \n\t\/\/ if the number is prime, \n\t\/\/ and number-2 is also prime \n\tif (isPrime(N) && isPrime(N - 2)) \n\t\treturn true; \n\telse\n\t\treturn false; \n} \n\n\/\/ Driver code \nint main() \n{ \n\tint n = 13; \n\n\tif (isPossible(n)) \n\t\tcout << \"Yes\"; \n\telse\n\t\tcout << \"No\"; \n\n\treturn 0; \n} \n",
        "category":"Basic Math",
        "adoption":true,
        "reason":null,
        "module_name":"PrimeSumChecker",
        "testbench":"SC_MODULE(Testbench) {\n    sc_signal<int> n_sig;       \/\/ Signal for the input number\n    sc_signal<bool> result_sig; \/\/ Signal for the result\n\n    \/\/ Instance of the PrimeSumChecker module\n    PrimeSumChecker checker_inst;\n\n    \/\/ Constructor: Initialize the module and run the test thread\n    SC_CTOR(Testbench)\n    : checker_inst(\"checker_inst\") {\n        \/\/ Connect signals to module ports\n        checker_inst.n_in(n_sig);\n        checker_inst.result_out(result_sig);\n\n        \/\/ Create a test thread to provide stimulus and check the result\n        SC_THREAD(run_tests);\n    }\n\n    \/\/ Thread to run test cases\n    void run_tests() {\n        \/\/ Test case: n = 13 (expected result: true)\n        n_sig.write(13);\n        wait(1, SC_NS); \/\/ Wait for the process to update\n        bool result = result_sig.read();\n        std::cout << \"Can 13 be expressed as the sum of two primes? \" << (result ? \"Yes\" : \"No\") << std::endl;\n        assert(result == true);\n\n        \/\/ Additional test case: n = 17 (expected result: false)\n        n_sig.write(17);\n        wait(1, SC_NS);\n        result = result_sig.read();\n        std::cout << \"Can 17 be expressed as the sum of two primes? \" << (result ? \"Yes\" : \"No\") << std::endl;\n        assert(result == false);\n\n        \/\/ End simulation after successful tests\n        std::cout << \"All tests passed successfully.\" << std::endl;\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); \/\/ Instantiate the testbench module\n    sc_start();         \/\/ Start the simulation\n    return 0;\n}\n",
        "signal":"sc_in<int> n_in;\nsc_out<bool> result_out;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input.\n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<int> n_in;\nsc_out<bool> result_out;\n> **Note**:\n   - Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n   - If the static const are provided, insure to write them in the SystemC code as well.\n\n**C++\/C Code**:\n```\n\/\/ C++ program to check if a prime number can be expressed as sum of two Prime Numbers \n#include <bits\/stdc++.h> \nusing namespace std; \n\n\/\/ Function to check whether \n\/\/ a number is prime or not \nbool isPrime(int n) \n{ \n\tif (n <= 1) \n\t\treturn false; \n\n\tfor (int i = 2; i <= sqrt(n); i++) \n\t{ \n\t\tif (n % i == 0) \n\t\t\treturn false; \n\t} \n\n\treturn true; \n} \n\n\/\/ Function to check if a prime number \n\/\/ can be expressed as sum of \n\/\/ two Prime Numbers \nbool isPossible(int N) \n{ \n\t\/\/ if the number is prime, \n\t\/\/ and number-2 is also prime \n\tif (isPrime(N) && isPrime(N - 2)) \n\t\treturn true; \n\telse\n\t\treturn false; \n} \n\n\/\/ Driver code \nint main() \n{ \n\tint n = 13; \n\n\tif (isPossible(n)) \n\t\tcout << \"Yes\"; \n\telse\n\t\tcout << \"No\"; \n\n\treturn 0; \n} \n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\nFew_shot_example_1:\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        dont_initialize();\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n\nFew_shot_example_2:\n#include <systemc.h>\n\n\/\/ Module: BubbleSort\n\/\/ Sorts a small fixed-size array of integers using the bubble sort algorithm.\nSC_MODULE(BubbleSort) {\n    sc_in<bool>  clk;      \/\/ Clock signal\n    sc_in<bool>  start;    \/\/ Start signal to begin sorting\n    sc_out<bool> done;     \/\/ Signal asserted when sorting is complete\n\n    sc_in<int>   in_arr[4];  \/\/ Input array of 4 integers to be sorted\n    sc_out<int>  out_arr[4]; \/\/ Output array of 4 sorted integers\n\n    int buf[4];  \/\/ Internal buffer to hold array elements during sorting\n\n    \/\/ Constructor: registers the sorting process with the clock\n    SC_CTOR(BubbleSort) {\n        SC_THREAD(sort_proc);\n        sensitive << clk.pos();\n    }\n\n    \/\/ Thread: waits for start, performs bubble sort, writes results, toggles done\n    void sort_proc() {\n        const int N = 4;\n        while (true) {\n            wait();  \/\/ wait for next clock edge\n            if (start.read()) {\n                \/\/ Read inputs into internal buffer\n                for (int i = 0; i < N; ++i)\n                    buf[i] = in_arr[i].read();\n\n                \/\/ Perform bubble sort on buffer[]\n                for (int i = 0; i < N - 1; ++i)\n                    for (int j = 0; j < N - i - 1; ++j)\n                        if (buf[j] > buf[j + 1])\n                            std::swap(buf[j], buf[j + 1]);\n\n                \/\/ Write sorted results to output ports\n                for (int i = 0; i < N; ++i)\n                    out_arr[i].write(buf[i]);\n\n                \/\/ Signal done for one cycle\n                done.write(true);\n                wait();\n                done.write(false);\n            }\n        }\n    }\n};\n\nFew_shot_example_3:\n#include <systemc.h>\n\n\/\/ Module: MatrixAdder\n\/\/ Adds two 4×4 matrices of integers element-wise.\nSC_MODULE(MatrixAdder) {\n    sc_in<int> A[4*4];   \/\/ Flattened 4×4 input matrix A (16 elements)\n    sc_in<int> B[4*4];   \/\/ Flattened 4×4 input matrix B (16 elements)\n    sc_out<int> C[4*4];  \/\/ Flattened 4×4 output matrix C = A + B\n\n    \/\/ Constructor: registers a combinational add method sensitive to all inputs\n    SC_CTOR(MatrixAdder) {\n        SC_METHOD(do_add);\n        \/\/ Make the add method sensitive to every element of A and B\n        for (int i = 0; i < 4*4; i++) {\n            sensitive << A[i] << B[i];\n        }\n    }\n\n    \/\/ Method: reads A[i] and B[i], writes sum into C[i] for all 16 positions\n    void do_add() {\n        for (int i = 0; i < 4*4; i++) {\n            C[i].write(A[i].read() + B[i].read());\n        }\n    }\n};\n\n\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":18,
        "task":"CheckWhetheraNumberisaPalindromeorNot",
        "code":"\/\/ C++ implementation of the above approach\n#include <iostream>\nusing namespace std;\n\n\/\/ Function to check palindrome\nint checkPalindrome(string str)\n{ \n\t\/\/ Calculating string length\n\tint len = str.length();\n\n\t\/\/ Traversing through the string \n\t\/\/ upto half its length\n\tfor (int i = 0; i < len \/ 2; i++) \n\t{\t \n\t\t\/\/ Comparing i th character from \n\t\t\/\/ starting and len-i th character \n\t\t\/\/ from end\n\t\tif (str[i] != str[len - i - 1])\n\t\t\treturn false;\n\t}\n\n\t\/\/ If the above loop doesn't return \n\t\/\/ then it is palindrome\n\treturn true;\n}\n\n\/\/ Driver Code\nint main()\n{ \n\t\/\/ Taking number as string\n\tstring st = \n\t\"112233445566778899000000998877665544332211\";\n\tif (checkPalindrome(st) == true)\n\t\tcout << \"Yes\";\n\telse\n\t\tcout << \"No\";\n\treturn 0;\n}\n\/\/ This code is written by vikkycirus\n",
        "category":"Basic Math",
        "adoption":false,
        "reason":null,
        "module_name":null,
        "testbench":null,
        "signal":null,
        "prompt":null
    },
    {
        "task_id":19,
        "task":"CheckWhetheraNumberisPrimeorNot",
        "code":"\/\/ C++ Program to check for prime number using Simple Trial Division\n#include <bits\/stdc++.h>\nusing namespace std;\n\nint main() {\n    int n = 29;\n\n    int cnt = 0;\n\n    \/\/ If number is less than\/equal to 1,\n    \/\/ it is not prime\n    if (n <= 1)\n        cout << n << \" is NOT prime\" << endl;\n    else {\n\n        \/\/ Check for divisors from 1 to n\n        for (int i = 1; i <= n; i++) {\n\n            \/\/ Check how many number is divisible\n            \/\/ by n\n            if (n % i == 0)\n                cnt++;\n        }\n\n        \/\/ If n is divisible by more than 2 numbers\n        \/\/ then it is not prime\n        if (cnt > 2)\n            cout << n << \" is NOT prime\" << endl;\n\n        \/\/ else it is prime\n        else\n            cout << n << \" is prime\" << endl;\n    }\n\n    return 0;\n}\n\n",
        "category":"Basic Math",
        "adoption":true,
        "reason":null,
        "module_name":"PrimeChecker",
        "testbench":"SC_MODULE(Testbench) {\n    sc_signal<int> n_sig;       \/\/ Signal for the input number\n    sc_signal<bool> prime_sig;  \/\/ Signal for the prime check result\n\n    \/\/ Instance of the PrimeChecker module\n    PrimeChecker prime_checker_inst;\n\n    \/\/ Constructor: Initialize the module and run the test thread\n    SC_CTOR(Testbench)\n    : prime_checker_inst(\"prime_checker_inst\") {\n        \/\/ Connect signals to module ports\n        prime_checker_inst.n(n_sig);\n        prime_checker_inst.is_prime(prime_sig);\n\n        \/\/ Create a test thread to provide stimulus and check the result\n        SC_THREAD(run_tests);\n    }\n\n    \/\/ Thread to run test cases\n    void run_tests() {\n        \/\/ Test case: n = 29 (expected: prime)\n        n_sig.write(29);\n        wait(1, SC_NS); \/\/ Wait for the process to update\n        bool result = prime_sig.read();\n        std::cout << \"Number \" << n_sig.read() << \" is \" << (result ? \"prime\" : \"NOT prime\") << std::endl;\n        assert(result == true);\n\n        \/\/ Test case: n = 1 (expected: NOT prime)\n        n_sig.write(1);\n        wait(1, SC_NS);\n        result = prime_sig.read();\n        std::cout << \"Number \" << n_sig.read() << \" is \" << (result ? \"prime\" : \"NOT prime\") << std::endl;\n        assert(result == false);\n\n        \/\/ Test case: n = 10 (expected: NOT prime)\n        n_sig.write(10);\n        wait(1, SC_NS);\n        result = prime_sig.read();\n        std::cout << \"Number \" << n_sig.read() << \" is \" << (result ? \"prime\" : \"NOT prime\") << std::endl;\n        assert(result == false);\n\n        \/\/ Test case: n = 13 (expected: prime)\n        n_sig.write(13);\n        wait(1, SC_NS);\n        result = prime_sig.read();\n        std::cout << \"Number \" << n_sig.read() << \" is \" << (result ? \"prime\" : \"NOT prime\") << std::endl;\n        assert(result == true);\n\n        \/\/ End simulation after successful tests\n        std::cout << \"All tests passed successfully.\" << std::endl;\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); \/\/ Instantiate the testbench module\n    sc_start();         \/\/ Start the simulation\n    return 0;\n}\n",
        "signal":"sc_in<int> n;\nsc_out<bool> is_prime;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input.\n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<int> n;\nsc_out<bool> is_prime;\n> **Note**:\n   - Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n   - If the static const are provided, insure to write them in the SystemC code as well.\n\n**C++\/C Code**:\n```\n\/\/ C++ Program to check for prime number using Simple Trial Division\n#include <bits\/stdc++.h>\nusing namespace std;\n\nint main() {\n    int n = 29;\n\n    int cnt = 0;\n\n    \/\/ If number is less than\/equal to 1,\n    \/\/ it is not prime\n    if (n <= 1)\n        cout << n << \" is NOT prime\" << endl;\n    else {\n\n        \/\/ Check for divisors from 1 to n\n        for (int i = 1; i <= n; i++) {\n\n            \/\/ Check how many number is divisible\n            \/\/ by n\n            if (n % i == 0)\n                cnt++;\n        }\n\n        \/\/ If n is divisible by more than 2 numbers\n        \/\/ then it is not prime\n        if (cnt > 2)\n            cout << n << \" is NOT prime\" << endl;\n\n        \/\/ else it is prime\n        else\n            cout << n << \" is prime\" << endl;\n    }\n\n    return 0;\n}\n\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\nFew_shot_example_1:\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        dont_initialize();\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n\nFew_shot_example_2:\n#include <systemc.h>\n\n\/\/ Module: BubbleSort\n\/\/ Sorts a small fixed-size array of integers using the bubble sort algorithm.\nSC_MODULE(BubbleSort) {\n    sc_in<bool>  clk;      \/\/ Clock signal\n    sc_in<bool>  start;    \/\/ Start signal to begin sorting\n    sc_out<bool> done;     \/\/ Signal asserted when sorting is complete\n\n    sc_in<int>   in_arr[4];  \/\/ Input array of 4 integers to be sorted\n    sc_out<int>  out_arr[4]; \/\/ Output array of 4 sorted integers\n\n    int buf[4];  \/\/ Internal buffer to hold array elements during sorting\n\n    \/\/ Constructor: registers the sorting process with the clock\n    SC_CTOR(BubbleSort) {\n        SC_THREAD(sort_proc);\n        sensitive << clk.pos();\n    }\n\n    \/\/ Thread: waits for start, performs bubble sort, writes results, toggles done\n    void sort_proc() {\n        const int N = 4;\n        while (true) {\n            wait();  \/\/ wait for next clock edge\n            if (start.read()) {\n                \/\/ Read inputs into internal buffer\n                for (int i = 0; i < N; ++i)\n                    buf[i] = in_arr[i].read();\n\n                \/\/ Perform bubble sort on buffer[]\n                for (int i = 0; i < N - 1; ++i)\n                    for (int j = 0; j < N - i - 1; ++j)\n                        if (buf[j] > buf[j + 1])\n                            std::swap(buf[j], buf[j + 1]);\n\n                \/\/ Write sorted results to output ports\n                for (int i = 0; i < N; ++i)\n                    out_arr[i].write(buf[i]);\n\n                \/\/ Signal done for one cycle\n                done.write(true);\n                wait();\n                done.write(false);\n            }\n        }\n    }\n};\n\nFew_shot_example_3:\n#include <systemc.h>\n\n\/\/ Module: MatrixAdder\n\/\/ Adds two 4×4 matrices of integers element-wise.\nSC_MODULE(MatrixAdder) {\n    sc_in<int> A[4*4];   \/\/ Flattened 4×4 input matrix A (16 elements)\n    sc_in<int> B[4*4];   \/\/ Flattened 4×4 input matrix B (16 elements)\n    sc_out<int> C[4*4];  \/\/ Flattened 4×4 output matrix C = A + B\n\n    \/\/ Constructor: registers a combinational add method sensitive to all inputs\n    SC_CTOR(MatrixAdder) {\n        SC_METHOD(do_add);\n        \/\/ Make the add method sensitive to every element of A and B\n        for (int i = 0; i < 4*4; i++) {\n            sensitive << A[i] << B[i];\n        }\n    }\n\n    \/\/ Method: reads A[i] and B[i], writes sum into C[i] for all 16 positions\n    void do_add() {\n        for (int i = 0; i < 4*4; i++) {\n            C[i].write(A[i].read() + B[i].read());\n        }\n    }\n};\n\n\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":20,
        "task":"CheckWhetherTwoMatricesAreEqualorNot",
        "code":"\/\/ C++ Program to check if two given matrices are identical \n#include <bits\/stdc++.h> \n#define N 4 \nusing namespace std; \n\n\/\/ This function returns 1 if A[][] \n\/\/ and B[][] are identical otherwise \n\/\/ returns 0 \nint areSame(int A[][N], int B[][N]) \n{ \n\tint i, j; \n\tfor (i = 0; i < N; i++) \n\t\tfor (j = 0; j < N; j++) \n\t\t\tif (A[i][j] != B[i][j]) \n\t\t\t\treturn 0; \n\treturn 1; \n} \n\nint main() \n{ \n\tint A[N][N] = {{1, 1, 1, 1}, \n\t\t\t\t{2, 2, 2, 2}, \n\t\t\t\t{3, 3, 3, 3}, \n\t\t\t\t{4, 4, 4, 4}}; \n\n\tint B[N][N] = {{1, 1, 1, 1}, \n\t\t\t\t{2, 2, 2, 2}, \n\t\t\t\t{3, 3, 3, 3}, \n\t\t\t\t{4, 4, 4, 4}}; \n\n\tif (areSame(A, B)) \n\t\tcout << \"Matrices are identical\"; \n\telse\n\t\tcout << \"Matrices are not identical\"; \n\treturn 0; \n} \n",
        "category":"Matrix Operation",
        "adoption":true,
        "reason":null,
        "module_name":"MatrixComparator",
        "testbench":"SC_MODULE(Testbench) {\n\n    sc_signal<int> A[4*4];\n    sc_signal<int> B[4*4];\n    sc_signal<bool> result;\n\n    MatrixComparator* comparator;\n\n    SC_CTOR(Testbench) {\n        \/\/ Instantiate the MatrixComparator module\n        comparator = new MatrixComparator(\"comparator\");\n        \/\/ Connect signals to the module's ports\n        for (int i = 0; i < 4*4; i++) {\n            comparator->A[i](A[i]);\n            comparator->B[i](B[i]);\n        }\n        comparator->identical(result);\n\n        \/\/ Create a thread to run the test cases\n        SC_THREAD(run_tests);\n    }\n\n    \/\/ Thread that initializes inputs, checks outputs, and asserts correctness\n    void run_tests() {\n        \/\/ Initialize matrices A and B as defined in the original C++ code:\n        \/\/ Matrix A:\n        \/\/   { 1, 1, 1, 1 },\n        \/\/   { 2, 2, 2, 2 },\n        \/\/   { 3, 3, 3, 3 },\n        \/\/   { 4, 4, 4, 4 }\n        \/\/ Matrix B: identical to Matrix A.\n        for (int row = 0; row < 4; row++) {\n            for (int col = 0; col < 4; col++) {\n                int index = row * 4 + col;\n                A[index].write(row + 1); \/\/ For row 0, write 1; row 1, write 2; etc.\n                B[index].write(row + 1);\n            }\n        }\n\n        \/\/ Wait for the signals to propagate and for the comparison to be performed.\n        wait(1, SC_NS);\n\n        \/\/ Check the result and print the output\n        if (result.read() == true) {\n            std::cout << \"Matrices are identical\" << std::endl;\n        } else {\n            std::cout << \"Matrices are not identical\" << std::endl;\n        }\n\n        \/\/ Assert the result is true, as the matrices are identical.\n        assert(result.read() == true);\n        std::cout << \"Test passed successfully\" << std::endl;\n\n        sc_stop(); \/\/ End the simulation\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); \/\/ Create an instance of the Testbench\n    sc_start();         \/\/ Start the simulation\n    return 0;\n}\n",
        "signal":"sc_in<int> A[4*4];\nsc_in<int> B[4*4];\nsc_out<bool> identical;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input.\n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<int> A[4*4];\nsc_in<int> B[4*4];\nsc_out<bool> identical;\n> **Note**:\n   - Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n   - If the static const are provided, insure to write them in the SystemC code as well.\n\n**C++\/C Code**:\n```\n\/\/ C++ Program to check if two given matrices are identical \n#include <bits\/stdc++.h> \n#define N 4 \nusing namespace std; \n\n\/\/ This function returns 1 if A[][] \n\/\/ and B[][] are identical otherwise \n\/\/ returns 0 \nint areSame(int A[][N], int B[][N]) \n{ \n\tint i, j; \n\tfor (i = 0; i < N; i++) \n\t\tfor (j = 0; j < N; j++) \n\t\t\tif (A[i][j] != B[i][j]) \n\t\t\t\treturn 0; \n\treturn 1; \n} \n\nint main() \n{ \n\tint A[N][N] = {{1, 1, 1, 1}, \n\t\t\t\t{2, 2, 2, 2}, \n\t\t\t\t{3, 3, 3, 3}, \n\t\t\t\t{4, 4, 4, 4}}; \n\n\tint B[N][N] = {{1, 1, 1, 1}, \n\t\t\t\t{2, 2, 2, 2}, \n\t\t\t\t{3, 3, 3, 3}, \n\t\t\t\t{4, 4, 4, 4}}; \n\n\tif (areSame(A, B)) \n\t\tcout << \"Matrices are identical\"; \n\telse\n\t\tcout << \"Matrices are not identical\"; \n\treturn 0; \n} \n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\nFew_shot_example_1:\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        dont_initialize();\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n\nFew_shot_example_2:\n#include <systemc.h>\n\n\/\/ Module: BubbleSort\n\/\/ Sorts a small fixed-size array of integers using the bubble sort algorithm.\nSC_MODULE(BubbleSort) {\n    sc_in<bool>  clk;      \/\/ Clock signal\n    sc_in<bool>  start;    \/\/ Start signal to begin sorting\n    sc_out<bool> done;     \/\/ Signal asserted when sorting is complete\n\n    sc_in<int>   in_arr[4];  \/\/ Input array of 4 integers to be sorted\n    sc_out<int>  out_arr[4]; \/\/ Output array of 4 sorted integers\n\n    int buf[4];  \/\/ Internal buffer to hold array elements during sorting\n\n    \/\/ Constructor: registers the sorting process with the clock\n    SC_CTOR(BubbleSort) {\n        SC_THREAD(sort_proc);\n        sensitive << clk.pos();\n    }\n\n    \/\/ Thread: waits for start, performs bubble sort, writes results, toggles done\n    void sort_proc() {\n        const int N = 4;\n        while (true) {\n            wait();  \/\/ wait for next clock edge\n            if (start.read()) {\n                \/\/ Read inputs into internal buffer\n                for (int i = 0; i < N; ++i)\n                    buf[i] = in_arr[i].read();\n\n                \/\/ Perform bubble sort on buffer[]\n                for (int i = 0; i < N - 1; ++i)\n                    for (int j = 0; j < N - i - 1; ++j)\n                        if (buf[j] > buf[j + 1])\n                            std::swap(buf[j], buf[j + 1]);\n\n                \/\/ Write sorted results to output ports\n                for (int i = 0; i < N; ++i)\n                    out_arr[i].write(buf[i]);\n\n                \/\/ Signal done for one cycle\n                done.write(true);\n                wait();\n                done.write(false);\n            }\n        }\n    }\n};\n\nFew_shot_example_3:\n#include <systemc.h>\n\n\/\/ Module: MatrixAdder\n\/\/ Adds two 4×4 matrices of integers element-wise.\nSC_MODULE(MatrixAdder) {\n    sc_in<int> A[4*4];   \/\/ Flattened 4×4 input matrix A (16 elements)\n    sc_in<int> B[4*4];   \/\/ Flattened 4×4 input matrix B (16 elements)\n    sc_out<int> C[4*4];  \/\/ Flattened 4×4 output matrix C = A + B\n\n    \/\/ Constructor: registers a combinational add method sensitive to all inputs\n    SC_CTOR(MatrixAdder) {\n        SC_METHOD(do_add);\n        \/\/ Make the add method sensitive to every element of A and B\n        for (int i = 0; i < 4*4; i++) {\n            sensitive << A[i] << B[i];\n        }\n    }\n\n    \/\/ Method: reads A[i] and B[i], writes sum into C[i] for all 16 positions\n    void do_add() {\n        for (int i = 0; i < 4*4; i++) {\n            C[i].write(A[i].read() + B[i].read());\n        }\n    }\n};\n\n\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":21,
        "task":"ComputetheSumofDiagonalsofaMatrix",
        "code":"\/\/ A simple C++ program to find sum of diagonals \n#include <bits\/stdc++.h> \nusing namespace std; \n\nconst int MAX = 100; \n\nvoid printDiagonalSums(int mat[][MAX], int n) \n{ \n\tint principal = 0, secondary = 0; \n\tfor (int i = 0; i < n; i++) \n\t{ \n\t\tfor (int j = 0; j < n; j++)\t \n\t\t{ \n\t\t\t\/\/ Condition for principal diagonal \n\t\t\tif (i == j) \n\t\t\t\tprincipal += mat[i][j]; \n\n\t\t\t\/\/ Condition for secondary diagonal \n\t\t\tif ((i + j) == (n - 1)) \n\t\t\t\tsecondary += mat[i][j]; \n\t\t} \n\t} \n\n\tcout << \"Principal Diagonal:\" << \n\t\t\tprincipal << endl; \n\tcout << \"Secondary Diagonal:\" << \n\t\t\tsecondary << endl; \n} \n\n\/\/ Driver code \nint main() \n{ \n\tint a[][MAX] = {{1, 2, 3, 4}, \n\t\t\t\t\t{5, 6, 7, 8}, \n\t\t\t\t\t{1, 2, 3, 4}, \n\t\t\t\t\t{5, 6, 7, 8}}; \n\tprintDiagonalSums(a, 4); \n\treturn 0; \n} \n",
        "category":"Matrix Operation",
        "adoption":true,
        "reason":null,
        "module_name":"DiagonalSum",
        "testbench":"SC_MODULE(Testbench) {\n\n    \/\/ Signals for the flattened matrix and the outputs\n    sc_signal<int> matrix[4*4];\n    sc_signal<int> principal;\n    sc_signal<int> secondary;\n\n    \/\/ Instance of the DiagonalSum module\n    DiagonalSum* diagSum;\n\n    SC_CTOR(Testbench) {\n        \/\/ Instantiate the DiagonalSum module\n        diagSum = new DiagonalSum(\"diagSum\");\n        \/\/ Connect the matrix signals and outputs\n        for (int i = 0; i < 4*4; i++) {\n            diagSum->matrix[i](matrix[i]);\n        }\n        diagSum->principal(principal);\n        diagSum->secondary(secondary);\n\n        \/\/ Start the test thread\n        SC_THREAD(run_tests);\n    }\n\n    \/\/ Thread to initialize inputs, check outputs, and assert correctness\n    void run_tests() {\n        \/\/ Initialize the matrix as defined in the original C++ code:\n        \/\/  Matrix:\n        \/\/      {1, 2, 3, 4},\n        \/\/      {5, 6, 7, 8},\n        \/\/      {1, 2, 3, 4},\n        \/\/      {5, 6, 7, 8}\n        int mat[4][4] = {\n            {1, 2, 3, 4},\n            {5, 6, 7, 8},\n            {1, 2, 3, 4},\n            {5, 6, 7, 8}\n        };\n\n        \/\/ Write the matrix values to the flattened signal array\n        for (int i = 0; i < 4; i++) {\n            for (int j = 0; j < 4; j++) {\n                int index = i * 4 + j;\n                matrix[index].write(mat[i][j]);\n            }\n        }\n\n        \/\/ Wait for a small time to let the combinational logic settle\n        wait(1, SC_NS);\n\n        \/\/ Expected sums computed manually:\n        \/\/ Principal diagonal: 1 + 6 + 3 + 8 = 18\n        \/\/ Secondary diagonal: 4 + 7 + 2 + 5 = 18\n        int expected_principal = 18;\n        int expected_secondary = 18;\n\n        \/\/ Read the computed outputs\n        int computed_principal = principal.read();\n        int computed_secondary = secondary.read();\n\n        \/\/ Print the results\n        std::cout << \"Principal Diagonal Sum: \" << computed_principal << std::endl;\n        std::cout << \"Secondary Diagonal Sum: \" << computed_secondary << std::endl;\n\n        \/\/ Assert that the computed sums match the expected values\n        assert(computed_principal == expected_principal);\n        assert(computed_secondary == expected_secondary);\n        std::cout << \"All tests passed successfully.\" << std::endl;\n\n        sc_stop(); \/\/ Stop the simulation\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); \/\/ Create the testbench instance\n    sc_start();         \/\/ Start simulation\n    return 0;\n}\n",
        "signal":"sc_in<int> matrix[4*4];\nsc_out<int> principal;\nsc_out<int> secondary;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input.\n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<int> matrix[4*4];\nsc_out<int> principal;\nsc_out<int> secondary;\n> **Note**:\n   - Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n   - If the static const are provided, insure to write them in the SystemC code as well.\n\n**C++\/C Code**:\n```\n\/\/ A simple C++ program to find sum of diagonals \n#include <bits\/stdc++.h> \nusing namespace std; \n\nconst int MAX = 100; \n\nvoid printDiagonalSums(int mat[][MAX], int n) \n{ \n\tint principal = 0, secondary = 0; \n\tfor (int i = 0; i < n; i++) \n\t{ \n\t\tfor (int j = 0; j < n; j++)\t \n\t\t{ \n\t\t\t\/\/ Condition for principal diagonal \n\t\t\tif (i == j) \n\t\t\t\tprincipal += mat[i][j]; \n\n\t\t\t\/\/ Condition for secondary diagonal \n\t\t\tif ((i + j) == (n - 1)) \n\t\t\t\tsecondary += mat[i][j]; \n\t\t} \n\t} \n\n\tcout << \"Principal Diagonal:\" << \n\t\t\tprincipal << endl; \n\tcout << \"Secondary Diagonal:\" << \n\t\t\tsecondary << endl; \n} \n\n\/\/ Driver code \nint main() \n{ \n\tint a[][MAX] = {{1, 2, 3, 4}, \n\t\t\t\t\t{5, 6, 7, 8}, \n\t\t\t\t\t{1, 2, 3, 4}, \n\t\t\t\t\t{5, 6, 7, 8}}; \n\tprintDiagonalSums(a, 4); \n\treturn 0; \n} \n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\nFew_shot_example_1:\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        dont_initialize();\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n\nFew_shot_example_2:\n#include <systemc.h>\n\n\/\/ Module: BubbleSort\n\/\/ Sorts a small fixed-size array of integers using the bubble sort algorithm.\nSC_MODULE(BubbleSort) {\n    sc_in<bool>  clk;      \/\/ Clock signal\n    sc_in<bool>  start;    \/\/ Start signal to begin sorting\n    sc_out<bool> done;     \/\/ Signal asserted when sorting is complete\n\n    sc_in<int>   in_arr[4];  \/\/ Input array of 4 integers to be sorted\n    sc_out<int>  out_arr[4]; \/\/ Output array of 4 sorted integers\n\n    int buf[4];  \/\/ Internal buffer to hold array elements during sorting\n\n    \/\/ Constructor: registers the sorting process with the clock\n    SC_CTOR(BubbleSort) {\n        SC_THREAD(sort_proc);\n        sensitive << clk.pos();\n    }\n\n    \/\/ Thread: waits for start, performs bubble sort, writes results, toggles done\n    void sort_proc() {\n        const int N = 4;\n        while (true) {\n            wait();  \/\/ wait for next clock edge\n            if (start.read()) {\n                \/\/ Read inputs into internal buffer\n                for (int i = 0; i < N; ++i)\n                    buf[i] = in_arr[i].read();\n\n                \/\/ Perform bubble sort on buffer[]\n                for (int i = 0; i < N - 1; ++i)\n                    for (int j = 0; j < N - i - 1; ++j)\n                        if (buf[j] > buf[j + 1])\n                            std::swap(buf[j], buf[j + 1]);\n\n                \/\/ Write sorted results to output ports\n                for (int i = 0; i < N; ++i)\n                    out_arr[i].write(buf[i]);\n\n                \/\/ Signal done for one cycle\n                done.write(true);\n                wait();\n                done.write(false);\n            }\n        }\n    }\n};\n\nFew_shot_example_3:\n#include <systemc.h>\n\n\/\/ Module: MatrixAdder\n\/\/ Adds two 4×4 matrices of integers element-wise.\nSC_MODULE(MatrixAdder) {\n    sc_in<int> A[4*4];   \/\/ Flattened 4×4 input matrix A (16 elements)\n    sc_in<int> B[4*4];   \/\/ Flattened 4×4 input matrix B (16 elements)\n    sc_out<int> C[4*4];  \/\/ Flattened 4×4 output matrix C = A + B\n\n    \/\/ Constructor: registers a combinational add method sensitive to all inputs\n    SC_CTOR(MatrixAdder) {\n        SC_METHOD(do_add);\n        \/\/ Make the add method sensitive to every element of A and B\n        for (int i = 0; i < 4*4; i++) {\n            sensitive << A[i] << B[i];\n        }\n    }\n\n    \/\/ Method: reads A[i] and B[i], writes sum into C[i] for all 16 positions\n    void do_add() {\n        for (int i = 0; i < 4*4; i++) {\n            C[i].write(A[i].read() + B[i].read());\n        }\n    }\n};\n\n\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":22,
        "task":"CopyAlltheElementsofOneArraytoAnotherintheReverseOrder",
        "code":"\/\/ C program to copy the contents \n\/\/ of one array into another \n\/\/ in the reverse order \n\n#include <stdio.h> \n\n\/\/ Function to print the array \nvoid printArray(int arr[], int len) \n{ \n\tint i; \n\tfor (i = 0; i < len; i++) { \n\t\tprintf(\"%d \", arr[i]); \n\t} \n} \n\n\/\/ Driver code \nint main() \n{ \n\tint original_arr[] = {1, 2, 3, 4, 5}; \n\tint len = sizeof(original_arr)\/sizeof(original_arr[0]); \n\n\tint copied_arr[len], i, j; \n\t\n\t\/\/ Copy the elements of the array \n\t\/\/ in the copied_arr in Reverse Order \n\tfor (i = 0; i < len; i++) { \n\t\tcopied_arr[i] = original_arr[len - i - 1]; \n\t} \n\n\t\/\/ Print the original_arr \n\tprintf(\" Original array: \"); \n\tprintArray(original_arr, len); \n\n\t\/\/ Print the copied array \n\tprintf(\" Resultant array: \"); \n\tprintArray(copied_arr, len); \n\n\treturn 0; \n} \n",
        "category":"Array Operation",
        "adoption":true,
        "reason":null,
        "module_name":"ArrayReverse",
        "testbench":"SC_MODULE(Testbench) {\n    sc_clock        clk{\"clk\", 1, SC_NS};\n    sc_signal<bool> start, done;\n    sc_signal<int>  sig_in[5], sig_out[5];\n\n    ArrayReverse*   dut;\n\n    SC_CTOR(Testbench) {\n        dut = new ArrayReverse(\"ArrayReverse\");\n        dut->clk(clk);\n        dut->start(start);\n        dut->done(done);\n        for (int i = 0; i < 5; ++i) {\n            dut->in_arr[i](sig_in[i]);\n            dut->out_arr[i](sig_out[i]);\n        }\n\n        SC_THREAD(run_tests);   \/\/ 無需 static sensitivity\n    }\n\n    void run_tests() {\n        int original[5] = {1, 2, 3, 4, 5};\n        int expected[5] = {5, 4, 3, 2, 1};\n\n        \/* ▸ 驅動輸入 *\/\n        for (int i = 0; i < 5; ++i)\n            sig_in[i].write(original[i]);\n\n        \/* ▸ 觸發反轉 *\/\n        wait(clk.posedge_event());\n        start.write(true);\n        wait(clk.posedge_event());\n        start.write(false);\n\n        \/* ▸ 等待 done=1 *\/\n        wait(done.posedge_event());\n\n        \/* ▸ 讀取結果並驗證 *\/\n        std::cout << \"Reversed Array: \";\n        for (int i = 0; i < 5; ++i) {\n            int val = sig_out[i].read();\n            std::cout << val << \" \";\n            assert(val == expected[i]);\n        }\n        std::cout << \"\\nAll tests passed successfully.\\n\";\n\n        sc_stop();\n    }\n};\n\n\/\/ ───────────────────── sc_main ─────────────────────\nint sc_main(int argc, char* argv[]) {\n    Testbench tb{\"tb\"};\n    sc_start();\n    return 0;\n}\n",
        "signal":"sc_in<bool>  clk;\nsc_in<bool>  start;\nsc_out<bool> done;\nsc_in<int>   in_arr[5];\nsc_out<int>  out_arr[5];",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input.\n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<bool>  clk;\nsc_in<bool>  start;\nsc_out<bool> done;\nsc_in<int>   in_arr[5];\nsc_out<int>  out_arr[5];\n> **Note**:\n   - Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n   - If the static const are provided, insure to write them in the SystemC code as well.\n\n**C++\/C Code**:\n```\n\/\/ C program to copy the contents \n\/\/ of one array into another \n\/\/ in the reverse order \n\n#include <stdio.h> \n\n\/\/ Function to print the array \nvoid printArray(int arr[], int len) \n{ \n\tint i; \n\tfor (i = 0; i < len; i++) { \n\t\tprintf(\"%d \", arr[i]); \n\t} \n} \n\n\/\/ Driver code \nint main() \n{ \n\tint original_arr[] = {1, 2, 3, 4, 5}; \n\tint len = sizeof(original_arr)\/sizeof(original_arr[0]); \n\n\tint copied_arr[len], i, j; \n\t\n\t\/\/ Copy the elements of the array \n\t\/\/ in the copied_arr in Reverse Order \n\tfor (i = 0; i < len; i++) { \n\t\tcopied_arr[i] = original_arr[len - i - 1]; \n\t} \n\n\t\/\/ Print the original_arr \n\tprintf(\" Original array: \"); \n\tprintArray(original_arr, len); \n\n\t\/\/ Print the copied array \n\tprintf(\" Resultant array: \"); \n\tprintArray(copied_arr, len); \n\n\treturn 0; \n} \n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\nFew_shot_example_1:\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        dont_initialize();\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n\nFew_shot_example_2:\n#include <systemc.h>\n\n\/\/ Module: BubbleSort\n\/\/ Sorts a small fixed-size array of integers using the bubble sort algorithm.\nSC_MODULE(BubbleSort) {\n    sc_in<bool>  clk;      \/\/ Clock signal\n    sc_in<bool>  start;    \/\/ Start signal to begin sorting\n    sc_out<bool> done;     \/\/ Signal asserted when sorting is complete\n\n    sc_in<int>   in_arr[4];  \/\/ Input array of 4 integers to be sorted\n    sc_out<int>  out_arr[4]; \/\/ Output array of 4 sorted integers\n\n    int buf[4];  \/\/ Internal buffer to hold array elements during sorting\n\n    \/\/ Constructor: registers the sorting process with the clock\n    SC_CTOR(BubbleSort) {\n        SC_THREAD(sort_proc);\n        sensitive << clk.pos();\n    }\n\n    \/\/ Thread: waits for start, performs bubble sort, writes results, toggles done\n    void sort_proc() {\n        const int N = 4;\n        while (true) {\n            wait();  \/\/ wait for next clock edge\n            if (start.read()) {\n                \/\/ Read inputs into internal buffer\n                for (int i = 0; i < N; ++i)\n                    buf[i] = in_arr[i].read();\n\n                \/\/ Perform bubble sort on buffer[]\n                for (int i = 0; i < N - 1; ++i)\n                    for (int j = 0; j < N - i - 1; ++j)\n                        if (buf[j] > buf[j + 1])\n                            std::swap(buf[j], buf[j + 1]);\n\n                \/\/ Write sorted results to output ports\n                for (int i = 0; i < N; ++i)\n                    out_arr[i].write(buf[i]);\n\n                \/\/ Signal done for one cycle\n                done.write(true);\n                wait();\n                done.write(false);\n            }\n        }\n    }\n};\n\nFew_shot_example_3:\n#include <systemc.h>\n\n\/\/ Module: MatrixAdder\n\/\/ Adds two 4×4 matrices of integers element-wise.\nSC_MODULE(MatrixAdder) {\n    sc_in<int> A[4*4];   \/\/ Flattened 4×4 input matrix A (16 elements)\n    sc_in<int> B[4*4];   \/\/ Flattened 4×4 input matrix B (16 elements)\n    sc_out<int> C[4*4];  \/\/ Flattened 4×4 output matrix C = A + B\n\n    \/\/ Constructor: registers a combinational add method sensitive to all inputs\n    SC_CTOR(MatrixAdder) {\n        SC_METHOD(do_add);\n        \/\/ Make the add method sensitive to every element of A and B\n        for (int i = 0; i < 4*4; i++) {\n            sensitive << A[i] << B[i];\n        }\n    }\n\n    \/\/ Method: reads A[i] and B[i], writes sum into C[i] for all 16 positions\n    void do_add() {\n        for (int i = 0; i < 4*4; i++) {\n            C[i].write(A[i].read() + B[i].read());\n        }\n    }\n};\n\n\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":23,
        "task":"DecimaltoBinaryConversion",
        "code":"\/\/ C++ program to convert a decimal number to binary number\n#include <iostream>\nusing namespace std;\n\n\/\/ Function to convert decimal\n\/\/ to binary\nvoid decToBinary(int n)\n{\n\t\/\/ Array to store binary number\n\tint binaryNum[32];\n\n\t\/\/ Counter for binary array\n\tint i = 0;\n\twhile (n > 0) {\n\t\t\/\/ Storing remainder in binary\n\t\t\/\/ array\n\t\tbinaryNum[i] = n % 2;\n\t\tn = n \/ 2;\n\t\ti++;\n\t}\n\n\t\/\/ Printing binary array in reverse\n\t\/\/ order\n\tfor (int j = i - 1; j >= 0; j--)\n\t\tcout << binaryNum[j];\n}\n\n\/\/ Driver code\nint main()\n{\n\tint n = 10;\n\tdecToBinary(n);\n\treturn 0;\n}\n",
        "category":"Basic Math",
        "adoption":true,
        "reason":null,
        "module_name":"DecToBinary",
        "testbench":"SC_MODULE(Testbench) {\n    sc_signal<int> dec_sig;    \/\/ Signal for the decimal input\n    sc_signal<int> bin_sig;    \/\/ Signal for the binary output\n\n    DecToBinary* dec_to_binary_inst;  \/\/ Instance of the conversion module\n\n    SC_CTOR(Testbench) {\n        \/\/ Instantiate the DecToBinary module and connect signals\n        dec_to_binary_inst = new DecToBinary(\"DecToBinary\");\n        dec_to_binary_inst->dec_in(dec_sig);\n        dec_to_binary_inst->binary_out(bin_sig);\n\n        SC_THREAD(run_tests);   \/\/ Launch test cases in a thread\n    }\n\n    void run_tests() {\n        \/\/ Test Case: Input n = 10 should result in binary 1010\n        dec_sig.write(10);\n        wait(1, SC_NS);  \/\/ Wait for the process to trigger\n\n        int result = bin_sig.read();\n        std::cout << \"Input: 10, Binary Output: \" << result << std::endl;\n        assert(result == 1010);\n\n        \/\/ Test Case: Input n = 0 should result in binary 0\n        dec_sig.write(0);\n        wait(1, SC_NS);  \/\/ Wait for the process to trigger\n\n        int result2 = bin_sig.read();\n        std::cout << \"Input: 0, Binary Output: \" << result2 << std::endl;\n        assert(result2 == 0);\n\n        \/\/ Test Case: Input n = 1000 should result in binary 1111101000\n        dec_sig.write(1000);\n        wait(1, SC_NS);  \/\/ Wait for the process to trigger\n        int result3 = bin_sig.read();\n        std::cout << \"Input: 1000, Binary Output: \" << result3 << std::endl;\n        assert(result3 == 1111101000);\n\n        \/\/ Print success message and stop simulation\n        std::cout << \"Test passed successfully.\" << std::endl;\n        sc_stop();\n    }\n\n    \/\/ Destructor to free allocated memory\n    ~Testbench() {\n        delete dec_to_binary_inst;\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\");  \/\/ Create an instance of the Testbench module\n    sc_start();          \/\/ Start the simulation\n    return 0;\n}\n",
        "signal":"sc_in<int> dec_in;\nsc_out<int> binary_out;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input.\n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<int> dec_in;\nsc_out<int> binary_out;\n> **Note**:\n   - Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n   - If the static const are provided, insure to write them in the SystemC code as well.\n\n**C++\/C Code**:\n```\n\/\/ C++ program to convert a decimal number to binary number\n#include <iostream>\nusing namespace std;\n\n\/\/ Function to convert decimal\n\/\/ to binary\nvoid decToBinary(int n)\n{\n\t\/\/ Array to store binary number\n\tint binaryNum[32];\n\n\t\/\/ Counter for binary array\n\tint i = 0;\n\twhile (n > 0) {\n\t\t\/\/ Storing remainder in binary\n\t\t\/\/ array\n\t\tbinaryNum[i] = n % 2;\n\t\tn = n \/ 2;\n\t\ti++;\n\t}\n\n\t\/\/ Printing binary array in reverse\n\t\/\/ order\n\tfor (int j = i - 1; j >= 0; j--)\n\t\tcout << binaryNum[j];\n}\n\n\/\/ Driver code\nint main()\n{\n\tint n = 10;\n\tdecToBinary(n);\n\treturn 0;\n}\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\nFew_shot_example_1:\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        dont_initialize();\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n\nFew_shot_example_2:\n#include <systemc.h>\n\n\/\/ Module: BubbleSort\n\/\/ Sorts a small fixed-size array of integers using the bubble sort algorithm.\nSC_MODULE(BubbleSort) {\n    sc_in<bool>  clk;      \/\/ Clock signal\n    sc_in<bool>  start;    \/\/ Start signal to begin sorting\n    sc_out<bool> done;     \/\/ Signal asserted when sorting is complete\n\n    sc_in<int>   in_arr[4];  \/\/ Input array of 4 integers to be sorted\n    sc_out<int>  out_arr[4]; \/\/ Output array of 4 sorted integers\n\n    int buf[4];  \/\/ Internal buffer to hold array elements during sorting\n\n    \/\/ Constructor: registers the sorting process with the clock\n    SC_CTOR(BubbleSort) {\n        SC_THREAD(sort_proc);\n        sensitive << clk.pos();\n    }\n\n    \/\/ Thread: waits for start, performs bubble sort, writes results, toggles done\n    void sort_proc() {\n        const int N = 4;\n        while (true) {\n            wait();  \/\/ wait for next clock edge\n            if (start.read()) {\n                \/\/ Read inputs into internal buffer\n                for (int i = 0; i < N; ++i)\n                    buf[i] = in_arr[i].read();\n\n                \/\/ Perform bubble sort on buffer[]\n                for (int i = 0; i < N - 1; ++i)\n                    for (int j = 0; j < N - i - 1; ++j)\n                        if (buf[j] > buf[j + 1])\n                            std::swap(buf[j], buf[j + 1]);\n\n                \/\/ Write sorted results to output ports\n                for (int i = 0; i < N; ++i)\n                    out_arr[i].write(buf[i]);\n\n                \/\/ Signal done for one cycle\n                done.write(true);\n                wait();\n                done.write(false);\n            }\n        }\n    }\n};\n\nFew_shot_example_3:\n#include <systemc.h>\n\n\/\/ Module: MatrixAdder\n\/\/ Adds two 4×4 matrices of integers element-wise.\nSC_MODULE(MatrixAdder) {\n    sc_in<int> A[4*4];   \/\/ Flattened 4×4 input matrix A (16 elements)\n    sc_in<int> B[4*4];   \/\/ Flattened 4×4 input matrix B (16 elements)\n    sc_out<int> C[4*4];  \/\/ Flattened 4×4 output matrix C = A + B\n\n    \/\/ Constructor: registers a combinational add method sensitive to all inputs\n    SC_CTOR(MatrixAdder) {\n        SC_METHOD(do_add);\n        \/\/ Make the add method sensitive to every element of A and B\n        for (int i = 0; i < 4*4; i++) {\n            sensitive << A[i] << B[i];\n        }\n    }\n\n    \/\/ Method: reads A[i] and B[i], writes sum into C[i] for all 16 positions\n    void do_add() {\n        for (int i = 0; i < 4*4; i++) {\n            C[i].write(A[i].read() + B[i].read());\n        }\n    }\n};\n\n\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":24,
        "task":"DecimaltoHexadecimalConversion",
        "code":"\/\/ C++ program to convert a decimal number to hexadecimal number \n#include <iostream> \nusing namespace std; \n\n\/\/ Function to convert decimal to hexadecimal \nvoid decToHexa(int n) \n{ \n\t\/\/ char array to store hexadecimal number \n\tchar hexaDeciNum[100]; \n\n\t\/\/ Counter for hexadecimal number array \n\tint i = 0; \n\twhile (n != 0) { \n\t\t\/\/ Temporary variable to store remainder \n\t\tint temp = 0; \n\n\t\t\/\/ Storing remainder in temp variable. \n\t\ttemp = n % 16; \n\n\t\t\/\/ Check if temp < 10 \n\t\tif (temp < 10) { \n\t\t\thexaDeciNum[i] = temp + 48; \n\t\t\ti++; \n\t\t} \n\t\telse { \n\t\t\thexaDeciNum[i] = temp + 55; \n\t\t\ti++; \n\t\t} \n\n\t\tn = n \/ 16; \n\t} \n\n\t\/\/ Printing hexadecimal number \n\t\/\/ array in reverse order \n\tfor (int j = i - 1; j >= 0; j--) \n\t\tcout << hexaDeciNum[j]; \n} \n\n\/\/ Driver code \nint main() \n{ \n\tint n = 2545; \n\tdecToHexa(n); \n\treturn 0; \n}\n",
        "category":"Basic Math",
        "adoption":false,
        "reason":null,
        "module_name":null,
        "testbench":null,
        "signal":null,
        "prompt":null
    },
    {
        "task_id":25,
        "task":"DecimaltoOctalConversion",
        "code":"\/\/ C++ program to convert a decimal number to octal number \n#include <iostream> \nusing namespace std; \n\n\/\/ Function to convert decimal to octal \nvoid decToOctal(int n) \n{ \n\t\/\/ Array to store octal number \n\tint octalNum[100]; \n\n\t\/\/ Counter for octal number array \n\tint i = 0; \n\twhile (n != 0) { \n\t\t\/\/ Storing remainder in octal array \n\t\toctalNum[i] = n % 8; \n\t\tn = n \/ 8; \n\t\ti++; \n\t} \n\n\t\/\/ Printing octal number array in \n\t\/\/ reverse order \n\tfor (int j = i - 1; j >= 0; j--) \n\t\tcout << octalNum[j]; \n} \n\n\/\/ Driver Code \nint main() \n{ \n\tint n = 33; \n\n\t\/\/ Function Call \n\tdecToOctal(n); \n\n\treturn 0; \n}\n",
        "category":"Basic Math",
        "adoption":false,
        "reason":null,
        "module_name":null,
        "testbench":null,
        "signal":null,
        "prompt":null
    },
    {
        "task_id":26,
        "task":"DisplayArmstrongNumbersBetween1to1000",
        "code":"\/\/ C++ program to find Armstrong numbers between 1 to 1000 using a brute force approach\n#include <bits\/stdc++.h>\nusing namespace std;\n\n\/\/ Function to return the order of a number.\nint order(int num)\n{\n\tint count = 0;\n\twhile (num > 0)\n\t{\n\t\tnum \/= 10;\n\t\tcount++;\n\t}\n\treturn count;\n}\n\n\/\/ Function to check whether thegiven number is Armstrong numberor not\nbool isArmstrong(int num)\n{\n\tint order_n = order(num);\n\tint num_temp = num, sum = 0;\n\n\twhile (num_temp > 0)\n\t{\n\t\tint curr = num_temp % 10;\n\t\tsum += pow(curr, order_n);\n\t\tnum_temp \/= 10;\n\t}\n\tif (sum == num)\n\t{\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n\n\/\/ Driver code\nint main()\n{\n\n\tcout << \"Armstrong numbers between 1 to 1000 : \";\n\t\/\/ Loop which will run from 1 to 1000\n\tfor (int num = 1; num <= 1000; ++num)\n\t{\n\n\t\tif (isArmstrong(num))\n\t\t{\n\t\t\tcout << num << \" \";\n\t\t}\n\t}\n\treturn 0;\n}\n",
        "category":"Basic Math",
        "adoption":false,
        "reason":null,
        "module_name":null,
        "testbench":null,
        "signal":null,
        "prompt":null
    },
    {
        "task_id":27,
        "task":"DisplayFactorsofaNaturalNumber",
        "code":"\/\/ C++ implementation of Naive method to print all divisors \n#include <iostream> \nusing namespace std; \n\n\/\/ Function to print the divisors \nvoid printDivisors(int n) \n{ \n\tfor (int i = 1; i <= n; i++) \n\t\tif (n % i == 0) \n\t\t\tcout <<\" \" << i; \n} \n\n\/\/ Driver code \nint main() \n{ \n\tcout <<\"The divisors of 100 are: \"; \n\tprintDivisors(100); \n\treturn 0; \n} \n\n\/\/ This code is contributed by shivanisinghss2110\n",
        "category":"Basic Math",
        "adoption":false,
        "reason":null,
        "module_name":null,
        "testbench":null,
        "signal":null,
        "prompt":null
    },
    {
        "task_id":28,
        "task":"DisplayPrimeNumbersBetweenTwoIntervals",
        "code":"\/\/ C++ program to find the prime numbers between a given interval\n#include <bits\/stdc++.h>\nusing namespace std;\n\n\/\/ Driver code\nint main()\n{\n    \/\/ Declare the variables\n    int a, b, i, j, flag;\n\n    \/\/ Ask user to enter lower value\n    \/\/ of interval\n    cout << \"Enter lower bound of the interval: \";\n\n    \/\/ Take input\n    \/\/ cin >> a;\n    a = 100;\n\n    \/\/ Ask user to enter upper value\n    \/\/ of interval\n    cout << \"Enter upper bound of the interval: \";\n\n    \/\/ Take input\n    \/\/ cin >> b;\n    b = 300;\n    \/\/ Print display message\n    cout << \"Prime numbers between \" << a << \" and \" << b\n         << \" are: \";\n\n    \/\/ Traverse each number in the interval\n    \/\/ with the help of for loop\n    for (i = a; i <= b; i++) {\n        \/\/ Skip 0 and 1 as they are\n        \/\/ neither prime nor composite\n        if (i == 1 || i == 0)\n            continue;\n\n        \/\/ flag variable to tell\n        \/\/ if i is prime or not\n        flag = 1;\n\n        for (j = 2; j <= i \/ 2; ++j) {\n            if (i % j == 0) {\n                flag = 0;\n                break;\n            }\n        }\n\n        \/\/ flag = 1 means i is prime\n        \/\/ and flag = 0 means i is not prime\n        if (flag == 1)\n            cout << i << \" \";\n    }\n\n    return 0;\n}\n",
        "category":"Basic Math",
        "adoption":false,
        "reason":null,
        "module_name":null,
        "testbench":null,
        "signal":null,
        "prompt":null
    },
    {
        "task_id":29,
        "task":"DisplayPrimeNumbersBetweenTwoIntervalsUsingFunction",
        "code":"\/\/ C Program to Find Prime Numbers in a Given Range using Trial Division method\n#include <stdbool.h>\n#include <stdio.h>\n\nbool isPrime(int n) {\n\n    \/\/ Checking primality by finding a complete division\n      \/\/ in the range 2 to n-1\n    if (n <= 1)\n        return false;\n    for (int i = 2; i < n; i++) {\n        if (n % i == 0)\n            return false;\n    }\n    return true;\n}\n\nvoid findPrimes(int l, int r) {\n\n    \/\/ Flag to check if any prime numbers are found\n    bool found = false;\n    for (int i = l; i <= r; i++) {\n\n        \/\/ Checking if the number is prime\n        if (isPrime(i)) {\n            printf(\"%d \", i);\n            found = true;\n        }\n    }\n    if (!found) {\n        printf(\n            \"No prime numbers found in the given range.\");\n    }\n}\n\nint main() {\n    int l = 10, r = 30;\n    \n      \/\/ Finding and printing the prime between [l, r]\n    findPrimes(l, r);\n  \n    return 0;\n}\n",
        "category":"Basic Math",
        "adoption":false,
        "reason":null,
        "module_name":null,
        "testbench":null,
        "signal":null,
        "prompt":null
    },
    {
        "task_id":30,
        "task":"FibonacciNumber",
        "code":"\/\/ C++ Program to find the nth fibonacci number using loops\n#include <bits\/stdc++.h>\nusing namespace std;\n\nint fib(int n) {\n  \n      \/\/ For 0th and 1st term\n    if (n <= 1)\n        return n;\n    \n      \/\/ Variable to store the last two terms\n    int prev1 = 1, prev2 = 0;\n      \n      \/\/ Variable that stores the current fibonacci term\n      int curr;\n\n    \/\/ Calculating the next fibonacci number by using\n      \/\/ the previous two number\n    for (int i = 2; i <= n; i++) {\n        curr = prev1 + prev2;\n        prev2 = prev1;\n        prev1 = curr;\n    }\n    return curr;\n}\n\nint main() {\n    int n = 5;\n    \n      \/\/ Finding the nth fibonacci number\n    cout << fib(n);\n    return 0;\n}\n",
        "category":"Basic Math",
        "adoption":true,
        "reason":null,
        "module_name":"FibonacciCalculator",
        "testbench":"SC_MODULE(Testbench) {\n    sc_signal<int> n_sig;          \/\/ Signal for the input position\n    sc_signal<int> result_sig;      \/\/ Signal for the output Fibonacci number\n\n    \/\/ Instance of the FibonacciCalculator module\n    FibonacciCalculator fib_inst;\n\n    \/\/ Constructor: Initialize the module and run the test thread\n    SC_CTOR(Testbench)\n    : fib_inst(\"fib_inst\") {\n        \/\/ Connect signals to module ports\n        fib_inst.n(n_sig);\n        fib_inst.result(result_sig);\n\n        \/\/ Create a test thread to provide stimulus and check the result\n        SC_THREAD(run_tests);\n    }\n\n    \/\/ Thread to run test cases\n    void run_tests() {\n        \/\/ Test case: n = 5 (expected Fibonacci number = 5)\n        n_sig.write(5);\n        wait(1, SC_NS); \/\/ Wait for the process to update\n        int result = result_sig.read();\n        std::cout << \"Fibonacci number at position \" << n_sig.read() << \" is \" << result << std::endl;\n        assert(result == 5);\n\n        \/\/ Additional test case: n = 10 (expected Fibonacci number = 55)\n        n_sig.write(10);\n        wait(1, SC_NS);\n        result = result_sig.read();\n        std::cout << \"Fibonacci number at position \" << n_sig.read() << \" is \" << result << std::endl;\n        assert(result == 55);\n\n        \/\/ End simulation after successful tests\n        std::cout << \"All tests passed successfully.\" << std::endl;\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); \/\/ Instantiate the testbench module\n    sc_start();         \/\/ Start the simulation\n    return 0;\n}\n",
        "signal":"sc_in<int> n;\nsc_out<int> result;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input.\n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<int> n;\nsc_out<int> result;\n> **Note**:\n   - Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n   - If the static const are provided, insure to write them in the SystemC code as well.\n\n**C++\/C Code**:\n```\n\/\/ C++ Program to find the nth fibonacci number using loops\n#include <bits\/stdc++.h>\nusing namespace std;\n\nint fib(int n) {\n  \n      \/\/ For 0th and 1st term\n    if (n <= 1)\n        return n;\n    \n      \/\/ Variable to store the last two terms\n    int prev1 = 1, prev2 = 0;\n      \n      \/\/ Variable that stores the current fibonacci term\n      int curr;\n\n    \/\/ Calculating the next fibonacci number by using\n      \/\/ the previous two number\n    for (int i = 2; i <= n; i++) {\n        curr = prev1 + prev2;\n        prev2 = prev1;\n        prev1 = curr;\n    }\n    return curr;\n}\n\nint main() {\n    int n = 5;\n    \n      \/\/ Finding the nth fibonacci number\n    cout << fib(n);\n    return 0;\n}\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\nFew_shot_example_1:\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        dont_initialize();\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n\nFew_shot_example_2:\n#include <systemc.h>\n\n\/\/ Module: BubbleSort\n\/\/ Sorts a small fixed-size array of integers using the bubble sort algorithm.\nSC_MODULE(BubbleSort) {\n    sc_in<bool>  clk;      \/\/ Clock signal\n    sc_in<bool>  start;    \/\/ Start signal to begin sorting\n    sc_out<bool> done;     \/\/ Signal asserted when sorting is complete\n\n    sc_in<int>   in_arr[4];  \/\/ Input array of 4 integers to be sorted\n    sc_out<int>  out_arr[4]; \/\/ Output array of 4 sorted integers\n\n    int buf[4];  \/\/ Internal buffer to hold array elements during sorting\n\n    \/\/ Constructor: registers the sorting process with the clock\n    SC_CTOR(BubbleSort) {\n        SC_THREAD(sort_proc);\n        sensitive << clk.pos();\n    }\n\n    \/\/ Thread: waits for start, performs bubble sort, writes results, toggles done\n    void sort_proc() {\n        const int N = 4;\n        while (true) {\n            wait();  \/\/ wait for next clock edge\n            if (start.read()) {\n                \/\/ Read inputs into internal buffer\n                for (int i = 0; i < N; ++i)\n                    buf[i] = in_arr[i].read();\n\n                \/\/ Perform bubble sort on buffer[]\n                for (int i = 0; i < N - 1; ++i)\n                    for (int j = 0; j < N - i - 1; ++j)\n                        if (buf[j] > buf[j + 1])\n                            std::swap(buf[j], buf[j + 1]);\n\n                \/\/ Write sorted results to output ports\n                for (int i = 0; i < N; ++i)\n                    out_arr[i].write(buf[i]);\n\n                \/\/ Signal done for one cycle\n                done.write(true);\n                wait();\n                done.write(false);\n            }\n        }\n    }\n};\n\nFew_shot_example_3:\n#include <systemc.h>\n\n\/\/ Module: MatrixAdder\n\/\/ Adds two 4×4 matrices of integers element-wise.\nSC_MODULE(MatrixAdder) {\n    sc_in<int> A[4*4];   \/\/ Flattened 4×4 input matrix A (16 elements)\n    sc_in<int> B[4*4];   \/\/ Flattened 4×4 input matrix B (16 elements)\n    sc_out<int> C[4*4];  \/\/ Flattened 4×4 output matrix C = A + B\n\n    \/\/ Constructor: registers a combinational add method sensitive to all inputs\n    SC_CTOR(MatrixAdder) {\n        SC_METHOD(do_add);\n        \/\/ Make the add method sensitive to every element of A and B\n        for (int i = 0; i < 4*4; i++) {\n            sensitive << A[i] << B[i];\n        }\n    }\n\n    \/\/ Method: reads A[i] and B[i], writes sum into C[i] for all 16 positions\n    void do_add() {\n        for (int i = 0; i < 4*4; i++) {\n            C[i].write(A[i].read() + B[i].read());\n        }\n    }\n};\n\n\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":31,
        "task":"FindCommonArrayElements",
        "code":"\/\/ C++ program to find common elements between two Arrays using set_intersection()\n#include <bits\/stdc++.h>\nusing namespace std;\n\nint main() {\n    int arr1[] = {1, 45, 54, 71, 76, 12};\n    int arr2[] = {1, 7, 5, 4, 6, 12};\n\n    \/\/ Compute the sizes\n    int n1 = sizeof(arr1) \/ sizeof(arr1[0]);\n    int n2 = sizeof(arr2) \/ sizeof(arr2[0]);\n\n    \/\/ Sort the arrays\n    sort(arr1, arr1 + n1);\n    sort(arr2, arr2 + n2);\n\n    \/\/ Vector to store result\n    vector<int> v;\n    \n    \/\/ Finding common elements using\n    \/\/ set_intersection() function\n    set_intersection(arr1, arr1 + n1, arr2,\n        arr2 + n2, back_inserter(v));\n\n    for (auto i: v){\n        cout << i << \" \";\n    }\n    return 0;\n}\n",
        "category":"Array Operation",
        "adoption":true,
        "reason":null,
        "module_name":"CommonElements",
        "testbench":"SC_MODULE(Testbench) {\n    sc_clock clk{\"clk\", 1, SC_NS};\n    sc_signal<bool> start, done;\n    sc_signal<int> sig_arr1[6], sig_arr2[6];\n    sc_signal<int> sig_result[6], sig_result_size;\n\n    CommonElements* dut;\n\n    SC_CTOR(Testbench) {\n        dut = new CommonElements(\"CommonElements\");\n        dut->clk(clk);\n        dut->start(start);\n        dut->done(done);\n        for (int i = 0; i < 6; ++i) {\n            dut->arr1[i](sig_arr1[i]);\n            dut->arr2[i](sig_arr2[i]);\n            dut->result[i](sig_result[i]);\n        }\n        dut->result_size(sig_result_size);\n\n        SC_THREAD(run_tests);\n    }\n\n    void run_tests() {\n        int a1[6] = {1, 45, 54, 71, 76, 12};\n        int a2[6] = {1, 7, 5, 4, 6, 12};\n        int expected[] = {1, 12};\n\n        for (int i = 0; i < 6; ++i) {\n            sig_arr1[i].write(a1[i]);\n            sig_arr2[i].write(a2[i]);\n        }\n\n        wait(clk.posedge_event());\n        start.write(true);\n        wait(clk.posedge_event());\n        start.write(false);\n\n        wait(done.posedge_event());\n\n        int size = sig_result_size.read();\n        std::cout << \"Common Elements (\" << size << \"): \";\n        for (int i = 0; i < size; ++i) {\n            int val = sig_result[i].read();\n            std::cout << val << \" \";\n            assert(val == expected[i]);\n        }\n        std::cout << \"All tests passed successfully.\\n\";\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\");\n    sc_start();                \/\/ launch simulation\n    return 0;\n}\n",
        "signal":"sc_in<bool> clk;\nsc_in<bool> start;\nsc_out<bool> done;\nsc_in<int> arr1[6];\nsc_in<int> arr2[6];\nsc_out<int> result[6];\nsc_out<int> result_size;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input.\n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<bool> clk;\nsc_in<bool> start;\nsc_out<bool> done;\nsc_in<int> arr1[6];\nsc_in<int> arr2[6];\nsc_out<int> result[6];\nsc_out<int> result_size;\n> **Note**:\n   - Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n   - If the static const are provided, insure to write them in the SystemC code as well.\n\n**C++\/C Code**:\n```\n\/\/ C++ program to find common elements between two Arrays using set_intersection()\n#include <bits\/stdc++.h>\nusing namespace std;\n\nint main() {\n    int arr1[] = {1, 45, 54, 71, 76, 12};\n    int arr2[] = {1, 7, 5, 4, 6, 12};\n\n    \/\/ Compute the sizes\n    int n1 = sizeof(arr1) \/ sizeof(arr1[0]);\n    int n2 = sizeof(arr2) \/ sizeof(arr2[0]);\n\n    \/\/ Sort the arrays\n    sort(arr1, arr1 + n1);\n    sort(arr2, arr2 + n2);\n\n    \/\/ Vector to store result\n    vector<int> v;\n    \n    \/\/ Finding common elements using\n    \/\/ set_intersection() function\n    set_intersection(arr1, arr1 + n1, arr2,\n        arr2 + n2, back_inserter(v));\n\n    for (auto i: v){\n        cout << i << \" \";\n    }\n    return 0;\n}\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\nFew_shot_example_1:\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        dont_initialize();\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n\nFew_shot_example_2:\n#include <systemc.h>\n\n\/\/ Module: BubbleSort\n\/\/ Sorts a small fixed-size array of integers using the bubble sort algorithm.\nSC_MODULE(BubbleSort) {\n    sc_in<bool>  clk;      \/\/ Clock signal\n    sc_in<bool>  start;    \/\/ Start signal to begin sorting\n    sc_out<bool> done;     \/\/ Signal asserted when sorting is complete\n\n    sc_in<int>   in_arr[4];  \/\/ Input array of 4 integers to be sorted\n    sc_out<int>  out_arr[4]; \/\/ Output array of 4 sorted integers\n\n    int buf[4];  \/\/ Internal buffer to hold array elements during sorting\n\n    \/\/ Constructor: registers the sorting process with the clock\n    SC_CTOR(BubbleSort) {\n        SC_THREAD(sort_proc);\n        sensitive << clk.pos();\n    }\n\n    \/\/ Thread: waits for start, performs bubble sort, writes results, toggles done\n    void sort_proc() {\n        const int N = 4;\n        while (true) {\n            wait();  \/\/ wait for next clock edge\n            if (start.read()) {\n                \/\/ Read inputs into internal buffer\n                for (int i = 0; i < N; ++i)\n                    buf[i] = in_arr[i].read();\n\n                \/\/ Perform bubble sort on buffer[]\n                for (int i = 0; i < N - 1; ++i)\n                    for (int j = 0; j < N - i - 1; ++j)\n                        if (buf[j] > buf[j + 1])\n                            std::swap(buf[j], buf[j + 1]);\n\n                \/\/ Write sorted results to output ports\n                for (int i = 0; i < N; ++i)\n                    out_arr[i].write(buf[i]);\n\n                \/\/ Signal done for one cycle\n                done.write(true);\n                wait();\n                done.write(false);\n            }\n        }\n    }\n};\n\nFew_shot_example_3:\n#include <systemc.h>\n\n\/\/ Module: MatrixAdder\n\/\/ Adds two 4×4 matrices of integers element-wise.\nSC_MODULE(MatrixAdder) {\n    sc_in<int> A[4*4];   \/\/ Flattened 4×4 input matrix A (16 elements)\n    sc_in<int> B[4*4];   \/\/ Flattened 4×4 input matrix B (16 elements)\n    sc_out<int> C[4*4];  \/\/ Flattened 4×4 output matrix C = A + B\n\n    \/\/ Constructor: registers a combinational add method sensitive to all inputs\n    SC_CTOR(MatrixAdder) {\n        SC_METHOD(do_add);\n        \/\/ Make the add method sensitive to every element of A and B\n        for (int i = 0; i < 4*4; i++) {\n            sensitive << A[i] << B[i];\n        }\n    }\n\n    \/\/ Method: reads A[i] and B[i], writes sum into C[i] for all 16 positions\n    void do_add() {\n        for (int i = 0; i < 4*4; i++) {\n            C[i].write(A[i].read() + B[i].read());\n        }\n    }\n};\n\n\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":32,
        "task":"FindCompoundInterest",
        "code":"\/\/ C++ program to find compound interest for given values.\n#include <bits\/stdc++.h>\nusing namespace std;\n\n\/\/ Driver code\nint main()\n{\n    double principal = 10000, rate = 5, time = 2;\n\n    \/\/ Calculate compound interest\n    double A = principal * ((pow((1 + rate \/ 100), time)));\n    double CI = A - principal;\n\n    cout << \"Compound interest is \" << CI;\n\n    return 0;\n}\n\/\/ This Code is Contributed by Sahil Rai.\n",
        "category":"Basic Math",
        "adoption":true,
        "reason":null,
        "module_name":"CompoundInterestCalculator",
        "testbench":"SC_MODULE(Testbench) {\n    sc_signal<double> principal_sig; \/\/ Signal for principal amount\n    sc_signal<double> rate_sig;      \/\/ Signal for interest rate\n    sc_signal<double> time_sig;      \/\/ Signal for time period\n    sc_signal<double> ci_sig;        \/\/ Signal for compound interest\n\n    \/\/ Instance of the CompoundInterestCalculator module\n    CompoundInterestCalculator ci_inst;\n\n    \/\/ Constructor: Initialize the module and run the test thread\n    SC_CTOR(Testbench)\n    : ci_inst(\"ci_inst\") {\n        \/\/ Connect signals to module ports\n        ci_inst.principal(principal_sig);\n        ci_inst.rate(rate_sig);\n        ci_inst.time(time_sig);\n        ci_inst.ci(ci_sig);\n\n        \/\/ Create a test thread to provide stimulus and check the result\n        SC_THREAD(run_tests);\n    }\n\n    \/\/ Thread to run test cases\n    void run_tests() {\n        \/\/ Test Case 1: Principal = 10000, Rate = 5%, Time = 2 years\n        principal_sig = 10000;\n        rate_sig = 5;\n        time_sig = 2;\n        wait(1, SC_NS); \/\/ Wait for the process to update\n        \n        \/\/ Read and print the compound interest\n        double result = ci_sig.read();\n        \/\/ Check if the result is as expected (allowing a small tolerance)\n        assert(fabs(result - 1025) < 1e-6);\n        \n        \/\/ Test Case 2: Principal = 20000, Rate = 10%, Time = 5 years\n        principal_sig = 20000;\n        rate_sig = 10;\n        time_sig = 5;\n        wait(1, SC_NS); \/\/ Wait for the process to update\n        \n        result = ci_sig.read(); \/\/ Reuse the already declared variable\n        \/\/ The correct expected compound interest should be around 12210.2\n        assert(fabs(result - 12210.2) < 1e-6);\n        \n        std::cout << \"All tests passed successfully!\" << std::endl;\n        \/\/ End simulation after successful test\n        sc_stop();\n    }    \n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); \/\/ Instantiate the testbench module\n    sc_start();         \/\/ Start the simulation\n    return 0;\n}\n",
        "signal":"sc_in<double> principal;\nsc_in<double> rate;\nsc_in<double> time;\nsc_out<double> ci;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input.\n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<double> principal;\nsc_in<double> rate;\nsc_in<double> time;\nsc_out<double> ci;\n> **Note**:\n   - Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n   - If the static const are provided, insure to write them in the SystemC code as well.\n\n**C++\/C Code**:\n```\n\/\/ C++ program to find compound interest for given values.\n#include <bits\/stdc++.h>\nusing namespace std;\n\n\/\/ Driver code\nint main()\n{\n    double principal = 10000, rate = 5, time = 2;\n\n    \/\/ Calculate compound interest\n    double A = principal * ((pow((1 + rate \/ 100), time)));\n    double CI = A - principal;\n\n    cout << \"Compound interest is \" << CI;\n\n    return 0;\n}\n\/\/ This Code is Contributed by Sahil Rai.\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\nFew_shot_example_1:\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        dont_initialize();\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n\nFew_shot_example_2:\n#include <systemc.h>\n\n\/\/ Module: BubbleSort\n\/\/ Sorts a small fixed-size array of integers using the bubble sort algorithm.\nSC_MODULE(BubbleSort) {\n    sc_in<bool>  clk;      \/\/ Clock signal\n    sc_in<bool>  start;    \/\/ Start signal to begin sorting\n    sc_out<bool> done;     \/\/ Signal asserted when sorting is complete\n\n    sc_in<int>   in_arr[4];  \/\/ Input array of 4 integers to be sorted\n    sc_out<int>  out_arr[4]; \/\/ Output array of 4 sorted integers\n\n    int buf[4];  \/\/ Internal buffer to hold array elements during sorting\n\n    \/\/ Constructor: registers the sorting process with the clock\n    SC_CTOR(BubbleSort) {\n        SC_THREAD(sort_proc);\n        sensitive << clk.pos();\n    }\n\n    \/\/ Thread: waits for start, performs bubble sort, writes results, toggles done\n    void sort_proc() {\n        const int N = 4;\n        while (true) {\n            wait();  \/\/ wait for next clock edge\n            if (start.read()) {\n                \/\/ Read inputs into internal buffer\n                for (int i = 0; i < N; ++i)\n                    buf[i] = in_arr[i].read();\n\n                \/\/ Perform bubble sort on buffer[]\n                for (int i = 0; i < N - 1; ++i)\n                    for (int j = 0; j < N - i - 1; ++j)\n                        if (buf[j] > buf[j + 1])\n                            std::swap(buf[j], buf[j + 1]);\n\n                \/\/ Write sorted results to output ports\n                for (int i = 0; i < N; ++i)\n                    out_arr[i].write(buf[i]);\n\n                \/\/ Signal done for one cycle\n                done.write(true);\n                wait();\n                done.write(false);\n            }\n        }\n    }\n};\n\nFew_shot_example_3:\n#include <systemc.h>\n\n\/\/ Module: MatrixAdder\n\/\/ Adds two 4×4 matrices of integers element-wise.\nSC_MODULE(MatrixAdder) {\n    sc_in<int> A[4*4];   \/\/ Flattened 4×4 input matrix A (16 elements)\n    sc_in<int> B[4*4];   \/\/ Flattened 4×4 input matrix B (16 elements)\n    sc_out<int> C[4*4];  \/\/ Flattened 4×4 output matrix C = A + B\n\n    \/\/ Constructor: registers a combinational add method sensitive to all inputs\n    SC_CTOR(MatrixAdder) {\n        SC_METHOD(do_add);\n        \/\/ Make the add method sensitive to every element of A and B\n        for (int i = 0; i < 4*4; i++) {\n            sensitive << A[i] << B[i];\n        }\n    }\n\n    \/\/ Method: reads A[i] and B[i], writes sum into C[i] for all 16 positions\n    void do_add() {\n        for (int i = 0; i < 4*4; i++) {\n            C[i].write(A[i].read() + B[i].read());\n        }\n    }\n};\n\n\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":33,
        "task":"FindFactorialofaNumber",
        "code":"\/\/ C++ program for factorial of a number\n#include <iostream>\nusing namespace std;\n\n\/\/ Function to find factorial of\n\/\/ given number\nunsigned int factorial(unsigned int n)\n{\n\tint res = 1, i;\n\tfor (i = 2; i <= n; i++)\n\t\tres *= i;\n\treturn res;\n}\n\n\/\/ Driver code\nint main()\n{\n\tint num = 5;\n\tcout << \"Factorial of \" << num << \" is \"\n\t\t<< factorial(num) << endl;\n\treturn 0;\n}\n",
        "category":"Basic Math",
        "adoption":true,
        "reason":null,
        "module_name":"Factorial",
        "testbench":"SC_MODULE(Testbench) {\n    sc_signal<unsigned int> num_sig;   \/\/ Signal to drive the input number\n    sc_signal<unsigned int> fact_sig;  \/\/ Signal to capture the output factorial\n\n    Factorial factorial_inst;  \/\/ Instance of the Factorial module\n\n    \/\/ Constructor: initialize the instance and connect signals\n    SC_CTOR(Testbench) : factorial_inst(\"factorial_inst\") {\n        factorial_inst.in(num_sig);\n        factorial_inst.out(fact_sig);\n\n        \/\/ Create a thread to run the test cases\n        SC_THREAD(run_tests);\n    }\n\n    \/\/ Thread that sets up test cases and checks the output\n    void run_tests() {\n        \/\/ Test case: Compute factorial for 5\n        num_sig.write(5);\n        wait(1, SC_NS);  \/\/ Wait for the process to execute\n\n        \/\/ Read the computed factorial value\n        unsigned int result = fact_sig.read();\n        cout << \"Factorial of 5 is \" << result << endl;\n        \/\/ Assert that the computed result is correct (120 for 5!)\n        assert(result == 120);\n\n        \/\/ Test case: Compute factorial for 0\n        num_sig.write(0);\n        wait(1, SC_NS);  \/\/ Wait for the process to execute\n        result = fact_sig.read();\n        cout << \"Factorial of 0 is \" << result << endl;\n        \/\/ Assert that the computed result is correct (1 for 0!)\n        assert(result == 1);\n\n        std::cout << \"All test passed successfully!\" << std::endl;\n        sc_stop();\n    }\n};\n\n\/\/ sc_main: Entry point for the SystemC simulation\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\");  \/\/ Create an instance of the Testbench module\n    sc_start();          \/\/ Start the simulation\n    return 0;\n}\n",
        "signal":"sc_in<unsigned int> in;\nsc_out<unsigned int> out;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input.\n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<unsigned int> in;\nsc_out<unsigned int> out;\n> **Note**:\n   - Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n   - If the static const are provided, insure to write them in the SystemC code as well.\n\n**C++\/C Code**:\n```\n\/\/ C++ program for factorial of a number\n#include <iostream>\nusing namespace std;\n\n\/\/ Function to find factorial of\n\/\/ given number\nunsigned int factorial(unsigned int n)\n{\n\tint res = 1, i;\n\tfor (i = 2; i <= n; i++)\n\t\tres *= i;\n\treturn res;\n}\n\n\/\/ Driver code\nint main()\n{\n\tint num = 5;\n\tcout << \"Factorial of \" << num << \" is \"\n\t\t<< factorial(num) << endl;\n\treturn 0;\n}\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\nFew_shot_example_1:\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        dont_initialize();\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n\nFew_shot_example_2:\n#include <systemc.h>\n\n\/\/ Module: BubbleSort\n\/\/ Sorts a small fixed-size array of integers using the bubble sort algorithm.\nSC_MODULE(BubbleSort) {\n    sc_in<bool>  clk;      \/\/ Clock signal\n    sc_in<bool>  start;    \/\/ Start signal to begin sorting\n    sc_out<bool> done;     \/\/ Signal asserted when sorting is complete\n\n    sc_in<int>   in_arr[4];  \/\/ Input array of 4 integers to be sorted\n    sc_out<int>  out_arr[4]; \/\/ Output array of 4 sorted integers\n\n    int buf[4];  \/\/ Internal buffer to hold array elements during sorting\n\n    \/\/ Constructor: registers the sorting process with the clock\n    SC_CTOR(BubbleSort) {\n        SC_THREAD(sort_proc);\n        sensitive << clk.pos();\n    }\n\n    \/\/ Thread: waits for start, performs bubble sort, writes results, toggles done\n    void sort_proc() {\n        const int N = 4;\n        while (true) {\n            wait();  \/\/ wait for next clock edge\n            if (start.read()) {\n                \/\/ Read inputs into internal buffer\n                for (int i = 0; i < N; ++i)\n                    buf[i] = in_arr[i].read();\n\n                \/\/ Perform bubble sort on buffer[]\n                for (int i = 0; i < N - 1; ++i)\n                    for (int j = 0; j < N - i - 1; ++j)\n                        if (buf[j] > buf[j + 1])\n                            std::swap(buf[j], buf[j + 1]);\n\n                \/\/ Write sorted results to output ports\n                for (int i = 0; i < N; ++i)\n                    out_arr[i].write(buf[i]);\n\n                \/\/ Signal done for one cycle\n                done.write(true);\n                wait();\n                done.write(false);\n            }\n        }\n    }\n};\n\nFew_shot_example_3:\n#include <systemc.h>\n\n\/\/ Module: MatrixAdder\n\/\/ Adds two 4×4 matrices of integers element-wise.\nSC_MODULE(MatrixAdder) {\n    sc_in<int> A[4*4];   \/\/ Flattened 4×4 input matrix A (16 elements)\n    sc_in<int> B[4*4];   \/\/ Flattened 4×4 input matrix B (16 elements)\n    sc_out<int> C[4*4];  \/\/ Flattened 4×4 output matrix C = A + B\n\n    \/\/ Constructor: registers a combinational add method sensitive to all inputs\n    SC_CTOR(MatrixAdder) {\n        SC_METHOD(do_add);\n        \/\/ Make the add method sensitive to every element of A and B\n        for (int i = 0; i < 4*4; i++) {\n            sensitive << A[i] << B[i];\n        }\n    }\n\n    \/\/ Method: reads A[i] and B[i], writes sum into C[i] for all 16 positions\n    void do_add() {\n        for (int i = 0; i < 4*4; i++) {\n            C[i].write(A[i].read() + B[i].read());\n        }\n    }\n};\n\n\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":34,
        "task":"FindGCD",
        "code":"\/\/ C++ program to find GCD of two numbers using simple arithmetic\n#include <bits\/stdc++.h>\nusing namespace std;\n\nint gcd(int a, int b) {\n    \/\/ Find Minimum of a and b\n    int res = min(a, b);\n\n      \/\/ Testing divisiblity with all numbers starting from\n    \/\/ min(a, b) to 1\n\n    while (res > 1) {\n\n        \/\/ If any number divide both a and b, so we\n        \/\/ got the answer\n        if (a % res == 0 && b % res == 0)\n            break;\n        res--;\n    }\n    return res;\n}\n\nint main() {\n    int a = 12, b = 16;\n  \n    \/\/ Finding gcd of two numbers a and b\n\n\n    cout << gcd(a, b);\n    return 0;\n}\n",
        "category":"Basic Math",
        "adoption":true,
        "reason":null,
        "module_name":"GcdCalculator",
        "testbench":"SC_MODULE(Testbench) {\n    sc_signal<int> a_sig;       \/\/ Signal for the first input\n    sc_signal<int> b_sig;       \/\/ Signal for the second input\n    sc_signal<int> gcd_sig;     \/\/ Signal for the GCD output\n\n    \/\/ Instance of the GcdCalculator module\n    GcdCalculator gcd_inst;\n\n    \/\/ Constructor: Initialize the module and run the test thread\n    SC_CTOR(Testbench)\n    : gcd_inst(\"gcd_inst\") {\n        \/\/ Connect signals to module ports\n        gcd_inst.a(a_sig);\n        gcd_inst.b(b_sig);\n        gcd_inst.gcd_result(gcd_sig);\n\n        \/\/ Create a test thread to provide stimulus and check the result\n        SC_THREAD(run_tests);\n    }\n\n    \/\/ Thread to run test cases\n    void run_tests() {\n        \/\/ Test case: a = 12, b = 16 (expected GCD = 4)\n        a_sig.write(12);\n        b_sig.write(16);\n        wait(1, SC_NS); \/\/ Wait for the process to update\n        int result = gcd_sig.read();\n        std::cout << \"GCD(\" << a_sig.read() << \", \" << b_sig.read() << \") = \" << result << std::endl;\n        assert(result == 4);\n\n        \/\/ Additional test case: a = 48, b = 18 (expected GCD = 6)\n        a_sig.write(48);\n        b_sig.write(18);\n        wait(1, SC_NS);\n        result = gcd_sig.read();\n        std::cout << \"GCD(\" << a_sig.read() << \", \" << b_sig.read() << \") = \" << result << std::endl;\n        assert(result == 6);\n\n        \/\/ End simulation after successful tests\n        std::cout << \"All tests passed successfully.\" << std::endl;\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); \/\/ Instantiate the testbench module\n    sc_start();         \/\/ Start the simulation\n    return 0;\n}\n",
        "signal":"sc_in<int> a;\nsc_in<int> b;\nsc_out<int> gcd_result;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input.\n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<int> a;\nsc_in<int> b;\nsc_out<int> gcd_result;\n> **Note**:\n   - Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n   - If the static const are provided, insure to write them in the SystemC code as well.\n\n**C++\/C Code**:\n```\n\/\/ C++ program to find GCD of two numbers using simple arithmetic\n#include <bits\/stdc++.h>\nusing namespace std;\n\nint gcd(int a, int b) {\n    \/\/ Find Minimum of a and b\n    int res = min(a, b);\n\n      \/\/ Testing divisiblity with all numbers starting from\n    \/\/ min(a, b) to 1\n\n    while (res > 1) {\n\n        \/\/ If any number divide both a and b, so we\n        \/\/ got the answer\n        if (a % res == 0 && b % res == 0)\n            break;\n        res--;\n    }\n    return res;\n}\n\nint main() {\n    int a = 12, b = 16;\n  \n    \/\/ Finding gcd of two numbers a and b\n\n\n    cout << gcd(a, b);\n    return 0;\n}\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\nFew_shot_example_1:\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        dont_initialize();\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n\nFew_shot_example_2:\n#include <systemc.h>\n\n\/\/ Module: BubbleSort\n\/\/ Sorts a small fixed-size array of integers using the bubble sort algorithm.\nSC_MODULE(BubbleSort) {\n    sc_in<bool>  clk;      \/\/ Clock signal\n    sc_in<bool>  start;    \/\/ Start signal to begin sorting\n    sc_out<bool> done;     \/\/ Signal asserted when sorting is complete\n\n    sc_in<int>   in_arr[4];  \/\/ Input array of 4 integers to be sorted\n    sc_out<int>  out_arr[4]; \/\/ Output array of 4 sorted integers\n\n    int buf[4];  \/\/ Internal buffer to hold array elements during sorting\n\n    \/\/ Constructor: registers the sorting process with the clock\n    SC_CTOR(BubbleSort) {\n        SC_THREAD(sort_proc);\n        sensitive << clk.pos();\n    }\n\n    \/\/ Thread: waits for start, performs bubble sort, writes results, toggles done\n    void sort_proc() {\n        const int N = 4;\n        while (true) {\n            wait();  \/\/ wait for next clock edge\n            if (start.read()) {\n                \/\/ Read inputs into internal buffer\n                for (int i = 0; i < N; ++i)\n                    buf[i] = in_arr[i].read();\n\n                \/\/ Perform bubble sort on buffer[]\n                for (int i = 0; i < N - 1; ++i)\n                    for (int j = 0; j < N - i - 1; ++j)\n                        if (buf[j] > buf[j + 1])\n                            std::swap(buf[j], buf[j + 1]);\n\n                \/\/ Write sorted results to output ports\n                for (int i = 0; i < N; ++i)\n                    out_arr[i].write(buf[i]);\n\n                \/\/ Signal done for one cycle\n                done.write(true);\n                wait();\n                done.write(false);\n            }\n        }\n    }\n};\n\nFew_shot_example_3:\n#include <systemc.h>\n\n\/\/ Module: MatrixAdder\n\/\/ Adds two 4×4 matrices of integers element-wise.\nSC_MODULE(MatrixAdder) {\n    sc_in<int> A[4*4];   \/\/ Flattened 4×4 input matrix A (16 elements)\n    sc_in<int> B[4*4];   \/\/ Flattened 4×4 input matrix B (16 elements)\n    sc_out<int> C[4*4];  \/\/ Flattened 4×4 output matrix C = A + B\n\n    \/\/ Constructor: registers a combinational add method sensitive to all inputs\n    SC_CTOR(MatrixAdder) {\n        SC_METHOD(do_add);\n        \/\/ Make the add method sensitive to every element of A and B\n        for (int i = 0; i < 4*4; i++) {\n            sensitive << A[i] << B[i];\n        }\n    }\n\n    \/\/ Method: reads A[i] and B[i], writes sum into C[i] for all 16 positions\n    void do_add() {\n        for (int i = 0; i < 4*4; i++) {\n            C[i].write(A[i].read() + B[i].read());\n        }\n    }\n};\n\n\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":35,
        "task":"FindLargestAmong3Numbers",
        "code":"\/\/ C++ Program to find largest among three numbers using if-else-if ladder\n#include <iostream>\nusing namespace std;\n\nint main() {\n    int a = 1, b = 2, c = 11;\n\n    \/\/ Finding the largest by comparing using\n      \/\/ relational operators with if-else\n    if (a >= b) {\n        if (a >= c)\n            cout << a;\n        else\n            cout << c;\n    }\n    else {\n        if (b >= c)\n            cout << b;\n        else\n            cout << c;\n    }\n\n    return 0;\n}\n",
        "category":"Basic Math",
        "adoption":true,
        "reason":null,
        "module_name":"LargestFinder",
        "testbench":"SC_MODULE(Testbench) {\n    sc_signal<int> a; \/\/ Signal for the first number\n    sc_signal<int> b; \/\/ Signal for the second number\n    sc_signal<int> c; \/\/ Signal for the third number\n    sc_signal<int> largest; \/\/ Signal for the largest number\n\n    LargestFinder largest_finder_inst; \/\/ Instance of the LargestFinder module\n\n    \/\/ Constructor\n    SC_CTOR(Testbench) : largest_finder_inst(\"largest_finder\") {\n        \/\/ Connect signals to ports\n        largest_finder_inst.a(a);\n        largest_finder_inst.b(b);\n        largest_finder_inst.c(c);\n        largest_finder_inst.largest(largest);\n\n        \/\/ Process to run tests\n        SC_THREAD(run_tests);\n    }\n\n    \/\/ Thread to run test cases\n    void run_tests() {\n        \/\/ Test case 1: Basic test\n        a = 1; b = 2; c = 11;\n        wait(1, SC_NS); \/\/ Wait for the largest_finder to process\n        assert(largest.read() == 11);\n        cout << \"Largest: \" << largest.read() << endl;\n\n        \/\/ Test case 2: All numbers are the same\n        a = 5; b = 5; c = 5;\n        wait(1, SC_NS);\n        assert(largest.read() == 5);\n        cout << \"Largest: \" << largest.read() << endl;\n\n        \/\/ Test case 3: Two numbers are the same, one is larger\n        a = 7; b = 7; c = 8;\n        wait(1, SC_NS);\n        assert(largest.read() == 8);\n        cout << \"Largest: \" << largest.read() << endl;\n\n        \/\/ Test case 4: Two numbers are the same, one is smaller\n        a = 9; b = 9; c = 1;\n        wait(1, SC_NS);\n        assert(largest.read() == 9);\n        cout << \"Largest: \" << largest.read() << endl;\n\n        \/\/ Test case 5: All different numbers\n        a = 3; b = 15; c = 9;\n        wait(1, SC_NS);\n        assert(largest.read() == 15);\n        cout << \"Largest: \" << largest.read() << endl;\n\n        \/\/ Print success message\n        cout << \"All tests passed successfully.\" << endl;\n\n        sc_stop(); \/\/ Stop the simulation\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); \/\/ Create an instance of the Testbench\n\n    \/\/ Start the simulation\n    sc_start();\n\n    return 0;\n}\n",
        "signal":"sc_in<int> a;\nsc_in<int> b;\nsc_in<int> c;\nsc_out<int> largest;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input.\n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<int> a;\nsc_in<int> b;\nsc_in<int> c;\nsc_out<int> largest;\n> **Note**:\n   - Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n   - If the static const are provided, insure to write them in the SystemC code as well.\n\n**C++\/C Code**:\n```\n\/\/ C++ Program to find largest among three numbers using if-else-if ladder\n#include <iostream>\nusing namespace std;\n\nint main() {\n    int a = 1, b = 2, c = 11;\n\n    \/\/ Finding the largest by comparing using\n      \/\/ relational operators with if-else\n    if (a >= b) {\n        if (a >= c)\n            cout << a;\n        else\n            cout << c;\n    }\n    else {\n        if (b >= c)\n            cout << b;\n        else\n            cout << c;\n    }\n\n    return 0;\n}\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\nFew_shot_example_1:\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        dont_initialize();\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n\nFew_shot_example_2:\n#include <systemc.h>\n\n\/\/ Module: BubbleSort\n\/\/ Sorts a small fixed-size array of integers using the bubble sort algorithm.\nSC_MODULE(BubbleSort) {\n    sc_in<bool>  clk;      \/\/ Clock signal\n    sc_in<bool>  start;    \/\/ Start signal to begin sorting\n    sc_out<bool> done;     \/\/ Signal asserted when sorting is complete\n\n    sc_in<int>   in_arr[4];  \/\/ Input array of 4 integers to be sorted\n    sc_out<int>  out_arr[4]; \/\/ Output array of 4 sorted integers\n\n    int buf[4];  \/\/ Internal buffer to hold array elements during sorting\n\n    \/\/ Constructor: registers the sorting process with the clock\n    SC_CTOR(BubbleSort) {\n        SC_THREAD(sort_proc);\n        sensitive << clk.pos();\n    }\n\n    \/\/ Thread: waits for start, performs bubble sort, writes results, toggles done\n    void sort_proc() {\n        const int N = 4;\n        while (true) {\n            wait();  \/\/ wait for next clock edge\n            if (start.read()) {\n                \/\/ Read inputs into internal buffer\n                for (int i = 0; i < N; ++i)\n                    buf[i] = in_arr[i].read();\n\n                \/\/ Perform bubble sort on buffer[]\n                for (int i = 0; i < N - 1; ++i)\n                    for (int j = 0; j < N - i - 1; ++j)\n                        if (buf[j] > buf[j + 1])\n                            std::swap(buf[j], buf[j + 1]);\n\n                \/\/ Write sorted results to output ports\n                for (int i = 0; i < N; ++i)\n                    out_arr[i].write(buf[i]);\n\n                \/\/ Signal done for one cycle\n                done.write(true);\n                wait();\n                done.write(false);\n            }\n        }\n    }\n};\n\nFew_shot_example_3:\n#include <systemc.h>\n\n\/\/ Module: MatrixAdder\n\/\/ Adds two 4×4 matrices of integers element-wise.\nSC_MODULE(MatrixAdder) {\n    sc_in<int> A[4*4];   \/\/ Flattened 4×4 input matrix A (16 elements)\n    sc_in<int> B[4*4];   \/\/ Flattened 4×4 input matrix B (16 elements)\n    sc_out<int> C[4*4];  \/\/ Flattened 4×4 output matrix C = A + B\n\n    \/\/ Constructor: registers a combinational add method sensitive to all inputs\n    SC_CTOR(MatrixAdder) {\n        SC_METHOD(do_add);\n        \/\/ Make the add method sensitive to every element of A and B\n        for (int i = 0; i < 4*4; i++) {\n            sensitive << A[i] << B[i];\n        }\n    }\n\n    \/\/ Method: reads A[i] and B[i], writes sum into C[i] for all 16 positions\n    void do_add() {\n        for (int i = 0; i < 4*4; i++) {\n            C[i].write(A[i].read() + B[i].read());\n        }\n    }\n};\n\n\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":36,
        "task":"FindLCM",
        "code":"\/\/ C++ program to find the LCM of two\n\/\/ numbers using the if statement and\n\/\/ while loop\n#include <iostream>\nusing namespace std;\n\n\/\/ Driver code\nint main()\n{\n\tint a = 15, b = 20, max_num, flag = 1;\n\n\t\/\/ Use ternary operator to get the\n\t\/\/ large number\n\tmax_num = (a > b) ? a : b;\n\n\twhile (flag) {\n\t\t\/\/ if statement checks max_num is completely\n\t\t\/\/ divisible by n1 and n2.\n\t\tif (max_num % a == 0 && max_num % b == 0) {\n\t\t\tcout << \"LCM of \" << a << \" and \" << b << \" is \"\n\t\t\t\t<< max_num;\n\t\t\tbreak;\n\t\t}\n\n\t\t\/\/ update by 1 on each iteration\n\t\t++max_num;\n\t}\n\treturn 0;\n}\n",
        "category":"Basic Math",
        "adoption":true,
        "reason":null,
        "module_name":"LcmCalculator",
        "testbench":"SC_MODULE(Testbench) {\n    sc_signal<int> a_sig;       \/\/ Signal for the first input\n    sc_signal<int> b_sig;       \/\/ Signal for the second input\n    sc_signal<int> lcm_sig;      \/\/ Signal for the LCM output\n\n    \/\/ Instance of the LcmCalculator module\n    LcmCalculator lcm_inst;\n\n    \/\/ Constructor: Initialize the module and run the test thread\n    SC_CTOR(Testbench)\n    : lcm_inst(\"lcm_inst\") {\n        \/\/ Connect signals to module ports\n        lcm_inst.a(a_sig);\n        lcm_inst.b(b_sig);\n        lcm_inst.lcm_result(lcm_sig);\n\n        \/\/ Create a test thread to provide stimulus and check the result\n        SC_THREAD(run_tests);\n    }\n\n    \/\/ Thread to run test cases\n    void run_tests() {\n        \/\/ Test case: a = 15, b = 20 (expected LCM = 60)\n        a_sig.write(15);\n        b_sig.write(20);\n        wait(1, SC_NS); \/\/ Wait for the process to update\n        int result = lcm_sig.read();\n        std::cout << \"LCM(\" << a_sig.read() << \", \" << b_sig.read() << \") = \" << result << std::endl;\n        assert(result == 60);\n\n        \/\/ Test case: a = 17, b = 15 (expected LCM = 255)\n        a_sig.write(17);\n        b_sig.write(15);\n        wait(1, SC_NS); \/\/ Wait for the process to update\n        result = lcm_sig.read();\n        std::cout << \"LCM(\" << a_sig.read() << \", \" << b_sig.read() << \") = \" << result << std::endl;\n        assert(result == 255);\n\n        \/\/ End simulation after successful test\n        std::cout << \"Test passed successfully.\" << endl;\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); \/\/ Instantiate the testbench module\n    sc_start();         \/\/ Start the simulation\n    return 0;\n}\n",
        "signal":"sc_in<int> a;\nsc_in<int> b;\nsc_out<int> lcm_result;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input.\n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<int> a;\nsc_in<int> b;\nsc_out<int> lcm_result;\n> **Note**:\n   - Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n   - If the static const are provided, insure to write them in the SystemC code as well.\n\n**C++\/C Code**:\n```\n\/\/ C++ program to find the LCM of two\n\/\/ numbers using the if statement and\n\/\/ while loop\n#include <iostream>\nusing namespace std;\n\n\/\/ Driver code\nint main()\n{\n\tint a = 15, b = 20, max_num, flag = 1;\n\n\t\/\/ Use ternary operator to get the\n\t\/\/ large number\n\tmax_num = (a > b) ? a : b;\n\n\twhile (flag) {\n\t\t\/\/ if statement checks max_num is completely\n\t\t\/\/ divisible by n1 and n2.\n\t\tif (max_num % a == 0 && max_num % b == 0) {\n\t\t\tcout << \"LCM of \" << a << \" and \" << b << \" is \"\n\t\t\t\t<< max_num;\n\t\t\tbreak;\n\t\t}\n\n\t\t\/\/ update by 1 on each iteration\n\t\t++max_num;\n\t}\n\treturn 0;\n}\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\nFew_shot_example_1:\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        dont_initialize();\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n\nFew_shot_example_2:\n#include <systemc.h>\n\n\/\/ Module: BubbleSort\n\/\/ Sorts a small fixed-size array of integers using the bubble sort algorithm.\nSC_MODULE(BubbleSort) {\n    sc_in<bool>  clk;      \/\/ Clock signal\n    sc_in<bool>  start;    \/\/ Start signal to begin sorting\n    sc_out<bool> done;     \/\/ Signal asserted when sorting is complete\n\n    sc_in<int>   in_arr[4];  \/\/ Input array of 4 integers to be sorted\n    sc_out<int>  out_arr[4]; \/\/ Output array of 4 sorted integers\n\n    int buf[4];  \/\/ Internal buffer to hold array elements during sorting\n\n    \/\/ Constructor: registers the sorting process with the clock\n    SC_CTOR(BubbleSort) {\n        SC_THREAD(sort_proc);\n        sensitive << clk.pos();\n    }\n\n    \/\/ Thread: waits for start, performs bubble sort, writes results, toggles done\n    void sort_proc() {\n        const int N = 4;\n        while (true) {\n            wait();  \/\/ wait for next clock edge\n            if (start.read()) {\n                \/\/ Read inputs into internal buffer\n                for (int i = 0; i < N; ++i)\n                    buf[i] = in_arr[i].read();\n\n                \/\/ Perform bubble sort on buffer[]\n                for (int i = 0; i < N - 1; ++i)\n                    for (int j = 0; j < N - i - 1; ++j)\n                        if (buf[j] > buf[j + 1])\n                            std::swap(buf[j], buf[j + 1]);\n\n                \/\/ Write sorted results to output ports\n                for (int i = 0; i < N; ++i)\n                    out_arr[i].write(buf[i]);\n\n                \/\/ Signal done for one cycle\n                done.write(true);\n                wait();\n                done.write(false);\n            }\n        }\n    }\n};\n\nFew_shot_example_3:\n#include <systemc.h>\n\n\/\/ Module: MatrixAdder\n\/\/ Adds two 4×4 matrices of integers element-wise.\nSC_MODULE(MatrixAdder) {\n    sc_in<int> A[4*4];   \/\/ Flattened 4×4 input matrix A (16 elements)\n    sc_in<int> B[4*4];   \/\/ Flattened 4×4 input matrix B (16 elements)\n    sc_out<int> C[4*4];  \/\/ Flattened 4×4 output matrix C = A + B\n\n    \/\/ Constructor: registers a combinational add method sensitive to all inputs\n    SC_CTOR(MatrixAdder) {\n        SC_METHOD(do_add);\n        \/\/ Make the add method sensitive to every element of A and B\n        for (int i = 0; i < 4*4; i++) {\n            sensitive << A[i] << B[i];\n        }\n    }\n\n    \/\/ Method: reads A[i] and B[i], writes sum into C[i] for all 16 positions\n    void do_add() {\n        for (int i = 0; i < 4*4; i++) {\n            C[i].write(A[i].read() + B[i].read());\n        }\n    }\n};\n\n\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":37,
        "task":"FindPowerWithoutUsingMultiplicationAndDivisionOperators",
        "code":"\/\/ C++ code for power function \n#include <bits\/stdc++.h> \nusing namespace std; \n\n\/\/ Works only if a >= 0 \n\/\/ and b >= 0 \nint pow(int a, int b) \n{ \n\tif (b == 0) \n\t\treturn 1; \n\tint answer = a; \n\tint increment = a; \n\tint i, j; \n\tfor(i = 1; i < b; i++) \n\t{ \n\t\tfor(j = 1; j < a; j++) \n\t\t{ \n\t\t\tanswer += increment; \n\t\t} \n\t\tincrement = answer; \n\t} \n\treturn answer; \n} \n\n\/\/ Driver Code \nint main() \n{ \n\tcout << pow(5, 3); \n\treturn 0; \n} \n\n\/\/ This code is contributed by rathbhupendra \n",
        "category":"Basic Math",
        "adoption":true,
        "reason":null,
        "module_name":"PowerFunction",
        "testbench":"SC_MODULE(Testbench) {\n    sc_clock clk{\"clk\", 1, SC_NS};\n    sc_signal<bool> start, done;\n    sc_signal<int> base, exponent, result;\n\n    PowerFunction* dut;\n\n    SC_CTOR(Testbench) {\n        \/\/ DUT instantiation and port binding\n        dut = new PowerFunction(\"PowerFunction\");\n        dut->clk(clk);\n        dut->start(start);\n        dut->done(done);\n        dut->base(base);\n        dut->exponent(exponent);\n        dut->result(result);\n\n        SC_THREAD(run_tests);\n    }\n\n    void run_tests() {\n        \/\/ Test case: 5^3 = 125\n        base.write(5);\n        exponent.write(3);\n\n        wait(clk.posedge_event());\n        start.write(true);\n        wait(clk.posedge_event());\n        start.write(false);\n\n        \/\/ Wait for done signal\n        wait(done.posedge_event());\n\n        int res = result.read();\n        std::cout << \"Result: \" << res << std::endl;\n        assert(res == 125);\n\n        std::cout << \"Test passed successfully.\" << std::endl;\n        sc_stop();\n    }\n};\n\n\/\/ ──────────────── sc_main ────────────────\nint sc_main(int, char*[]) {\n    Testbench tb{\"tb\"};\n    sc_start();\n    return 0;\n}\n",
        "signal":"sc_in<bool> clk;\nsc_in<bool> start;\nsc_out<bool> done;\nsc_in<int> base;\nsc_in<int> exponent;\nsc_out<int> result;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input.\n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<bool> clk;\nsc_in<bool> start;\nsc_out<bool> done;\nsc_in<int> base;\nsc_in<int> exponent;\nsc_out<int> result;\n> **Note**:\n   - Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n   - If the static const are provided, insure to write them in the SystemC code as well.\n\n**C++\/C Code**:\n```\n\/\/ C++ code for power function \n#include <bits\/stdc++.h> \nusing namespace std; \n\n\/\/ Works only if a >= 0 \n\/\/ and b >= 0 \nint pow(int a, int b) \n{ \n\tif (b == 0) \n\t\treturn 1; \n\tint answer = a; \n\tint increment = a; \n\tint i, j; \n\tfor(i = 1; i < b; i++) \n\t{ \n\t\tfor(j = 1; j < a; j++) \n\t\t{ \n\t\t\tanswer += increment; \n\t\t} \n\t\tincrement = answer; \n\t} \n\treturn answer; \n} \n\n\/\/ Driver Code \nint main() \n{ \n\tcout << pow(5, 3); \n\treturn 0; \n} \n\n\/\/ This code is contributed by rathbhupendra \n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\nFew_shot_example_1:\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        dont_initialize();\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n\nFew_shot_example_2:\n#include <systemc.h>\n\n\/\/ Module: BubbleSort\n\/\/ Sorts a small fixed-size array of integers using the bubble sort algorithm.\nSC_MODULE(BubbleSort) {\n    sc_in<bool>  clk;      \/\/ Clock signal\n    sc_in<bool>  start;    \/\/ Start signal to begin sorting\n    sc_out<bool> done;     \/\/ Signal asserted when sorting is complete\n\n    sc_in<int>   in_arr[4];  \/\/ Input array of 4 integers to be sorted\n    sc_out<int>  out_arr[4]; \/\/ Output array of 4 sorted integers\n\n    int buf[4];  \/\/ Internal buffer to hold array elements during sorting\n\n    \/\/ Constructor: registers the sorting process with the clock\n    SC_CTOR(BubbleSort) {\n        SC_THREAD(sort_proc);\n        sensitive << clk.pos();\n    }\n\n    \/\/ Thread: waits for start, performs bubble sort, writes results, toggles done\n    void sort_proc() {\n        const int N = 4;\n        while (true) {\n            wait();  \/\/ wait for next clock edge\n            if (start.read()) {\n                \/\/ Read inputs into internal buffer\n                for (int i = 0; i < N; ++i)\n                    buf[i] = in_arr[i].read();\n\n                \/\/ Perform bubble sort on buffer[]\n                for (int i = 0; i < N - 1; ++i)\n                    for (int j = 0; j < N - i - 1; ++j)\n                        if (buf[j] > buf[j + 1])\n                            std::swap(buf[j], buf[j + 1]);\n\n                \/\/ Write sorted results to output ports\n                for (int i = 0; i < N; ++i)\n                    out_arr[i].write(buf[i]);\n\n                \/\/ Signal done for one cycle\n                done.write(true);\n                wait();\n                done.write(false);\n            }\n        }\n    }\n};\n\nFew_shot_example_3:\n#include <systemc.h>\n\n\/\/ Module: MatrixAdder\n\/\/ Adds two 4×4 matrices of integers element-wise.\nSC_MODULE(MatrixAdder) {\n    sc_in<int> A[4*4];   \/\/ Flattened 4×4 input matrix A (16 elements)\n    sc_in<int> B[4*4];   \/\/ Flattened 4×4 input matrix B (16 elements)\n    sc_out<int> C[4*4];  \/\/ Flattened 4×4 output matrix C = A + B\n\n    \/\/ Constructor: registers a combinational add method sensitive to all inputs\n    SC_CTOR(MatrixAdder) {\n        SC_METHOD(do_add);\n        \/\/ Make the add method sensitive to every element of A and B\n        for (int i = 0; i < 4*4; i++) {\n            sensitive << A[i] << B[i];\n        }\n    }\n\n    \/\/ Method: reads A[i] and B[i], writes sum into C[i] for all 16 positions\n    void do_add() {\n        for (int i = 0; i < 4*4; i++) {\n            C[i].write(A[i].read() + B[i].read());\n        }\n    }\n};\n\n\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":38,
        "task":"FindQuotientandRemainder",
        "code":"\/\/ C++ program to find quotient\n\/\/ and remainder\n#include <iostream>\nusing namespace std;\n\n\/\/ Driver code\nint main()\n{\n    int Dividend, Quotient, Divisor, Remainder;\n\n    cout << \"Enter Dividend & Divisor: \";\n    cin >> Dividend >> Divisor;\n\n    \/\/ Check for division by zero\n    if (Divisor == 0) {\n        cout << \"Error: Divisor cannot be zero.\" << endl;\n    } else {\n        Quotient = Dividend \/ Divisor;\n        Remainder = Dividend % Divisor;\n\n        cout << \"The Quotient = \" << Quotient << endl;\n        cout << \"The Remainder = \" << Remainder << endl;\n    }\n    return 0;\n}\n",
        "category":"Basic Math",
        "adoption":true,
        "reason":null,
        "module_name":"Divider",
        "testbench":"SC_MODULE(Testbench) {\n    sc_signal<int> Dividend;   \/\/ Signal for the dividend\n    sc_signal<int> Divisor;    \/\/ Signal for the divisor\n    sc_signal<int> Quotient;   \/\/ Signal for the quotient\n    sc_signal<int> Remainder;  \/\/ Signal for the remainder\n    sc_signal<bool> Error;     \/\/ Signal to indicate division by zero error\n\n    Divider divider_inst;       \/\/ Instance of the Divider module\n\n    \/\/ Constructor\n    SC_CTOR(Testbench) : divider_inst(\"divider\") {\n        \/\/ Connect signals to ports\n        divider_inst.Dividend(Dividend);\n        divider_inst.Divisor(Divisor);\n        divider_inst.Quotient(Quotient);\n        divider_inst.Remainder(Remainder);\n        divider_inst.Error(Error);\n\n        \/\/ Process to run tests\n        SC_THREAD(run_tests);\n    }\n\n    \/\/ Thread to run test cases\n    void run_tests() {\n        \/\/ Test case 1: Division by zero\n        Dividend = 10;\n        Divisor = 0;\n        wait(1, SC_NS);\n        assert(Error.read() == true && \"Division by zero case\");\n        cout << \"Test Case 1: Division by zero - Error: \" << Error.read() << endl;\n\n        \/\/ Test case 2: Normal division\n        Dividend = 20;\n        Divisor = 3;\n        wait(1, SC_NS);\n        assert(Error.read() == false);\n        assert(Quotient.read() == 6);\n        assert(Remainder.read() == 2);\n        cout << \"Test Case 2: Quotient: \" << Quotient.read() << \", Remainder: \" << Remainder.read() << endl;\n\n        \/\/ Test case 3: Exact division\n        Dividend = 15;\n        Divisor = 5;\n        wait(1, SC_NS);\n        assert(Error.read() == false);\n        assert(Quotient.read() == 3);\n        assert(Remainder.read() == 0);\n        cout << \"Test Case 3: Quotient: \" << Quotient.read() << \", Remainder: \" << Remainder.read() << endl;\n\n        \/\/ Test case 4: Negative dividend\n        Dividend = -20;\n        Divisor = 3;\n        wait(1, SC_NS);\n        assert(Error.read() == false);\n        assert(Quotient.read() == -6);\n        assert(Remainder.read() == -2);\n        cout << \"Test Case 4: Quotient: \" << Quotient.read() << \", Remainder: \" << Remainder.read() << endl;\n\n        \/\/ Test case 5: Negative divisor\n        Dividend = 20;\n        Divisor = -3;\n        wait(1, SC_NS);\n        assert(Error.read() == false);\n        assert(Quotient.read() == -6);\n        assert(Remainder.read() == 2);\n        cout << \"Test Case 5: Quotient: \" << Quotient.read() << \", Remainder: \" << Remainder.read() << endl;\n\n        \/\/ Test case 6: Both negative\n        Dividend = -20;\n        Divisor = -3;\n        wait(1, SC_NS);\n        assert(Error.read() == false);\n        assert(Quotient.read() == 6);\n        assert(Remainder.read() == -2);\n        cout << \"Test Case 6: Quotient: \" << Quotient.read() << \", Remainder: \" << Remainder.read() << endl;\n\n        \/\/ Print success message\n        cout << \"All tests passed successfully.\" << endl;\n\n        sc_stop(); \/\/ Stop the simulation\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); \/\/ Create an instance of the Testbench\n\n    \/\/ Start the simulation\n    sc_start();\n\n    return 0;\n}\n",
        "signal":"sc_in<int> Dividend;\nsc_in<int> Divisor;\nsc_out<int> Quotient;\nsc_out<int> Remainder;\nsc_out<bool> Error;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input.\n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<int> Dividend;\nsc_in<int> Divisor;\nsc_out<int> Quotient;\nsc_out<int> Remainder;\nsc_out<bool> Error;\n> **Note**:\n   - Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n   - If the static const are provided, insure to write them in the SystemC code as well.\n\n**C++\/C Code**:\n```\n\/\/ C++ program to find quotient\n\/\/ and remainder\n#include <iostream>\nusing namespace std;\n\n\/\/ Driver code\nint main()\n{\n    int Dividend, Quotient, Divisor, Remainder;\n\n    cout << \"Enter Dividend & Divisor: \";\n    cin >> Dividend >> Divisor;\n\n    \/\/ Check for division by zero\n    if (Divisor == 0) {\n        cout << \"Error: Divisor cannot be zero.\" << endl;\n    } else {\n        Quotient = Dividend \/ Divisor;\n        Remainder = Dividend % Divisor;\n\n        cout << \"The Quotient = \" << Quotient << endl;\n        cout << \"The Remainder = \" << Remainder << endl;\n    }\n    return 0;\n}\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\nFew_shot_example_1:\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        dont_initialize();\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n\nFew_shot_example_2:\n#include <systemc.h>\n\n\/\/ Module: BubbleSort\n\/\/ Sorts a small fixed-size array of integers using the bubble sort algorithm.\nSC_MODULE(BubbleSort) {\n    sc_in<bool>  clk;      \/\/ Clock signal\n    sc_in<bool>  start;    \/\/ Start signal to begin sorting\n    sc_out<bool> done;     \/\/ Signal asserted when sorting is complete\n\n    sc_in<int>   in_arr[4];  \/\/ Input array of 4 integers to be sorted\n    sc_out<int>  out_arr[4]; \/\/ Output array of 4 sorted integers\n\n    int buf[4];  \/\/ Internal buffer to hold array elements during sorting\n\n    \/\/ Constructor: registers the sorting process with the clock\n    SC_CTOR(BubbleSort) {\n        SC_THREAD(sort_proc);\n        sensitive << clk.pos();\n    }\n\n    \/\/ Thread: waits for start, performs bubble sort, writes results, toggles done\n    void sort_proc() {\n        const int N = 4;\n        while (true) {\n            wait();  \/\/ wait for next clock edge\n            if (start.read()) {\n                \/\/ Read inputs into internal buffer\n                for (int i = 0; i < N; ++i)\n                    buf[i] = in_arr[i].read();\n\n                \/\/ Perform bubble sort on buffer[]\n                for (int i = 0; i < N - 1; ++i)\n                    for (int j = 0; j < N - i - 1; ++j)\n                        if (buf[j] > buf[j + 1])\n                            std::swap(buf[j], buf[j + 1]);\n\n                \/\/ Write sorted results to output ports\n                for (int i = 0; i < N; ++i)\n                    out_arr[i].write(buf[i]);\n\n                \/\/ Signal done for one cycle\n                done.write(true);\n                wait();\n                done.write(false);\n            }\n        }\n    }\n};\n\nFew_shot_example_3:\n#include <systemc.h>\n\n\/\/ Module: MatrixAdder\n\/\/ Adds two 4×4 matrices of integers element-wise.\nSC_MODULE(MatrixAdder) {\n    sc_in<int> A[4*4];   \/\/ Flattened 4×4 input matrix A (16 elements)\n    sc_in<int> B[4*4];   \/\/ Flattened 4×4 input matrix B (16 elements)\n    sc_out<int> C[4*4];  \/\/ Flattened 4×4 output matrix C = A + B\n\n    \/\/ Constructor: registers a combinational add method sensitive to all inputs\n    SC_CTOR(MatrixAdder) {\n        SC_METHOD(do_add);\n        \/\/ Make the add method sensitive to every element of A and B\n        for (int i = 0; i < 4*4; i++) {\n            sensitive << A[i] << B[i];\n        }\n    }\n\n    \/\/ Method: reads A[i] and B[i], writes sum into C[i] for all 16 positions\n    void do_add() {\n        for (int i = 0; i < 4*4; i++) {\n            C[i].write(A[i].read() + B[i].read());\n        }\n    }\n};\n\n\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":39,
        "task":"FindSimpleInterest",
        "code":"\/\/ C++ program to find simple interest \n\/\/ for given principal amount, time \n\/\/ and rate of interest.\n#include<iostream>\nusing namespace std;\n\n\/\/ Driver code\nint main()\n{\n\t\/\/ We can change values here for\n\t\/\/ different inputs\n\tfloat P = 1, R = 1, T = 1;\n\n\t\/\/ Calculate simple interest \n\tfloat SI = (P * T * R) \/ 100;\n\n\t\/\/ Print the resultant value of SI \n\tcout << \"Simple Interest = \" << SI;\n\n\treturn 0;\n}\n\n",
        "category":"Basic Math",
        "adoption":true,
        "reason":null,
        "module_name":"SimpleInterestCalculator",
        "testbench":"SC_MODULE(Testbench) {\n    sc_signal<float> P_sig;      \/\/ Signal for Principal\n    sc_signal<float> R_sig;      \/\/ Signal for Rate\n    sc_signal<float> T_sig;      \/\/ Signal for Time\n    sc_signal<float> SI_sig;     \/\/ Signal for Simple Interest\n\n    SimpleInterestCalculator si_inst; \/\/ Instance of the SimpleInterestCalculator module\n\n    \/\/ Constructor\n    SC_CTOR(Testbench)\n    : si_inst(\"si_inst\") {\n        \/\/ Connect signals to module ports\n        si_inst.P(P_sig);\n        si_inst.R(R_sig);\n        si_inst.T(T_sig);\n        si_inst.SI(SI_sig);\n\n        \/\/ Create a test thread to provide stimulus and check the result\n        SC_THREAD(run_tests);\n    }\n\n    \/\/ Thread to run test cases\n    void run_tests() {\n        \/\/ Test case 1: P = 1, R = 1, T = 1 (expected SI = 0.01)\n        P_sig = 1.0;\n        R_sig = 1.0;\n        T_sig = 1.0;\n        wait(1, SC_NS); \/\/ Wait for the process to update\n        float result = SI_sig.read();\n        std::cout << \"Simple Interest for P=1, R=1, T=1: \" << result << std::endl;\n        assert(abs(result - 0.01) < 1e-6); \/\/ Allow for floating-point precision errors\n\n        \/\/ Test case 2: P = 1000, R = 5, T = 2 (expected SI = 100.0)\n        P_sig = 1000.0;\n        R_sig = 5.0;\n        T_sig = 2.0;\n        wait(1, SC_NS); \/\/ Wait for the process to update\n        result = SI_sig.read();\n        std::cout << \"Simple Interest for P=1000, R=5, T=2: \" << result << std::endl;\n        assert(abs(result - 100.0) < 1e-6); \/\/ Allow for floating-point precision errors\n        \n        \/\/ End simulation after successful test\n        std::cout << \"Test passed successfully.\" << std::endl;\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); \/\/ Instantiate the testbench module\n    sc_start();         \/\/ Start the simulation\n    return 0;\n}\n",
        "signal":"sc_in<float> P;\nsc_in<float> R;\nsc_in<float> T;\nsc_out<float> SI;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input.\n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<float> P;\nsc_in<float> R;\nsc_in<float> T;\nsc_out<float> SI;\n> **Note**:\n   - Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n   - If the static const are provided, insure to write them in the SystemC code as well.\n\n**C++\/C Code**:\n```\n\/\/ C++ program to find simple interest \n\/\/ for given principal amount, time \n\/\/ and rate of interest.\n#include<iostream>\nusing namespace std;\n\n\/\/ Driver code\nint main()\n{\n\t\/\/ We can change values here for\n\t\/\/ different inputs\n\tfloat P = 1, R = 1, T = 1;\n\n\t\/\/ Calculate simple interest \n\tfloat SI = (P * T * R) \/ 100;\n\n\t\/\/ Print the resultant value of SI \n\tcout << \"Simple Interest = \" << SI;\n\n\treturn 0;\n}\n\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\nFew_shot_example_1:\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        dont_initialize();\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n\nFew_shot_example_2:\n#include <systemc.h>\n\n\/\/ Module: BubbleSort\n\/\/ Sorts a small fixed-size array of integers using the bubble sort algorithm.\nSC_MODULE(BubbleSort) {\n    sc_in<bool>  clk;      \/\/ Clock signal\n    sc_in<bool>  start;    \/\/ Start signal to begin sorting\n    sc_out<bool> done;     \/\/ Signal asserted when sorting is complete\n\n    sc_in<int>   in_arr[4];  \/\/ Input array of 4 integers to be sorted\n    sc_out<int>  out_arr[4]; \/\/ Output array of 4 sorted integers\n\n    int buf[4];  \/\/ Internal buffer to hold array elements during sorting\n\n    \/\/ Constructor: registers the sorting process with the clock\n    SC_CTOR(BubbleSort) {\n        SC_THREAD(sort_proc);\n        sensitive << clk.pos();\n    }\n\n    \/\/ Thread: waits for start, performs bubble sort, writes results, toggles done\n    void sort_proc() {\n        const int N = 4;\n        while (true) {\n            wait();  \/\/ wait for next clock edge\n            if (start.read()) {\n                \/\/ Read inputs into internal buffer\n                for (int i = 0; i < N; ++i)\n                    buf[i] = in_arr[i].read();\n\n                \/\/ Perform bubble sort on buffer[]\n                for (int i = 0; i < N - 1; ++i)\n                    for (int j = 0; j < N - i - 1; ++j)\n                        if (buf[j] > buf[j + 1])\n                            std::swap(buf[j], buf[j + 1]);\n\n                \/\/ Write sorted results to output ports\n                for (int i = 0; i < N; ++i)\n                    out_arr[i].write(buf[i]);\n\n                \/\/ Signal done for one cycle\n                done.write(true);\n                wait();\n                done.write(false);\n            }\n        }\n    }\n};\n\nFew_shot_example_3:\n#include <systemc.h>\n\n\/\/ Module: MatrixAdder\n\/\/ Adds two 4×4 matrices of integers element-wise.\nSC_MODULE(MatrixAdder) {\n    sc_in<int> A[4*4];   \/\/ Flattened 4×4 input matrix A (16 elements)\n    sc_in<int> B[4*4];   \/\/ Flattened 4×4 input matrix B (16 elements)\n    sc_out<int> C[4*4];  \/\/ Flattened 4×4 output matrix C = A + B\n\n    \/\/ Constructor: registers a combinational add method sensitive to all inputs\n    SC_CTOR(MatrixAdder) {\n        SC_METHOD(do_add);\n        \/\/ Make the add method sensitive to every element of A and B\n        for (int i = 0; i < 4*4; i++) {\n            sensitive << A[i] << B[i];\n        }\n    }\n\n    \/\/ Method: reads A[i] and B[i], writes sum into C[i] for all 16 positions\n    void do_add() {\n        for (int i = 0; i < 4*4; i++) {\n            C[i].write(A[i].read() + B[i].read());\n        }\n    }\n};\n\n\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":40,
        "task":"FindtheDeterminantofaMatrix",
        "code":"#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nconst int MAXN = 105;\ndouble a[MAXN][MAXN];\n\ndouble determinant(int n) {\n\tdouble det = 1.0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint pivot = i;\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tif (abs(a[j][i]) > abs(a[pivot][i])) {\n\t\t\t\tpivot = j;\n\t\t\t}\n\t\t}\n\t\tif (pivot != i) {\n\t\t\tswap(a[i], a[pivot]);\n\t\t\tdet *= -1;\n\t\t}\n\t\tif (a[i][i] == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tdet *= a[i][i];\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tdouble factor = a[j][i] \/ a[i][i];\n\t\t\tfor (int k = i + 1; k < n; k++) {\n\t\t\t\ta[j][k] -= factor * a[i][k];\n\t\t\t}\n\t\t}\n\t}\n\treturn det;\n}\n\nint main() {\n\tint n = 4;\n\tdouble matrix[4][4] = {{1, 0, 2, -1},\n\t\t\t\t\t\t{3, 0, 0, 5},\n\t\t\t\t\t\t{2, 1, 4, -3},\n\t\t\t\t\t\t{1, 0, 5, 0}};\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\ta[i][j] = matrix[i][j];\n\t\t}\n\t}\n\tdouble det = determinant(n);\n\tcout << \"Determinant = \" << det << endl;\n\treturn 0;\n}\n",
        "category":"Matrix Operation",
        "adoption":true,
        "reason":null,
        "module_name":"DeterminantCalculator",
        "testbench":"SC_MODULE(Testbench) {\n    \n    sc_signal<double> matrix[4*4];\n    sc_signal<double> det;\n\n    DeterminantCalculator* detCalc;\n\n    SC_CTOR(Testbench) {\n        detCalc = new DeterminantCalculator(\"detCalc\");\n        for (int i = 0; i < 4*4; i++) {\n            detCalc->matrix[i](matrix[i]);\n        }\n        detCalc->det(det);\n        SC_THREAD(run_tests);\n    }\n\n    \/\/ Thread to initialize matrix, check result, and assert correctness\n    void run_tests() {\n        \/\/ Initialize the 4x4 matrix (row-major order)\n        \/\/ Matrix:\n        \/\/ { {1, 0, 2, -1},\n        \/\/   {3, 0, 0, 5},\n        \/\/   {2, 1, 4, -3},\n        \/\/   {1, 0, 5, 0} }\n        double init_matrix[4*4] = {\n            1, 0, 2, -1,\n            3, 0, 0, 5,\n            2, 1, 4, -3,\n            1, 0, 5, 0\n        };\n        for (int i = 0; i < 4*4; i++) {\n            matrix[i].write(init_matrix[i]);\n        }\n\n        \/\/ Wait for signals to propagate and process to complete\n        wait(2, SC_NS);\n\n        \/\/ Read the result and check\n        double result = det.read();\n        std::cout << \"Determinant = \" << result << std::endl;\n        \/\/ Expected determinant is 30 (as computed in the original code)\n        assert(std::abs(result - 30.0) < 1e-6);\n        std::cout << \"Test passed successfully\" << std::endl;\n\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\");\n    sc_start();\n    return 0;\n}\n",
        "signal":"sc_in<double> matrix[4*4];\nsc_out<double> det;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input.\n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<double> matrix[4*4];\nsc_out<double> det;\n> **Note**:\n   - Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n   - If the static const are provided, insure to write them in the SystemC code as well.\n\n**C++\/C Code**:\n```\n#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nconst int MAXN = 105;\ndouble a[MAXN][MAXN];\n\ndouble determinant(int n) {\n\tdouble det = 1.0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint pivot = i;\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tif (abs(a[j][i]) > abs(a[pivot][i])) {\n\t\t\t\tpivot = j;\n\t\t\t}\n\t\t}\n\t\tif (pivot != i) {\n\t\t\tswap(a[i], a[pivot]);\n\t\t\tdet *= -1;\n\t\t}\n\t\tif (a[i][i] == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tdet *= a[i][i];\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tdouble factor = a[j][i] \/ a[i][i];\n\t\t\tfor (int k = i + 1; k < n; k++) {\n\t\t\t\ta[j][k] -= factor * a[i][k];\n\t\t\t}\n\t\t}\n\t}\n\treturn det;\n}\n\nint main() {\n\tint n = 4;\n\tdouble matrix[4][4] = {{1, 0, 2, -1},\n\t\t\t\t\t\t{3, 0, 0, 5},\n\t\t\t\t\t\t{2, 1, 4, -3},\n\t\t\t\t\t\t{1, 0, 5, 0}};\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\ta[i][j] = matrix[i][j];\n\t\t}\n\t}\n\tdouble det = determinant(n);\n\tcout << \"Determinant = \" << det << endl;\n\treturn 0;\n}\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\nFew_shot_example_1:\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        dont_initialize();\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n\nFew_shot_example_2:\n#include <systemc.h>\n\n\/\/ Module: BubbleSort\n\/\/ Sorts a small fixed-size array of integers using the bubble sort algorithm.\nSC_MODULE(BubbleSort) {\n    sc_in<bool>  clk;      \/\/ Clock signal\n    sc_in<bool>  start;    \/\/ Start signal to begin sorting\n    sc_out<bool> done;     \/\/ Signal asserted when sorting is complete\n\n    sc_in<int>   in_arr[4];  \/\/ Input array of 4 integers to be sorted\n    sc_out<int>  out_arr[4]; \/\/ Output array of 4 sorted integers\n\n    int buf[4];  \/\/ Internal buffer to hold array elements during sorting\n\n    \/\/ Constructor: registers the sorting process with the clock\n    SC_CTOR(BubbleSort) {\n        SC_THREAD(sort_proc);\n        sensitive << clk.pos();\n    }\n\n    \/\/ Thread: waits for start, performs bubble sort, writes results, toggles done\n    void sort_proc() {\n        const int N = 4;\n        while (true) {\n            wait();  \/\/ wait for next clock edge\n            if (start.read()) {\n                \/\/ Read inputs into internal buffer\n                for (int i = 0; i < N; ++i)\n                    buf[i] = in_arr[i].read();\n\n                \/\/ Perform bubble sort on buffer[]\n                for (int i = 0; i < N - 1; ++i)\n                    for (int j = 0; j < N - i - 1; ++j)\n                        if (buf[j] > buf[j + 1])\n                            std::swap(buf[j], buf[j + 1]);\n\n                \/\/ Write sorted results to output ports\n                for (int i = 0; i < N; ++i)\n                    out_arr[i].write(buf[i]);\n\n                \/\/ Signal done for one cycle\n                done.write(true);\n                wait();\n                done.write(false);\n            }\n        }\n    }\n};\n\nFew_shot_example_3:\n#include <systemc.h>\n\n\/\/ Module: MatrixAdder\n\/\/ Adds two 4×4 matrices of integers element-wise.\nSC_MODULE(MatrixAdder) {\n    sc_in<int> A[4*4];   \/\/ Flattened 4×4 input matrix A (16 elements)\n    sc_in<int> B[4*4];   \/\/ Flattened 4×4 input matrix B (16 elements)\n    sc_out<int> C[4*4];  \/\/ Flattened 4×4 output matrix C = A + B\n\n    \/\/ Constructor: registers a combinational add method sensitive to all inputs\n    SC_CTOR(MatrixAdder) {\n        SC_METHOD(do_add);\n        \/\/ Make the add method sensitive to every element of A and B\n        for (int i = 0; i < 4*4; i++) {\n            sensitive << A[i] << B[i];\n        }\n    }\n\n    \/\/ Method: reads A[i] and B[i], writes sum into C[i] for all 16 positions\n    void do_add() {\n        for (int i = 0; i < 4*4; i++) {\n            C[i].write(A[i].read() + B[i].read());\n        }\n    }\n};\n\n\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":41,
        "task":"FindtheMaximumandMinimuminanArray",
        "code":"\/\/ C++ program to find minimum (or maximum) element \n\/\/ in an array. \n#include <bits\/stdc++.h> \nusing namespace std; \n\nint getMin(int arr[], int n) \n{ \n\treturn *min_element(arr, arr + n); \n} \n\nint getMax(int arr[], int n) \n{ \n\treturn *max_element(arr, arr + n); \n} \n\nint main() \n{ \n\tint arr[] = { 12, 1234, 45, 67, 1 }; \n\tint n = sizeof(arr) \/ sizeof(arr[0]); \n\tcout << \"Minimum element of array: \" << getMin(arr, n) << \" \"; \n\tcout << \"Maximum element of array: \" << getMax(arr, n); \n\treturn 0; \n} \n",
        "category":"Array Operation",
        "adoption":true,
        "reason":null,
        "module_name":"MinMax",
        "testbench":"SC_MODULE(Testbench) {\n    sc_clock        clk{\"clk\", 1, SC_NS};\n    sc_signal<bool> start, done;\n    sc_signal<int>  min_val, max_val;\n    sc_signal<int>  sig_in[5];\n\n    MinMax*         dut;\n\n    SC_CTOR(Testbench) {\n        \/* 建立 DUT 並連線 *\/\n        dut = new MinMax(\"MinMax\");\n        dut->clk(clk);\n        dut->start(start);\n        dut->done(done);\n        dut->min_val(min_val);\n        dut->max_val(max_val);\n        for (int i = 0; i < 5; ++i)\n            dut->in_arr[i](sig_in[i]);\n\n        SC_THREAD(run_tests);\n    }\n\n    void run_tests() {\n        int data[5] = {12, 1234, 45, 67, 1};\n\n        \/* ▸ 驅動輸入 *\/\n        for (int i = 0; i < 5; ++i)\n            sig_in[i].write(data[i]);\n\n        \/* ▸ 觸發運算 *\/\n        wait(clk.posedge_event());\n        start.write(true);\n        wait(clk.posedge_event());\n        start.write(false);\n\n        \/* ▸ 等待 done=1 *\/\n        wait(done.posedge_event());\n\n        \/* ▸ 讀取並驗證結果 *\/\n        int computed_min = min_val.read();\n        int computed_max = max_val.read();\n\n        assert(computed_min == 1);\n        assert(computed_max == 1234);\n\n        std::cout << \"Computed minimum: \" << computed_min << '\\n';\n        std::cout << \"Computed maximum: \" << computed_max << '\\n';\n        std::cout << \"Test passed successfully.\\n\";\n\n        sc_stop();\n    }\n};\n\n\/\/─────────────── sc_main ───────────────\nint sc_main(int, char*[]) {\n    Testbench tb{\"tb\"};\n    sc_start();\n    return 0;\n}\n",
        "signal":"sc_in<bool>  clk;\nsc_in<bool>  start;\nsc_out<bool> done;\nsc_out<int>  min_val;\nsc_out<int>  max_val;\nsc_in<int>   in_arr[5];",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input.\n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<bool>  clk;\nsc_in<bool>  start;\nsc_out<bool> done;\nsc_out<int>  min_val;\nsc_out<int>  max_val;\nsc_in<int>   in_arr[5];\n> **Note**:\n   - Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n   - If the static const are provided, insure to write them in the SystemC code as well.\n\n**C++\/C Code**:\n```\n\/\/ C++ program to find minimum (or maximum) element \n\/\/ in an array. \n#include <bits\/stdc++.h> \nusing namespace std; \n\nint getMin(int arr[], int n) \n{ \n\treturn *min_element(arr, arr + n); \n} \n\nint getMax(int arr[], int n) \n{ \n\treturn *max_element(arr, arr + n); \n} \n\nint main() \n{ \n\tint arr[] = { 12, 1234, 45, 67, 1 }; \n\tint n = sizeof(arr) \/ sizeof(arr[0]); \n\tcout << \"Minimum element of array: \" << getMin(arr, n) << \" \"; \n\tcout << \"Maximum element of array: \" << getMax(arr, n); \n\treturn 0; \n} \n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\nFew_shot_example_1:\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        dont_initialize();\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n\nFew_shot_example_2:\n#include <systemc.h>\n\n\/\/ Module: BubbleSort\n\/\/ Sorts a small fixed-size array of integers using the bubble sort algorithm.\nSC_MODULE(BubbleSort) {\n    sc_in<bool>  clk;      \/\/ Clock signal\n    sc_in<bool>  start;    \/\/ Start signal to begin sorting\n    sc_out<bool> done;     \/\/ Signal asserted when sorting is complete\n\n    sc_in<int>   in_arr[4];  \/\/ Input array of 4 integers to be sorted\n    sc_out<int>  out_arr[4]; \/\/ Output array of 4 sorted integers\n\n    int buf[4];  \/\/ Internal buffer to hold array elements during sorting\n\n    \/\/ Constructor: registers the sorting process with the clock\n    SC_CTOR(BubbleSort) {\n        SC_THREAD(sort_proc);\n        sensitive << clk.pos();\n    }\n\n    \/\/ Thread: waits for start, performs bubble sort, writes results, toggles done\n    void sort_proc() {\n        const int N = 4;\n        while (true) {\n            wait();  \/\/ wait for next clock edge\n            if (start.read()) {\n                \/\/ Read inputs into internal buffer\n                for (int i = 0; i < N; ++i)\n                    buf[i] = in_arr[i].read();\n\n                \/\/ Perform bubble sort on buffer[]\n                for (int i = 0; i < N - 1; ++i)\n                    for (int j = 0; j < N - i - 1; ++j)\n                        if (buf[j] > buf[j + 1])\n                            std::swap(buf[j], buf[j + 1]);\n\n                \/\/ Write sorted results to output ports\n                for (int i = 0; i < N; ++i)\n                    out_arr[i].write(buf[i]);\n\n                \/\/ Signal done for one cycle\n                done.write(true);\n                wait();\n                done.write(false);\n            }\n        }\n    }\n};\n\nFew_shot_example_3:\n#include <systemc.h>\n\n\/\/ Module: MatrixAdder\n\/\/ Adds two 4×4 matrices of integers element-wise.\nSC_MODULE(MatrixAdder) {\n    sc_in<int> A[4*4];   \/\/ Flattened 4×4 input matrix A (16 elements)\n    sc_in<int> B[4*4];   \/\/ Flattened 4×4 input matrix B (16 elements)\n    sc_out<int> C[4*4];  \/\/ Flattened 4×4 output matrix C = A + B\n\n    \/\/ Constructor: registers a combinational add method sensitive to all inputs\n    SC_CTOR(MatrixAdder) {\n        SC_METHOD(do_add);\n        \/\/ Make the add method sensitive to every element of A and B\n        for (int i = 0; i < 4*4; i++) {\n            sensitive << A[i] << B[i];\n        }\n    }\n\n    \/\/ Method: reads A[i] and B[i], writes sum into C[i] for all 16 positions\n    void do_add() {\n        for (int i = 0; i < 4*4; i++) {\n            C[i].write(A[i].read() + B[i].read());\n        }\n    }\n};\n\n\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":42,
        "task":"FindtheNormalandTraceofaMatrix",
        "code":"\/\/ C++ program to find trace and \n\/\/ normal of given matrix \n#include<bits\/stdc++.h> \nusing namespace std; \n\n\/\/ Size of given matrix \nconst int MAX = 100; \n\n\/\/ Returns Normal of a matrix of \n\/\/ size n x n \nint findNormal(int mat[][MAX], int n) \n{ \n\tint sum = 0; \n\tfor (int i = 0; i < n; i++) \n\t\tfor (int j = 0; j < n; j++) \n\t\t\tsum += mat[i][j] * mat[i][j]; \n\treturn sqrt(sum); \n} \n\n\/\/ Returns trace of a matrix of \n\/\/ size n x n \nint findTrace(int mat[][MAX], int n) \n{ \n\tint sum = 0; \n\tfor (int i = 0; i < n; i++) \n\t\tsum += mat[i][i]; \n\treturn sum; \n} \n\n\/\/ Driven code \nint main() \n{ \n\tint mat[][MAX] = {{1, 1, 1, 1, 1}, \n\t\t{2, 2, 2, 2, 2}, \n\t\t{3, 3, 3, 3, 3}, \n\t\t{4, 4, 4, 4, 4}, \n\t\t{5, 5, 5, 5, 5}}; \n\tcout << \"Trace of Matrix = \" << \n\t\t\tfindTrace(mat, 5) << endl; \n\tcout << \"Normal of Matrix = \" << \n\t\t\tfindNormal(mat, 5) << endl; \n\treturn 0; \n} \n",
        "category":"Matrix Operation",
        "adoption":true,
        "reason":null,
        "module_name":"MatrixOperations",
        "testbench":"SC_MODULE(Testbench) {\n \n    \/\/ Signals to connect with the MatrixOperations module\n    sc_signal<int> matrix[5*5];\n    sc_signal<int> trace_signal;\n    sc_signal<int> norm_signal;\n\n    \/\/ Instance of the MatrixOperations module\n    MatrixOperations* matrixOps;\n\n    SC_CTOR(Testbench) {\n        \/\/ Instantiate the MatrixOperations module\n        matrixOps = new MatrixOperations(\"matrixOps\");\n\n        \/\/ Connect the matrix signals to the module ports\n        for (int i = 0; i < 5*5; i++) {\n            matrixOps->matrix[i](matrix[i]);\n        }\n        matrixOps->trace(trace_signal);\n        matrixOps->norm(norm_signal);\n\n        \/\/ Create a thread to run test cases\n        SC_THREAD(run_tests);\n    }\n\n    \/\/ Thread that initializes the matrix, checks outputs, and asserts correctness\n    void run_tests() {\n        \/\/ Initialize the matrix with values as defined in the original C++ code:\n        \/\/ Matrix:\n        \/\/   {1, 1, 1, 1, 1},\n        \/\/   {2, 2, 2, 2, 2},\n        \/\/   {3, 3, 3, 3, 3},\n        \/\/   {4, 4, 4, 4, 4},\n        \/\/   {5, 5, 5, 5, 5}\n        for (int row = 0; row < 5; row++) {\n            for (int col = 0; col < 5; col++) {\n                int index = row * 5 + col;\n                matrix[index].write(row + 1); \/\/ Set all elements in a row to row+1\n            }\n        }\n\n        \/\/ Wait for the combinational logic to settle\n        wait(1, SC_NS);\n\n        \/\/ Expected outputs:\n        \/\/ Trace = 1 + 2 + 3 + 4 + 5 = 15\n        \/\/ Normal = sqrt(5*(1^2 + 2^2 + 3^2 + 4^2 + 5^2)) = sqrt(275) ≈ 16 (when truncated)\n        int expected_trace = 15;\n        int expected_norm = static_cast<int>(sqrt(275));\n\n        std::cout << \"Computed Trace: \" << trace_signal.read() << std::endl;\n        std::cout << \"Computed Normal: \" << norm_signal.read() << std::endl;\n\n        \/\/ Validate the computed outputs using assertions\n        assert(trace_signal.read() == expected_trace);\n        assert(norm_signal.read() == expected_norm);\n\n        std::cout << \"All tests passed successfully.\" << std::endl;\n\n        sc_stop(); \/\/ End the simulation\n    }\n};\n\n\/\/ sc_main: the entry point of the SystemC simulation\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); \/\/ Instantiate the testbench\n    sc_start();         \/\/ Start the simulation\n    return 0;\n}\n",
        "signal":"sc_in<int> matrix[5*5];\nsc_out<int> trace;\nsc_out<int> norm;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input.\n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<int> matrix[5*5];\nsc_out<int> trace;\nsc_out<int> norm;\n> **Note**:\n   - Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n   - If the static const are provided, insure to write them in the SystemC code as well.\n\n**C++\/C Code**:\n```\n\/\/ C++ program to find trace and \n\/\/ normal of given matrix \n#include<bits\/stdc++.h> \nusing namespace std; \n\n\/\/ Size of given matrix \nconst int MAX = 100; \n\n\/\/ Returns Normal of a matrix of \n\/\/ size n x n \nint findNormal(int mat[][MAX], int n) \n{ \n\tint sum = 0; \n\tfor (int i = 0; i < n; i++) \n\t\tfor (int j = 0; j < n; j++) \n\t\t\tsum += mat[i][j] * mat[i][j]; \n\treturn sqrt(sum); \n} \n\n\/\/ Returns trace of a matrix of \n\/\/ size n x n \nint findTrace(int mat[][MAX], int n) \n{ \n\tint sum = 0; \n\tfor (int i = 0; i < n; i++) \n\t\tsum += mat[i][i]; \n\treturn sum; \n} \n\n\/\/ Driven code \nint main() \n{ \n\tint mat[][MAX] = {{1, 1, 1, 1, 1}, \n\t\t{2, 2, 2, 2, 2}, \n\t\t{3, 3, 3, 3, 3}, \n\t\t{4, 4, 4, 4, 4}, \n\t\t{5, 5, 5, 5, 5}}; \n\tcout << \"Trace of Matrix = \" << \n\t\t\tfindTrace(mat, 5) << endl; \n\tcout << \"Normal of Matrix = \" << \n\t\t\tfindNormal(mat, 5) << endl; \n\treturn 0; \n} \n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\nFew_shot_example_1:\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        dont_initialize();\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n\nFew_shot_example_2:\n#include <systemc.h>\n\n\/\/ Module: BubbleSort\n\/\/ Sorts a small fixed-size array of integers using the bubble sort algorithm.\nSC_MODULE(BubbleSort) {\n    sc_in<bool>  clk;      \/\/ Clock signal\n    sc_in<bool>  start;    \/\/ Start signal to begin sorting\n    sc_out<bool> done;     \/\/ Signal asserted when sorting is complete\n\n    sc_in<int>   in_arr[4];  \/\/ Input array of 4 integers to be sorted\n    sc_out<int>  out_arr[4]; \/\/ Output array of 4 sorted integers\n\n    int buf[4];  \/\/ Internal buffer to hold array elements during sorting\n\n    \/\/ Constructor: registers the sorting process with the clock\n    SC_CTOR(BubbleSort) {\n        SC_THREAD(sort_proc);\n        sensitive << clk.pos();\n    }\n\n    \/\/ Thread: waits for start, performs bubble sort, writes results, toggles done\n    void sort_proc() {\n        const int N = 4;\n        while (true) {\n            wait();  \/\/ wait for next clock edge\n            if (start.read()) {\n                \/\/ Read inputs into internal buffer\n                for (int i = 0; i < N; ++i)\n                    buf[i] = in_arr[i].read();\n\n                \/\/ Perform bubble sort on buffer[]\n                for (int i = 0; i < N - 1; ++i)\n                    for (int j = 0; j < N - i - 1; ++j)\n                        if (buf[j] > buf[j + 1])\n                            std::swap(buf[j], buf[j + 1]);\n\n                \/\/ Write sorted results to output ports\n                for (int i = 0; i < N; ++i)\n                    out_arr[i].write(buf[i]);\n\n                \/\/ Signal done for one cycle\n                done.write(true);\n                wait();\n                done.write(false);\n            }\n        }\n    }\n};\n\nFew_shot_example_3:\n#include <systemc.h>\n\n\/\/ Module: MatrixAdder\n\/\/ Adds two 4×4 matrices of integers element-wise.\nSC_MODULE(MatrixAdder) {\n    sc_in<int> A[4*4];   \/\/ Flattened 4×4 input matrix A (16 elements)\n    sc_in<int> B[4*4];   \/\/ Flattened 4×4 input matrix B (16 elements)\n    sc_out<int> C[4*4];  \/\/ Flattened 4×4 output matrix C = A + B\n\n    \/\/ Constructor: registers a combinational add method sensitive to all inputs\n    SC_CTOR(MatrixAdder) {\n        SC_METHOD(do_add);\n        \/\/ Make the add method sensitive to every element of A and B\n        for (int i = 0; i < 4*4; i++) {\n            sensitive << A[i] << B[i];\n        }\n    }\n\n    \/\/ Method: reads A[i] and B[i], writes sum into C[i] for all 16 positions\n    void do_add() {\n        for (int i = 0; i < 4*4; i++) {\n            C[i].write(A[i].read() + B[i].read());\n        }\n    }\n};\n\n\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":43,
        "task":"FindtheRootsoftheQuadraticEquation",
        "code":"\/\/ C++ program to find roots of\n\/\/ a quadratic equation\n#include <bits\/stdc++.h>\nusing namespace std;\n\n\/\/ Prints roots of quadratic equation\n\/\/ ax*2 + bx + x\nvoid findRoots(int a, int b, int c)\n{\n    \/\/ If a is 0, then equation is\n    \/\/ not quadratic, but linear\n    if (a == 0) {\n        cout << \"Invalid\";\n        return;\n    }\n\n    int d = b * b - 4 * a * c;\n    double sqrt_val = sqrt(abs(d));\n\n    if (d > 0) {\n        cout << \"Roots are real and different \";\n        cout << (double)(-b + sqrt_val) \/ (2 * a) << \" \"\n             << (double)(-b - sqrt_val) \/ (2 * a);\n    }\n    else if (d == 0) {\n        cout << \"Roots are real and same \";\n        cout << -(double)b \/ (2 * a);\n    }\n\n    \/\/ d < 0\n    else {\n        cout << \"Roots are complex \";\n        cout << -(double)b \/ (2 * a) << \" + i\"\n             << sqrt_val \/ (2 * a) << \" \"\n             << -(double)b \/ (2 * a) << \" - i\"\n             << sqrt_val \/ (2 * a);\n    }\n}\n\n\/\/ Driver code\nint main()\n{\n    int a = 1, b = -7, c = 12;\n\n    \/\/ Function call\n    findRoots(a, b, c);\n    return 0;\n}\n",
        "category":"Basic Math",
        "adoption":true,
        "reason":null,
        "module_name":"QuadraticRoots",
        "testbench":"SC_MODULE(Testbench) {\n    sc_signal<int> a_sig, b_sig, c_sig;\n    sc_signal<double> root1_sig, root2_sig, imag_sig;\n    sc_signal<bool> is_complex_sig;\n\n    QuadraticRoots dut;\n\n    SC_CTOR(Testbench) : dut(\"QuadraticRoots\") {\n        dut.a(a_sig);\n        dut.b(b_sig);\n        dut.c(c_sig);\n        dut.root1(root1_sig);\n        dut.root2(root2_sig);\n        dut.imag(imag_sig);\n        dut.is_complex(is_complex_sig);\n\n        SC_THREAD(run_test);\n    }\n\n    void run_test() {\n        a_sig = 1;\n        b_sig = -7;\n        c_sig = 12; \/\/ Expected roots: 4 and 3 (real and distinct)\n        wait(1, SC_NS);  \/\/ 等一個模擬時間單位讓 SC_METHOD 完成運算\n;\n\n        assert(is_complex_sig.read() == false);\n        double r1 = root1_sig.read();\n        double r2 = root2_sig.read();\n\n        \/\/ Order of roots can vary\n        bool case1 = std::abs(r1 - 4.0) < 1e-6 && std::abs(r2 - 3.0) < 1e-6;\n        bool case2 = std::abs(r1 - 3.0) < 1e-6 && std::abs(r2 - 4.0) < 1e-6;\n\n        std::cout << \"Real roots: \" << r1 << \" and \" << r2 << \"\\n\";\n\n        assert(is_complex_sig.read() == false);  \/\/ 確認為實根\n        assert(std::abs(r1 - 4.0) < 1e-6 || std::abs(r1 - 3.0) < 1e-6); \/\/ r1 正確\n        assert(std::abs(r2 - 4.0) < 1e-6 || std::abs(r2 - 3.0) < 1e-6); \/\/ r2 正確\n        assert(case1 || case2); \/\/ 根組合正確\n\n        std::cout << \"Test passed successfully.\" << std::endl;\n\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\");\n    sc_start();\n    return 0;\n}\n",
        "signal":"sc_in<int> a, b, c;\nsc_out<double> root1, root2;\nsc_out<double> imag;\nsc_out<bool> is_complex;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input.\n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<int> a, b, c;\nsc_out<double> root1, root2;\nsc_out<double> imag;\nsc_out<bool> is_complex;\n> **Note**:\n   - Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n   - If the static const are provided, insure to write them in the SystemC code as well.\n\n**C++\/C Code**:\n```\n\/\/ C++ program to find roots of\n\/\/ a quadratic equation\n#include <bits\/stdc++.h>\nusing namespace std;\n\n\/\/ Prints roots of quadratic equation\n\/\/ ax*2 + bx + x\nvoid findRoots(int a, int b, int c)\n{\n    \/\/ If a is 0, then equation is\n    \/\/ not quadratic, but linear\n    if (a == 0) {\n        cout << \"Invalid\";\n        return;\n    }\n\n    int d = b * b - 4 * a * c;\n    double sqrt_val = sqrt(abs(d));\n\n    if (d > 0) {\n        cout << \"Roots are real and different \";\n        cout << (double)(-b + sqrt_val) \/ (2 * a) << \" \"\n             << (double)(-b - sqrt_val) \/ (2 * a);\n    }\n    else if (d == 0) {\n        cout << \"Roots are real and same \";\n        cout << -(double)b \/ (2 * a);\n    }\n\n    \/\/ d < 0\n    else {\n        cout << \"Roots are complex \";\n        cout << -(double)b \/ (2 * a) << \" + i\"\n             << sqrt_val \/ (2 * a) << \" \"\n             << -(double)b \/ (2 * a) << \" - i\"\n             << sqrt_val \/ (2 * a);\n    }\n}\n\n\/\/ Driver code\nint main()\n{\n    int a = 1, b = -7, c = 12;\n\n    \/\/ Function call\n    findRoots(a, b, c);\n    return 0;\n}\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\nFew_shot_example_1:\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        dont_initialize();\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n\nFew_shot_example_2:\n#include <systemc.h>\n\n\/\/ Module: BubbleSort\n\/\/ Sorts a small fixed-size array of integers using the bubble sort algorithm.\nSC_MODULE(BubbleSort) {\n    sc_in<bool>  clk;      \/\/ Clock signal\n    sc_in<bool>  start;    \/\/ Start signal to begin sorting\n    sc_out<bool> done;     \/\/ Signal asserted when sorting is complete\n\n    sc_in<int>   in_arr[4];  \/\/ Input array of 4 integers to be sorted\n    sc_out<int>  out_arr[4]; \/\/ Output array of 4 sorted integers\n\n    int buf[4];  \/\/ Internal buffer to hold array elements during sorting\n\n    \/\/ Constructor: registers the sorting process with the clock\n    SC_CTOR(BubbleSort) {\n        SC_THREAD(sort_proc);\n        sensitive << clk.pos();\n    }\n\n    \/\/ Thread: waits for start, performs bubble sort, writes results, toggles done\n    void sort_proc() {\n        const int N = 4;\n        while (true) {\n            wait();  \/\/ wait for next clock edge\n            if (start.read()) {\n                \/\/ Read inputs into internal buffer\n                for (int i = 0; i < N; ++i)\n                    buf[i] = in_arr[i].read();\n\n                \/\/ Perform bubble sort on buffer[]\n                for (int i = 0; i < N - 1; ++i)\n                    for (int j = 0; j < N - i - 1; ++j)\n                        if (buf[j] > buf[j + 1])\n                            std::swap(buf[j], buf[j + 1]);\n\n                \/\/ Write sorted results to output ports\n                for (int i = 0; i < N; ++i)\n                    out_arr[i].write(buf[i]);\n\n                \/\/ Signal done for one cycle\n                done.write(true);\n                wait();\n                done.write(false);\n            }\n        }\n    }\n};\n\nFew_shot_example_3:\n#include <systemc.h>\n\n\/\/ Module: MatrixAdder\n\/\/ Adds two 4×4 matrices of integers element-wise.\nSC_MODULE(MatrixAdder) {\n    sc_in<int> A[4*4];   \/\/ Flattened 4×4 input matrix A (16 elements)\n    sc_in<int> B[4*4];   \/\/ Flattened 4×4 input matrix B (16 elements)\n    sc_out<int> C[4*4];  \/\/ Flattened 4×4 output matrix C = A + B\n\n    \/\/ Constructor: registers a combinational add method sensitive to all inputs\n    SC_CTOR(MatrixAdder) {\n        SC_METHOD(do_add);\n        \/\/ Make the add method sensitive to every element of A and B\n        for (int i = 0; i < 4*4; i++) {\n            sensitive << A[i] << B[i];\n        }\n    }\n\n    \/\/ Method: reads A[i] and B[i], writes sum into C[i] for all 16 positions\n    void do_add() {\n        for (int i = 0; i < 4*4; i++) {\n            C[i].write(A[i].read() + B[i].read());\n        }\n    }\n};\n\n\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":44,
        "task":"FindtheTransposeofaMatrix",
        "code":"\/\/ C++ Program to find the transpose \n\/\/ of a matrix\n#include <bits\/stdc++.h> \nusing namespace std; \n#define N 4\n\n\/\/ This function stores transpose \n\/\/ of A[][] in B[][]\nvoid transpose(int A[][N], \n\t\t\tint B[][N])\n{\n\tint i, j;\n\tfor (i = 0; i < N; i++)\n\t\tfor (j = 0; j < N; j++)\n\t\t\tB[i][j] = A[j][i];\n}\n\n\/\/ Driver code\nint main()\n{\n\tint A[N][N] = {{1, 1, 1, 1},\n\t\t\t\t{2, 2, 2, 2},\n\t\t\t\t{3, 3, 3, 3},\n\t\t\t\t{4, 4, 4, 4}};\n\n\tint B[N][N], i, j;\n\n\ttranspose(A, B);\n\n\tcout << \"Result matrix is \\n\";\n\tfor (i = 0; i < N; i++)\n\t{\n\t\tfor (j = 0; j < N; j++)\n\t\tcout << \" \" << B[i][j];\n\t\tcout <<\"\\n\";\n\t}\n\treturn 0;\n}\n",
        "category":"Matrix Operation",
        "adoption":true,
        "reason":null,
        "module_name":"MatrixTranspose",
        "testbench":"SC_MODULE(Testbench) {\n    \n    \/\/ Signals to connect to the MatrixTranspose ports\n    sc_signal<int> A[4*4];\n    sc_signal<int> B[4*4];\n\n    MatrixTranspose* transpose_inst;\n\n    SC_CTOR(Testbench) {\n        \/\/ Instantiate the MatrixTranspose module\n        transpose_inst = new MatrixTranspose(\"MatrixTranspose\");\n        \/\/ Connect the signals to the module's ports\n        for (int i = 0; i < 4*4; i++) {\n            transpose_inst->A[i](A[i]);\n            transpose_inst->B[i](B[i]);\n        }\n        \/\/ Create a thread to run the test cases\n        SC_THREAD(run_tests);\n    }\n\n    \/\/ Thread that initializes inputs, checks outputs, and asserts correctness\n    void run_tests() {\n        \/\/ Initialize matrix A as defined in the original C++ code:\n        \/\/ A = { {1, 1, 1, 1},\n        \/\/       {2, 2, 2, 2},\n        \/\/       {3, 3, 3, 3},\n        \/\/       {4, 4, 4, 4} }\n        for (int row = 0; row < 4; row++) {\n            for (int col = 0; col < 4; col++) {\n                int index = row * 4 + col;\n                A[index].write(row + 1); \/\/ row 0 -> 1, row 1 -> 2, etc.\n            }\n        }\n\n        \/\/ Wait for the signals to propagate and the combinational logic to settle.\n        wait(1, SC_NS);\n\n        \/\/ Check the result transposed matrix B and print the output\n        std::cout << \"Result matrix is:\" << std::endl;\n        for (int i = 0; i < 4; i++) {\n            for (int j = 0; j < 4; j++) {\n                int index = i * 4 + j;\n                \/\/ Expected value: since B[i][j] = A[j][i] and each row j of A is (j+1)\n                int expected = j + 1;\n                int result = B[index].read();\n                \/\/ Validate the result using assert\n                assert(result == expected);\n                std::cout << result << \" \";\n            }\n            std::cout << std::endl;\n        }\n        std::cout << \"All tests passed successfully.\" << std::endl;\n\n        sc_stop(); \/\/ Stop the simulation\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); \/\/ Create an instance of the Testbench\n    sc_start();         \/\/ Start the simulation\n    return 0;\n}\n",
        "signal":"sc_in<int> A[4*4];\nsc_out<int> B[4*4];",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input.\n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<int> A[4*4];\nsc_out<int> B[4*4];\n> **Note**:\n   - Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n   - If the static const are provided, insure to write them in the SystemC code as well.\n\n**C++\/C Code**:\n```\n\/\/ C++ Program to find the transpose \n\/\/ of a matrix\n#include <bits\/stdc++.h> \nusing namespace std; \n#define N 4\n\n\/\/ This function stores transpose \n\/\/ of A[][] in B[][]\nvoid transpose(int A[][N], \n\t\t\tint B[][N])\n{\n\tint i, j;\n\tfor (i = 0; i < N; i++)\n\t\tfor (j = 0; j < N; j++)\n\t\t\tB[i][j] = A[j][i];\n}\n\n\/\/ Driver code\nint main()\n{\n\tint A[N][N] = {{1, 1, 1, 1},\n\t\t\t\t{2, 2, 2, 2},\n\t\t\t\t{3, 3, 3, 3},\n\t\t\t\t{4, 4, 4, 4}};\n\n\tint B[N][N], i, j;\n\n\ttranspose(A, B);\n\n\tcout << \"Result matrix is \\n\";\n\tfor (i = 0; i < N; i++)\n\t{\n\t\tfor (j = 0; j < N; j++)\n\t\tcout << \" \" << B[i][j];\n\t\tcout <<\"\\n\";\n\t}\n\treturn 0;\n}\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\nFew_shot_example_1:\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        dont_initialize();\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n\nFew_shot_example_2:\n#include <systemc.h>\n\n\/\/ Module: BubbleSort\n\/\/ Sorts a small fixed-size array of integers using the bubble sort algorithm.\nSC_MODULE(BubbleSort) {\n    sc_in<bool>  clk;      \/\/ Clock signal\n    sc_in<bool>  start;    \/\/ Start signal to begin sorting\n    sc_out<bool> done;     \/\/ Signal asserted when sorting is complete\n\n    sc_in<int>   in_arr[4];  \/\/ Input array of 4 integers to be sorted\n    sc_out<int>  out_arr[4]; \/\/ Output array of 4 sorted integers\n\n    int buf[4];  \/\/ Internal buffer to hold array elements during sorting\n\n    \/\/ Constructor: registers the sorting process with the clock\n    SC_CTOR(BubbleSort) {\n        SC_THREAD(sort_proc);\n        sensitive << clk.pos();\n    }\n\n    \/\/ Thread: waits for start, performs bubble sort, writes results, toggles done\n    void sort_proc() {\n        const int N = 4;\n        while (true) {\n            wait();  \/\/ wait for next clock edge\n            if (start.read()) {\n                \/\/ Read inputs into internal buffer\n                for (int i = 0; i < N; ++i)\n                    buf[i] = in_arr[i].read();\n\n                \/\/ Perform bubble sort on buffer[]\n                for (int i = 0; i < N - 1; ++i)\n                    for (int j = 0; j < N - i - 1; ++j)\n                        if (buf[j] > buf[j + 1])\n                            std::swap(buf[j], buf[j + 1]);\n\n                \/\/ Write sorted results to output ports\n                for (int i = 0; i < N; ++i)\n                    out_arr[i].write(buf[i]);\n\n                \/\/ Signal done for one cycle\n                done.write(true);\n                wait();\n                done.write(false);\n            }\n        }\n    }\n};\n\nFew_shot_example_3:\n#include <systemc.h>\n\n\/\/ Module: MatrixAdder\n\/\/ Adds two 4×4 matrices of integers element-wise.\nSC_MODULE(MatrixAdder) {\n    sc_in<int> A[4*4];   \/\/ Flattened 4×4 input matrix A (16 elements)\n    sc_in<int> B[4*4];   \/\/ Flattened 4×4 input matrix B (16 elements)\n    sc_out<int> C[4*4];  \/\/ Flattened 4×4 output matrix C = A + B\n\n    \/\/ Constructor: registers a combinational add method sensitive to all inputs\n    SC_CTOR(MatrixAdder) {\n        SC_METHOD(do_add);\n        \/\/ Make the add method sensitive to every element of A and B\n        for (int i = 0; i < 4*4; i++) {\n            sensitive << A[i] << B[i];\n        }\n    }\n\n    \/\/ Method: reads A[i] and B[i], writes sum into C[i] for all 16 positions\n    void do_add() {\n        for (int i = 0; i < 4*4; i++) {\n            C[i].write(A[i].read() + B[i].read());\n        }\n    }\n};\n\n\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":45,
        "task":"HexadecimaltoDecimalConversion",
        "code":"\/\/ C++ program to convert hexadecimal \n\/\/ to decimal \n#include <bits\/stdc++.h> \nusing namespace std; \n\n\/\/ Function to convert hexadecimal \n\/\/ to decimal \nint hexadecimalToDecimal(string hexVal) \n{ \n\tint len = hexVal.size(); \n\n\t\/\/ Initializing base value to 1, \n\t\/\/ i.e 16^0 \n\tint base = 1; \n\n\tint dec_val = 0; \n\n\t\/\/ Extracting characters as digits \n\t\/\/ from last character \n\tfor (int i = len - 1; i >= 0; i--) { \n\t\t\/\/ If character lies in '0'-'9', \n\t\t\/\/ converting it to integral 0-9 \n\t\t\/\/ by subtracting 48 from ASCII value \n\t\tif (hexVal[i] >= '0' && hexVal[i] <= '9') { \n\t\t\tdec_val += (int(hexVal[i]) - 48) * base; \n\n\t\t\t\/\/ incrementing base by power \n\t\t\tbase = base * 16; \n\t\t} \n\n\t\t\/\/ If character lies in 'A'-'F' , converting \n\t\t\/\/ it to integral 10 - 15 by subtracting 55 \n\t\t\/\/ from ASCII value \n\t\telse if (hexVal[i] >= 'A' && hexVal[i] <= 'F') { \n\t\t\tdec_val += (int(hexVal[i]) - 55) * base; \n\n\t\t\t\/\/ Incrementing base by power \n\t\t\tbase = base * 16; \n\t\t} \n\t} \n\treturn dec_val; \n} \n\n\/\/ Driver code \nint main() \n{ \n\tstring hexNum = \"1A\"; \n\tcout << (hexadecimalToDecimal(hexNum)); \n\n\treturn 0; \n}\n",
        "category":"Basic Math",
        "adoption":true,
        "reason":null,
        "module_name":"HexToDecimal",
        "testbench":"SC_MODULE(Testbench) {\n    sc_signal<char> sig_hex[8];\n    sc_signal<int>  sig_dec;\n\n    HexToDecimal dut{\"HexToDecimal\"};\n\n    SC_CTOR(Testbench) {\n        for (int i = 0; i < 8; ++i)\n            dut.hex_in[i](sig_hex[i]);\n        dut.dec_out(sig_dec);\n\n        SC_THREAD(run_tests);\n    }\n\n    \/* 將 C-style 字串寫入輸入腳位（自動補 \\0） *\/\n    void write_hex(const std::string& s) {\n        int i = 0;\n        for (; i < static_cast<int>(s.size()) && i < 8; ++i)\n            sig_hex[i].write(s[i]);\n        if (i < 8) sig_hex[i++].write('\\0');\n        for (; i < 8; ++i) sig_hex[i].write('\\0');\n    }\n\n    \/* 測試流程 *\/\n    void run_tests() {\n        \/\/ ▸ 測試 1：1A → 26\n        write_hex(\"1A\");\n        wait(1, SC_NS);                 \/\/ 觸發更新\n        assert(sig_dec.read() == 26);\n        std::cout << \"Hex 1A -> \" << sig_dec.read() << '\\n';\n\n        \/\/ ▸ 測試 2：FF → 255\n        write_hex(\"FF\");\n        wait(1, SC_NS);\n        assert(sig_dec.read() == 255);\n        std::cout << \"Hex FF -> \" << sig_dec.read() << '\\n';\n\n        \/\/ ▸ 測試 3：1234 → 4660\n        write_hex(\"1234\");\n        wait(1, SC_NS);\n        assert(sig_dec.read() == 0x1234);\n        std::cout << \"Hex 1234 -> \" << sig_dec.read() << '\\n';\n\n        std::cout << \"All tests passed successfully.\\n\";\n        sc_stop();\n    }\n};\n\n\/* ──────────────────────── sc_main ──────────────────────── *\/\nint sc_main(int, char*[]) {\n    Testbench tb{\"tb\"};\n    sc_start();\n    return 0;\n}\n",
        "signal":"sc_in<char> hex_in[8];\nsc_out<int> dec_out;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input.\n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<char> hex_in[8];\nsc_out<int> dec_out;\n> **Note**:\n   - Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n   - If the static const are provided, insure to write them in the SystemC code as well.\n\n**C++\/C Code**:\n```\n\/\/ C++ program to convert hexadecimal \n\/\/ to decimal \n#include <bits\/stdc++.h> \nusing namespace std; \n\n\/\/ Function to convert hexadecimal \n\/\/ to decimal \nint hexadecimalToDecimal(string hexVal) \n{ \n\tint len = hexVal.size(); \n\n\t\/\/ Initializing base value to 1, \n\t\/\/ i.e 16^0 \n\tint base = 1; \n\n\tint dec_val = 0; \n\n\t\/\/ Extracting characters as digits \n\t\/\/ from last character \n\tfor (int i = len - 1; i >= 0; i--) { \n\t\t\/\/ If character lies in '0'-'9', \n\t\t\/\/ converting it to integral 0-9 \n\t\t\/\/ by subtracting 48 from ASCII value \n\t\tif (hexVal[i] >= '0' && hexVal[i] <= '9') { \n\t\t\tdec_val += (int(hexVal[i]) - 48) * base; \n\n\t\t\t\/\/ incrementing base by power \n\t\t\tbase = base * 16; \n\t\t} \n\n\t\t\/\/ If character lies in 'A'-'F' , converting \n\t\t\/\/ it to integral 10 - 15 by subtracting 55 \n\t\t\/\/ from ASCII value \n\t\telse if (hexVal[i] >= 'A' && hexVal[i] <= 'F') { \n\t\t\tdec_val += (int(hexVal[i]) - 55) * base; \n\n\t\t\t\/\/ Incrementing base by power \n\t\t\tbase = base * 16; \n\t\t} \n\t} \n\treturn dec_val; \n} \n\n\/\/ Driver code \nint main() \n{ \n\tstring hexNum = \"1A\"; \n\tcout << (hexadecimalToDecimal(hexNum)); \n\n\treturn 0; \n}\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\nFew_shot_example_1:\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        dont_initialize();\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n\nFew_shot_example_2:\n#include <systemc.h>\n\n\/\/ Module: BubbleSort\n\/\/ Sorts a small fixed-size array of integers using the bubble sort algorithm.\nSC_MODULE(BubbleSort) {\n    sc_in<bool>  clk;      \/\/ Clock signal\n    sc_in<bool>  start;    \/\/ Start signal to begin sorting\n    sc_out<bool> done;     \/\/ Signal asserted when sorting is complete\n\n    sc_in<int>   in_arr[4];  \/\/ Input array of 4 integers to be sorted\n    sc_out<int>  out_arr[4]; \/\/ Output array of 4 sorted integers\n\n    int buf[4];  \/\/ Internal buffer to hold array elements during sorting\n\n    \/\/ Constructor: registers the sorting process with the clock\n    SC_CTOR(BubbleSort) {\n        SC_THREAD(sort_proc);\n        sensitive << clk.pos();\n    }\n\n    \/\/ Thread: waits for start, performs bubble sort, writes results, toggles done\n    void sort_proc() {\n        const int N = 4;\n        while (true) {\n            wait();  \/\/ wait for next clock edge\n            if (start.read()) {\n                \/\/ Read inputs into internal buffer\n                for (int i = 0; i < N; ++i)\n                    buf[i] = in_arr[i].read();\n\n                \/\/ Perform bubble sort on buffer[]\n                for (int i = 0; i < N - 1; ++i)\n                    for (int j = 0; j < N - i - 1; ++j)\n                        if (buf[j] > buf[j + 1])\n                            std::swap(buf[j], buf[j + 1]);\n\n                \/\/ Write sorted results to output ports\n                for (int i = 0; i < N; ++i)\n                    out_arr[i].write(buf[i]);\n\n                \/\/ Signal done for one cycle\n                done.write(true);\n                wait();\n                done.write(false);\n            }\n        }\n    }\n};\n\nFew_shot_example_3:\n#include <systemc.h>\n\n\/\/ Module: MatrixAdder\n\/\/ Adds two 4×4 matrices of integers element-wise.\nSC_MODULE(MatrixAdder) {\n    sc_in<int> A[4*4];   \/\/ Flattened 4×4 input matrix A (16 elements)\n    sc_in<int> B[4*4];   \/\/ Flattened 4×4 input matrix B (16 elements)\n    sc_out<int> C[4*4];  \/\/ Flattened 4×4 output matrix C = A + B\n\n    \/\/ Constructor: registers a combinational add method sensitive to all inputs\n    SC_CTOR(MatrixAdder) {\n        SC_METHOD(do_add);\n        \/\/ Make the add method sensitive to every element of A and B\n        for (int i = 0; i < 4*4; i++) {\n            sensitive << A[i] << B[i];\n        }\n    }\n\n    \/\/ Method: reads A[i] and B[i], writes sum into C[i] for all 16 positions\n    void do_add() {\n        for (int i = 0; i < 4*4; i++) {\n            C[i].write(A[i].read() + B[i].read());\n        }\n    }\n};\n\n\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":46,
        "task":"InterchangeElementsofFirstAndLastColumnsInMatrix",
        "code":"\/\/ C++ code to swap the element of first \n\/\/ and last row and display the result \n#include <iostream> \nusing namespace std; \n\n#define n 4 \n\nvoid interchangeFirstLast(int m[][n]) \n{ \n\t\tint rows = n; \n\t\t\n\t\t\/\/ Swapping of element between first \n\t\t\/\/ and last rows \n\t\tfor (int i = 0; i < n; i++) \n\t\t{ \n\t\t\tint t = m[0][i]; \n\t\t\tm[0][i] = m[rows - 1][i]; \n\t\t\tm[rows - 1][i] = t; \n\t\t} \n} \n\n\/\/ Driver code \nint main() \n{ \n\t\/\/ input in the array \n\tint m[n][n] = {{8, 9, 7, 6}, \n\t\t\t\t{4, 7, 6, 5}, \n\t\t\t\t{3, 2, 1, 8}, \n\t\t\t\t{9, 9, 7, 7}}; \n\t\t\t\t\n\tinterchangeFirstLast(m); \n\t\n\t\/\/ Printing the interchanged matrix \n\tfor (int i = 0; i < n; i++) \n\t{ \n\t\tfor (int j = 0; j < n; j++) \n\t\t\tcout << m[i][j] << \" \"; \n\t\tcout << endl; \n\t} \n} \n\n\/\/ This code is contributed by Anant Agarwal. \n",
        "category":"Matrix Operation",
        "adoption":true,
        "reason":null,
        "module_name":"MatrixSwapper",
        "testbench":"SC_MODULE(Testbench) {\n\n    \n    sc_signal<int> in[4*4];\n    sc_signal<int> out[4*4];\n    MatrixSwapper* swapper;\n\n    SC_CTOR(Testbench) {\n        swapper = new MatrixSwapper(\"swapper\");\n        \/\/ Connect the signals to the MatrixSwapper ports\n        for (int i = 0; i < 4*4; i++) {\n            swapper->in[i](in[i]);\n            swapper->out[i](out[i]);\n        }\n        SC_THREAD(run_tests);\n    }\n\n    \/\/ Thread that runs the test, checks outputs, and asserts correctness\n    void run_tests() {\n        \/\/ Initialize the matrix as in the original C++ code:\n        \/\/   { {8, 9, 7, 6},\n        \/\/     {4, 7, 6, 5},\n        \/\/     {3, 2, 1, 8},\n        \/\/     {9, 9, 7, 7} }\n        int m[4*4] = {8, 9, 7, 6,\n                       4, 7, 6, 5,\n                       3, 2, 1, 8,\n                       9, 9, 7, 7};\n        for (int i = 0; i < 4*4; i++) {\n            in[i].write(m[i]);\n        }\n\n        \/\/ Wait for signals to propagate\n        wait(1, SC_NS);\n\n        \/\/ Expected output after swapping first and last rows:\n        \/\/   { {9, 9, 7, 7},\n        \/\/     {4, 7, 6, 5},\n        \/\/     {3, 2, 1, 8},\n        \/\/     {8, 9, 7, 6} }\n        int expected[4*4] = {9, 9, 7, 7,\n                              4, 7, 6, 5,\n                              3, 2, 1, 8,\n                              8, 9, 7, 6};\n\n        \/\/ Print and check the result matrix\n        std::cout << \"Swapped Matrix:\" << std::endl;\n        for (int row = 0; row < 4; row++) {\n            for (int col = 0; col < 4; col++) {\n                int idx = row * 4 + col;\n                int result = out[idx].read();\n                std::cout << result << \" \";\n                assert(result == expected[idx]);\n            }\n            std::cout << std::endl;\n        }\n        std::cout << \"All tests passed successfully.\" << std::endl;\n\n        sc_stop(); \/\/ Stop the simulation\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); \/\/ Create an instance of the Testbench\n    sc_start();         \/\/ Start the simulation\n    return 0;\n}\n",
        "signal":"sc_in<int> in[4*4];\nsc_out<int> out[4*4];",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input.\n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<int> in[4*4];\nsc_out<int> out[4*4];\n> **Note**:\n   - Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n   - If the static const are provided, insure to write them in the SystemC code as well.\n\n**C++\/C Code**:\n```\n\/\/ C++ code to swap the element of first \n\/\/ and last row and display the result \n#include <iostream> \nusing namespace std; \n\n#define n 4 \n\nvoid interchangeFirstLast(int m[][n]) \n{ \n\t\tint rows = n; \n\t\t\n\t\t\/\/ Swapping of element between first \n\t\t\/\/ and last rows \n\t\tfor (int i = 0; i < n; i++) \n\t\t{ \n\t\t\tint t = m[0][i]; \n\t\t\tm[0][i] = m[rows - 1][i]; \n\t\t\tm[rows - 1][i] = t; \n\t\t} \n} \n\n\/\/ Driver code \nint main() \n{ \n\t\/\/ input in the array \n\tint m[n][n] = {{8, 9, 7, 6}, \n\t\t\t\t{4, 7, 6, 5}, \n\t\t\t\t{3, 2, 1, 8}, \n\t\t\t\t{9, 9, 7, 7}}; \n\t\t\t\t\n\tinterchangeFirstLast(m); \n\t\n\t\/\/ Printing the interchanged matrix \n\tfor (int i = 0; i < n; i++) \n\t{ \n\t\tfor (int j = 0; j < n; j++) \n\t\t\tcout << m[i][j] << \" \"; \n\t\tcout << endl; \n\t} \n} \n\n\/\/ This code is contributed by Anant Agarwal. \n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\nFew_shot_example_1:\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        dont_initialize();\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n\nFew_shot_example_2:\n#include <systemc.h>\n\n\/\/ Module: BubbleSort\n\/\/ Sorts a small fixed-size array of integers using the bubble sort algorithm.\nSC_MODULE(BubbleSort) {\n    sc_in<bool>  clk;      \/\/ Clock signal\n    sc_in<bool>  start;    \/\/ Start signal to begin sorting\n    sc_out<bool> done;     \/\/ Signal asserted when sorting is complete\n\n    sc_in<int>   in_arr[4];  \/\/ Input array of 4 integers to be sorted\n    sc_out<int>  out_arr[4]; \/\/ Output array of 4 sorted integers\n\n    int buf[4];  \/\/ Internal buffer to hold array elements during sorting\n\n    \/\/ Constructor: registers the sorting process with the clock\n    SC_CTOR(BubbleSort) {\n        SC_THREAD(sort_proc);\n        sensitive << clk.pos();\n    }\n\n    \/\/ Thread: waits for start, performs bubble sort, writes results, toggles done\n    void sort_proc() {\n        const int N = 4;\n        while (true) {\n            wait();  \/\/ wait for next clock edge\n            if (start.read()) {\n                \/\/ Read inputs into internal buffer\n                for (int i = 0; i < N; ++i)\n                    buf[i] = in_arr[i].read();\n\n                \/\/ Perform bubble sort on buffer[]\n                for (int i = 0; i < N - 1; ++i)\n                    for (int j = 0; j < N - i - 1; ++j)\n                        if (buf[j] > buf[j + 1])\n                            std::swap(buf[j], buf[j + 1]);\n\n                \/\/ Write sorted results to output ports\n                for (int i = 0; i < N; ++i)\n                    out_arr[i].write(buf[i]);\n\n                \/\/ Signal done for one cycle\n                done.write(true);\n                wait();\n                done.write(false);\n            }\n        }\n    }\n};\n\nFew_shot_example_3:\n#include <systemc.h>\n\n\/\/ Module: MatrixAdder\n\/\/ Adds two 4×4 matrices of integers element-wise.\nSC_MODULE(MatrixAdder) {\n    sc_in<int> A[4*4];   \/\/ Flattened 4×4 input matrix A (16 elements)\n    sc_in<int> B[4*4];   \/\/ Flattened 4×4 input matrix B (16 elements)\n    sc_out<int> C[4*4];  \/\/ Flattened 4×4 output matrix C = A + B\n\n    \/\/ Constructor: registers a combinational add method sensitive to all inputs\n    SC_CTOR(MatrixAdder) {\n        SC_METHOD(do_add);\n        \/\/ Make the add method sensitive to every element of A and B\n        for (int i = 0; i < 4*4; i++) {\n            sensitive << A[i] << B[i];\n        }\n    }\n\n    \/\/ Method: reads A[i] and B[i], writes sum into C[i] for all 16 positions\n    void do_add() {\n        for (int i = 0; i < 4*4; i++) {\n            C[i].write(A[i].read() + B[i].read());\n        }\n    }\n};\n\n\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":47,
        "task":"InterchangeElementsofFirstAndLastRowsinMatrix",
        "code":"\/\/ C++ code to swap the element of first \n\/\/ and last column and display the result \n#include <iostream> \nusing namespace std; \n\n#define n 4 \n\nvoid interchangeFirstLast(int m[][n]) \n{ \n\t\/\/ swapping of element between first \n\t\/\/ and last columns \n\tfor (int i = 0; i < n; i++) \n\t{ \n\t\tint t = m[i][0]; \n\t\tm[i][0] = m[i][n - 1]; \n\t\tm[i][n - 1] = t; \n\t} \n} \n\n\/\/ Driver function \nint main() \n{ \n\t\/\/ input in the array \n\tint m[n][n] = {{8, 9, 7, 6}, \n\t\t\t\t{4, 7, 6, 5}, \n\t\t\t\t{3, 2, 1, 8}, \n\t\t\t\t{9, 9, 7, 7}}; \n\n\tinterchangeFirstLast(m); \n\n\t\/\/ printing the interchanged matrix \n\tfor (int i = 0; i < n; i++) \n\t{ \n\t\tfor (int j = 0; j < n; j++) \n\t\t\tcout << m[i][j] << \" \"; \n\t\tcout << endl; \n\t} \n} \n",
        "category":"Matrix Operation",
        "adoption":true,
        "reason":null,
        "module_name":"MatrixSwapper",
        "testbench":"SC_MODULE(Testbench) {\n\n    sc_signal<int> in[4*4];\n    sc_signal<int> out[4*4];\n\n    MatrixSwapper* matrixSwapper;\n\n    SC_CTOR(Testbench) {\n        \/\/ Instantiate the MatrixSwapper module\n        matrixSwapper = new MatrixSwapper(\"matrixSwapper\");\n        \/\/ Connect the testbench signals to the module's ports\n        for (int i = 0; i < 4*4; i++) {\n            matrixSwapper->in[i](in[i]);\n            matrixSwapper->out[i](out[i]);\n        }\n        SC_THREAD(run_tests);\n    }\n\n    void run_tests() {\n        \/\/ Define the input matrix as per the original C++ code:\n        \/\/ { {8, 9, 7, 6},\n        \/\/   {4, 7, 6, 5},\n        \/\/   {3, 2, 1, 8},\n        \/\/   {9, 9, 7, 7} }\n        int input_matrix[4*4] = {\n            8, 9, 7, 6,\n            4, 7, 6, 5,\n            3, 2, 1, 8,\n            9, 9, 7, 7\n        };\n\n        \/\/ Expected output after swapping first and last columns:\n        \/\/ { {6, 9, 7, 8},\n        \/\/   {5, 7, 6, 4},\n        \/\/   {8, 2, 1, 3},\n        \/\/   {7, 9, 7, 9} }\n        int expected[4*4] = {\n            6, 9, 7, 8,\n            5, 7, 6, 4,\n            8, 2, 1, 3,\n            7, 9, 7, 9\n        };\n\n        \/\/ Write input matrix values into signals\n        for (int i = 0; i < 4*4; i++) {\n            in[i].write(input_matrix[i]);\n        }\n\n        \/\/ Allow the signals to propagate\n        wait(1, SC_NS);\n\n        \/\/ Check the swapped matrix and print the result\n        std::cout << \"Swapped Matrix:\" << std::endl;\n        for (int row = 0; row < 4; row++) {\n            for (int col = 0; col < 4; col++) {\n                int index = row * 4 + col;\n                int result = out[index].read();\n                \/\/ Assert that the result matches the expected value\n                assert(result == expected[index]);\n                std::cout << result << \" \";\n            }\n            std::cout << std::endl;\n        }\n        std::cout << \"All tests passed successfully.\" << std::endl;\n\n        sc_stop(); \/\/ Stop the simulation\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); \/\/ Create an instance of the Testbench\n    sc_start();         \/\/ Start the simulation\n    return 0;\n}\n",
        "signal":"sc_in<int> in[4*4];\nsc_out<int> out[4*4];",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input.\n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<int> in[4*4];\nsc_out<int> out[4*4];\n> **Note**:\n   - Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n   - If the static const are provided, insure to write them in the SystemC code as well.\n\n**C++\/C Code**:\n```\n\/\/ C++ code to swap the element of first \n\/\/ and last column and display the result \n#include <iostream> \nusing namespace std; \n\n#define n 4 \n\nvoid interchangeFirstLast(int m[][n]) \n{ \n\t\/\/ swapping of element between first \n\t\/\/ and last columns \n\tfor (int i = 0; i < n; i++) \n\t{ \n\t\tint t = m[i][0]; \n\t\tm[i][0] = m[i][n - 1]; \n\t\tm[i][n - 1] = t; \n\t} \n} \n\n\/\/ Driver function \nint main() \n{ \n\t\/\/ input in the array \n\tint m[n][n] = {{8, 9, 7, 6}, \n\t\t\t\t{4, 7, 6, 5}, \n\t\t\t\t{3, 2, 1, 8}, \n\t\t\t\t{9, 9, 7, 7}}; \n\n\tinterchangeFirstLast(m); \n\n\t\/\/ printing the interchanged matrix \n\tfor (int i = 0; i < n; i++) \n\t{ \n\t\tfor (int j = 0; j < n; j++) \n\t\t\tcout << m[i][j] << \" \"; \n\t\tcout << endl; \n\t} \n} \n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\nFew_shot_example_1:\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        dont_initialize();\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n\nFew_shot_example_2:\n#include <systemc.h>\n\n\/\/ Module: BubbleSort\n\/\/ Sorts a small fixed-size array of integers using the bubble sort algorithm.\nSC_MODULE(BubbleSort) {\n    sc_in<bool>  clk;      \/\/ Clock signal\n    sc_in<bool>  start;    \/\/ Start signal to begin sorting\n    sc_out<bool> done;     \/\/ Signal asserted when sorting is complete\n\n    sc_in<int>   in_arr[4];  \/\/ Input array of 4 integers to be sorted\n    sc_out<int>  out_arr[4]; \/\/ Output array of 4 sorted integers\n\n    int buf[4];  \/\/ Internal buffer to hold array elements during sorting\n\n    \/\/ Constructor: registers the sorting process with the clock\n    SC_CTOR(BubbleSort) {\n        SC_THREAD(sort_proc);\n        sensitive << clk.pos();\n    }\n\n    \/\/ Thread: waits for start, performs bubble sort, writes results, toggles done\n    void sort_proc() {\n        const int N = 4;\n        while (true) {\n            wait();  \/\/ wait for next clock edge\n            if (start.read()) {\n                \/\/ Read inputs into internal buffer\n                for (int i = 0; i < N; ++i)\n                    buf[i] = in_arr[i].read();\n\n                \/\/ Perform bubble sort on buffer[]\n                for (int i = 0; i < N - 1; ++i)\n                    for (int j = 0; j < N - i - 1; ++j)\n                        if (buf[j] > buf[j + 1])\n                            std::swap(buf[j], buf[j + 1]);\n\n                \/\/ Write sorted results to output ports\n                for (int i = 0; i < N; ++i)\n                    out_arr[i].write(buf[i]);\n\n                \/\/ Signal done for one cycle\n                done.write(true);\n                wait();\n                done.write(false);\n            }\n        }\n    }\n};\n\nFew_shot_example_3:\n#include <systemc.h>\n\n\/\/ Module: MatrixAdder\n\/\/ Adds two 4×4 matrices of integers element-wise.\nSC_MODULE(MatrixAdder) {\n    sc_in<int> A[4*4];   \/\/ Flattened 4×4 input matrix A (16 elements)\n    sc_in<int> B[4*4];   \/\/ Flattened 4×4 input matrix B (16 elements)\n    sc_out<int> C[4*4];  \/\/ Flattened 4×4 output matrix C = A + B\n\n    \/\/ Constructor: registers a combinational add method sensitive to all inputs\n    SC_CTOR(MatrixAdder) {\n        SC_METHOD(do_add);\n        \/\/ Make the add method sensitive to every element of A and B\n        for (int i = 0; i < 4*4; i++) {\n            sensitive << A[i] << B[i];\n        }\n    }\n\n    \/\/ Method: reads A[i] and B[i], writes sum into C[i] for all 16 positions\n    void do_add() {\n        for (int i = 0; i < 4*4; i++) {\n            C[i].write(A[i].read() + B[i].read());\n        }\n    }\n};\n\n\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":48,
        "task":"MakeaSimpleCalculator",
        "code":"\/\/ C++ Program to make a Simple Calculator using\n\/\/ switch-case statements\n#include <bits\/stdc++.h>\nusing namespace std;\n\nint main() {\n    char op;\n    double a, b, res;\n\n    \/\/ Read the operator\n    cout << \"Enter an operator (+, -, *, \/): \";\n    cin >> op;\n\n    \/\/ Read the two numbers\n    cout << \"Enter two numbers: \";\n    cin >> a >> b;\n\n    \/\/ Define all four operations in the corresponding\n    \/\/ switch-case\n    switch (op) {\n    case '+':\n        res = a + b;\n        break;\n    case '-':\n        res = a - b;\n        break;\n    case '*':\n        res = a * b;\n        break;\n    case '\/':\n        res = a \/ b;\n        break;\n    default:\n        cout << \"Error! Operator is not correct\";\n        res = -DBL_MAX;\n    }\n    \n      \/\/ Printing the result\n    if (res != -DBL_MAX)\n        cout << \"Result: \" << res;\n    return 0;\n}\n",
        "category":"Basic Math",
        "adoption":true,
        "reason":null,
        "module_name":"Calculator",
        "testbench":"SC_MODULE(Testbench) {\n    sc_signal<char>  op_sig;\n    sc_signal<double> a_sig, b_sig, res_sig;\n    sc_signal<bool> valid_sig;\n\n    Calculator calc_inst;\n\n    SC_CTOR(Testbench) : calc_inst(\"Calculator\") {\n        calc_inst.op(op_sig);\n        calc_inst.a(a_sig);\n        calc_inst.b(b_sig);\n        calc_inst.res(res_sig);\n        calc_inst.valid(valid_sig);\n\n        SC_THREAD(run_tests);\n    }\n\n    void run_tests() {\n        struct TestCase {\n            char op;\n            double a, b;\n            double expected;\n            bool valid;\n        };\n\n        TestCase cases[] = {\n            {'+', 3.0, 4.0, 7.0, true},\n            {'-', 10.0, 2.5, 7.5, true},\n            {'*', 5.0, 6.0, 30.0, true},\n            {'\/', 9.0, 3.0, 3.0, true},\n            {'\/', 5.0, 0.0, 0.0, false},\n            {'%', 8.0, 3.0, 0.0, false} \/\/ Invalid operator\n        };\n\n        for (const auto& test : cases) {\n            op_sig.write(test.op);\n            a_sig.write(test.a);\n            b_sig.write(test.b);\n            wait(1, SC_NS);\n\n            std::cout << \"Test: \" << test.a << \" \" << test.op << \" \" << test.b << \"\\n\";\n            std::cout << \"→ Result = \" << res_sig.read()\n                      << \", Valid = \" << valid_sig.read() << \"\\n\";\n\n            assert(valid_sig.read() == test.valid);\n            if (test.valid) {\n                assert(fabs(res_sig.read() - test.expected) < 1e-6);\n            }\n        }\n\n        std::cout << \"All tests passed successfully.\" << std::endl;\n        sc_stop();\n    }\n};\n\n\/\/ ─────────────── sc_main ───────────────\nint sc_main(int, char*[]) {\n    Testbench tb(\"tb\");\n    sc_start();\n    return 0;\n}\n",
        "signal":"sc_in<char>  op;\nsc_in<double> a, b;\nsc_out<double> res;\nsc_out<bool> valid;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input.\n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<char>  op;\nsc_in<double> a, b;\nsc_out<double> res;\nsc_out<bool> valid;\n> **Note**:\n   - Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n   - If the static const are provided, insure to write them in the SystemC code as well.\n\n**C++\/C Code**:\n```\n\/\/ C++ Program to make a Simple Calculator using\n\/\/ switch-case statements\n#include <bits\/stdc++.h>\nusing namespace std;\n\nint main() {\n    char op;\n    double a, b, res;\n\n    \/\/ Read the operator\n    cout << \"Enter an operator (+, -, *, \/): \";\n    cin >> op;\n\n    \/\/ Read the two numbers\n    cout << \"Enter two numbers: \";\n    cin >> a >> b;\n\n    \/\/ Define all four operations in the corresponding\n    \/\/ switch-case\n    switch (op) {\n    case '+':\n        res = a + b;\n        break;\n    case '-':\n        res = a - b;\n        break;\n    case '*':\n        res = a * b;\n        break;\n    case '\/':\n        res = a \/ b;\n        break;\n    default:\n        cout << \"Error! Operator is not correct\";\n        res = -DBL_MAX;\n    }\n    \n      \/\/ Printing the result\n    if (res != -DBL_MAX)\n        cout << \"Result: \" << res;\n    return 0;\n}\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\nFew_shot_example_1:\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        dont_initialize();\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n\nFew_shot_example_2:\n#include <systemc.h>\n\n\/\/ Module: BubbleSort\n\/\/ Sorts a small fixed-size array of integers using the bubble sort algorithm.\nSC_MODULE(BubbleSort) {\n    sc_in<bool>  clk;      \/\/ Clock signal\n    sc_in<bool>  start;    \/\/ Start signal to begin sorting\n    sc_out<bool> done;     \/\/ Signal asserted when sorting is complete\n\n    sc_in<int>   in_arr[4];  \/\/ Input array of 4 integers to be sorted\n    sc_out<int>  out_arr[4]; \/\/ Output array of 4 sorted integers\n\n    int buf[4];  \/\/ Internal buffer to hold array elements during sorting\n\n    \/\/ Constructor: registers the sorting process with the clock\n    SC_CTOR(BubbleSort) {\n        SC_THREAD(sort_proc);\n        sensitive << clk.pos();\n    }\n\n    \/\/ Thread: waits for start, performs bubble sort, writes results, toggles done\n    void sort_proc() {\n        const int N = 4;\n        while (true) {\n            wait();  \/\/ wait for next clock edge\n            if (start.read()) {\n                \/\/ Read inputs into internal buffer\n                for (int i = 0; i < N; ++i)\n                    buf[i] = in_arr[i].read();\n\n                \/\/ Perform bubble sort on buffer[]\n                for (int i = 0; i < N - 1; ++i)\n                    for (int j = 0; j < N - i - 1; ++j)\n                        if (buf[j] > buf[j + 1])\n                            std::swap(buf[j], buf[j + 1]);\n\n                \/\/ Write sorted results to output ports\n                for (int i = 0; i < N; ++i)\n                    out_arr[i].write(buf[i]);\n\n                \/\/ Signal done for one cycle\n                done.write(true);\n                wait();\n                done.write(false);\n            }\n        }\n    }\n};\n\nFew_shot_example_3:\n#include <systemc.h>\n\n\/\/ Module: MatrixAdder\n\/\/ Adds two 4×4 matrices of integers element-wise.\nSC_MODULE(MatrixAdder) {\n    sc_in<int> A[4*4];   \/\/ Flattened 4×4 input matrix A (16 elements)\n    sc_in<int> B[4*4];   \/\/ Flattened 4×4 input matrix B (16 elements)\n    sc_out<int> C[4*4];  \/\/ Flattened 4×4 output matrix C = A + B\n\n    \/\/ Constructor: registers a combinational add method sensitive to all inputs\n    SC_CTOR(MatrixAdder) {\n        SC_METHOD(do_add);\n        \/\/ Make the add method sensitive to every element of A and B\n        for (int i = 0; i < 4*4; i++) {\n            sensitive << A[i] << B[i];\n        }\n    }\n\n    \/\/ Method: reads A[i] and B[i], writes sum into C[i] for all 16 positions\n    void do_add() {\n        for (int i = 0; i < 4*4; i++) {\n            C[i].write(A[i].read() + B[i].read());\n        }\n    }\n};\n\n\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":49,
        "task":"MergeTwoArrays",
        "code":"\/\/ C++ program to merge two sorted arrays\/ \n#include<bits\/stdc++.h> \nusing namespace std; \n\nvoid mergeArrays(int arr1[], int arr2[], int n1, \n\t\t\t\t\t\t\tint n2, int arr3[]) \n{ \n\tint i = 0, j = 0, k = 0; \n\t\/\/ traverse the arr1 and insert its element in arr3 \n\twhile(i < n1){ \n\tarr3[k++] = arr1[i++]; \n\t} \n\t\t\n\t\/\/ now traverse arr2 and insert in arr3 \n\twhile(j < n2){ \n\tarr3[k++] = arr2[j++]; \n\t} \n\t\t\n\t\/\/ sort the whole array arr3 \n\tsort(arr3, arr3+n1+n2); \n} \n\n\/\/ Driver code \nint main() \n{ \n\tint arr1[] = {1, 3, 5, 7}; \n\tint n1 = sizeof(arr1) \/ sizeof(arr1[0]); \n\n\tint arr2[] = {2, 4, 6, 8}; \n\tint n2 = sizeof(arr2) \/ sizeof(arr2[0]); \n\n\tint arr3[n1+n2]; \n\tmergeArrays(arr1, arr2, n1, n2, arr3); \n\n\tcout << \"Array after merging\" <<endl; \n\tfor (int i=0; i < n1+n2; i++) \n\t\tcout << arr3[i] << \" \"; \n\n\treturn 0; \n} \n",
        "category":"Array Operation",
        "adoption":true,
        "reason":null,
        "module_name":"MergeArrays",
        "testbench":"SC_MODULE(Testbench) {\n    sc_clock clk{\"clk\", 1, SC_NS};\n    sc_signal<bool> start, done;\n    sc_signal<int> sig_arr1[4], sig_arr2[4], sig_arr3[8];\n\n    MergeArrays* dut;\n\n    SC_CTOR(Testbench) {\n        dut = new MergeArrays(\"MergeArrays\");\n        dut->clk(clk);\n        dut->start(start);\n        dut->done(done);\n        for (int i = 0; i < 4; ++i) dut->arr1[i](sig_arr1[i]);\n        for (int i = 0; i < 4; ++i) dut->arr2[i](sig_arr2[i]);\n        for (int i = 0; i < 8; ++i) dut->arr3[i](sig_arr3[i]);\n\n        SC_THREAD(run_tests);\n    }\n\n    void run_tests() {\n        int data1[4] = {1, 3, 5, 7};\n        int data2[4] = {2, 4, 6, 8};\n        int expected[8] = {1, 2, 3, 4, 5, 6, 7, 8};\n\n        for (int i = 0; i < 4; ++i) sig_arr1[i].write(data1[i]);\n        for (int i = 0; i < 4; ++i) sig_arr2[i].write(data2[i]);\n\n        wait(clk.posedge_event());\n        start.write(true);\n        wait(clk.posedge_event());\n        start.write(false);\n\n        wait(done.posedge_event());\n\n        for (int i = 0; i < 8; ++i) {\n            int val = sig_arr3[i].read();\n            std::cout << \"arr3[\" << i << \"]: \" << val << std::endl;\n            assert(val == expected[i]);\n        }\n\n        std::cout << \"All merge tests passed successfully.\" << std::endl;\n        sc_stop();\n    }\n};\n\n\/\/ ─────────────── sc_main ───────────────\nint sc_main(int, char*[]) {\n    Testbench tb{\"tb\"};\n    sc_start();\n    return 0;\n}",
        "signal":"sc_in<bool> clk;\nsc_in<bool> start;\nsc_out<bool> done;\nsc_in<int>  arr1[4];\nsc_in<int>  arr2[4];\nsc_out<int> arr3[8];",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input.\n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<bool> clk;\nsc_in<bool> start;\nsc_out<bool> done;\nsc_in<int>  arr1[4];\nsc_in<int>  arr2[4];\nsc_out<int> arr3[8];\n> **Note**:\n   - Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n   - If the static const are provided, insure to write them in the SystemC code as well.\n\n**C++\/C Code**:\n```\n\/\/ C++ program to merge two sorted arrays\/ \n#include<bits\/stdc++.h> \nusing namespace std; \n\nvoid mergeArrays(int arr1[], int arr2[], int n1, \n\t\t\t\t\t\t\tint n2, int arr3[]) \n{ \n\tint i = 0, j = 0, k = 0; \n\t\/\/ traverse the arr1 and insert its element in arr3 \n\twhile(i < n1){ \n\tarr3[k++] = arr1[i++]; \n\t} \n\t\t\n\t\/\/ now traverse arr2 and insert in arr3 \n\twhile(j < n2){ \n\tarr3[k++] = arr2[j++]; \n\t} \n\t\t\n\t\/\/ sort the whole array arr3 \n\tsort(arr3, arr3+n1+n2); \n} \n\n\/\/ Driver code \nint main() \n{ \n\tint arr1[] = {1, 3, 5, 7}; \n\tint n1 = sizeof(arr1) \/ sizeof(arr1[0]); \n\n\tint arr2[] = {2, 4, 6, 8}; \n\tint n2 = sizeof(arr2) \/ sizeof(arr2[0]); \n\n\tint arr3[n1+n2]; \n\tmergeArrays(arr1, arr2, n1, n2, arr3); \n\n\tcout << \"Array after merging\" <<endl; \n\tfor (int i=0; i < n1+n2; i++) \n\t\tcout << arr3[i] << \" \"; \n\n\treturn 0; \n} \n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\nFew_shot_example_1:\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        dont_initialize();\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n\nFew_shot_example_2:\n#include <systemc.h>\n\n\/\/ Module: BubbleSort\n\/\/ Sorts a small fixed-size array of integers using the bubble sort algorithm.\nSC_MODULE(BubbleSort) {\n    sc_in<bool>  clk;      \/\/ Clock signal\n    sc_in<bool>  start;    \/\/ Start signal to begin sorting\n    sc_out<bool> done;     \/\/ Signal asserted when sorting is complete\n\n    sc_in<int>   in_arr[4];  \/\/ Input array of 4 integers to be sorted\n    sc_out<int>  out_arr[4]; \/\/ Output array of 4 sorted integers\n\n    int buf[4];  \/\/ Internal buffer to hold array elements during sorting\n\n    \/\/ Constructor: registers the sorting process with the clock\n    SC_CTOR(BubbleSort) {\n        SC_THREAD(sort_proc);\n        sensitive << clk.pos();\n    }\n\n    \/\/ Thread: waits for start, performs bubble sort, writes results, toggles done\n    void sort_proc() {\n        const int N = 4;\n        while (true) {\n            wait();  \/\/ wait for next clock edge\n            if (start.read()) {\n                \/\/ Read inputs into internal buffer\n                for (int i = 0; i < N; ++i)\n                    buf[i] = in_arr[i].read();\n\n                \/\/ Perform bubble sort on buffer[]\n                for (int i = 0; i < N - 1; ++i)\n                    for (int j = 0; j < N - i - 1; ++j)\n                        if (buf[j] > buf[j + 1])\n                            std::swap(buf[j], buf[j + 1]);\n\n                \/\/ Write sorted results to output ports\n                for (int i = 0; i < N; ++i)\n                    out_arr[i].write(buf[i]);\n\n                \/\/ Signal done for one cycle\n                done.write(true);\n                wait();\n                done.write(false);\n            }\n        }\n    }\n};\n\nFew_shot_example_3:\n#include <systemc.h>\n\n\/\/ Module: MatrixAdder\n\/\/ Adds two 4×4 matrices of integers element-wise.\nSC_MODULE(MatrixAdder) {\n    sc_in<int> A[4*4];   \/\/ Flattened 4×4 input matrix A (16 elements)\n    sc_in<int> B[4*4];   \/\/ Flattened 4×4 input matrix B (16 elements)\n    sc_out<int> C[4*4];  \/\/ Flattened 4×4 output matrix C = A + B\n\n    \/\/ Constructor: registers a combinational add method sensitive to all inputs\n    SC_CTOR(MatrixAdder) {\n        SC_METHOD(do_add);\n        \/\/ Make the add method sensitive to every element of A and B\n        for (int i = 0; i < 4*4; i++) {\n            sensitive << A[i] << B[i];\n        }\n    }\n\n    \/\/ Method: reads A[i] and B[i], writes sum into C[i] for all 16 positions\n    void do_add() {\n        for (int i = 0; i < 4*4; i++) {\n            C[i].write(A[i].read() + B[i].read());\n        }\n    }\n};\n\n\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":50,
        "task":"MultiplyTwoFloating-PointNumbers",
        "code":"\/\/ C++ program to multiply two \n\/\/ floating point numbers \n#include <iostream> \nusing namespace std; \n\n\/\/ Creating a user-defined function \n\/\/ called mul_floatnumbers that \n\/\/ multiplies the numbers passed to \n\/\/ it as an input. It gives you the \n\/\/ product of these numbers. \nfloat mul_floatnumbers(float a, float b) { return a * b; } \n\n\/\/ Driver code \nint main() \n{ \n\tfloat A = 1.2, B = 3.0, product; \n\n\t\/\/ Calling mul_floatnumbers function \n\tproduct = mul_floatnumbers(A, B); \n\n\t\/\/ Printing the output \n\tcout << product; \n\n\treturn 0; \n}\n",
        "category":"Basic Math",
        "adoption":true,
        "reason":null,
        "module_name":"Multiplier",
        "testbench":"SC_MODULE(Testbench) {\n    \/\/ Signals to connect to the Multiplier module ports\n    sc_signal<float> a;\n    sc_signal<float> b;\n    sc_signal<float> product;\n\n    \/\/ Instance of the Multiplier module\n    Multiplier multiplier_inst;\n\n    \/\/ Constructor that sets up the testbench\n    SC_CTOR(Testbench)\n    : multiplier_inst(\"multiplier_inst\") {\n        \/\/ Connect signals to the multiplier's ports\n        multiplier_inst.a(a);\n        multiplier_inst.b(b);\n        multiplier_inst.product(product);\n\n        \/\/ Create a thread to run the test cases\n        SC_THREAD(run_tests);\n    }\n\n    \/\/ Thread that runs test cases for the Multiplier module\n    void run_tests() {\n        const float epsilon = 1e-6;\n\n        \/\/ Test case 1: Multiply 1.2 and 3.0 (Expected product: 3.6)\n        a.write(1.2);\n        b.write(3.0);\n        wait(1, SC_NS);\n        float result = product.read();\n        std::cout << \"1.2 * 3.0 = \" << result << std::endl;\n        assert(std::fabs(result - 3.6) < epsilon);\n\n        \/\/ Test case 2: Multiply 2.5 and 4.0 (Expected product: 10.0)\n        a.write(2.5);\n        b.write(4.0);\n        wait(1, SC_NS);\n        result = product.read();\n        std::cout << \"2.5 * 4.0 = \" << result << std::endl;\n        assert(std::fabs(result - 10.0) < epsilon);\n\n        std::cout << \"All tests passed successfully.\" << std::endl;\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    \/\/ Instantiate the testbench module\n    Testbench tb(\"tb\");\n\n    \/\/ Start the simulation\n    sc_start();\n\n    return 0;\n}\n",
        "signal":"sc_in<float> a;\nsc_in<float> b;\nsc_out<float> product;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input.\n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<float> a;\nsc_in<float> b;\nsc_out<float> product;\n> **Note**:\n   - Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n   - If the static const are provided, insure to write them in the SystemC code as well.\n\n**C++\/C Code**:\n```\n\/\/ C++ program to multiply two \n\/\/ floating point numbers \n#include <iostream> \nusing namespace std; \n\n\/\/ Creating a user-defined function \n\/\/ called mul_floatnumbers that \n\/\/ multiplies the numbers passed to \n\/\/ it as an input. It gives you the \n\/\/ product of these numbers. \nfloat mul_floatnumbers(float a, float b) { return a * b; } \n\n\/\/ Driver code \nint main() \n{ \n\tfloat A = 1.2, B = 3.0, product; \n\n\t\/\/ Calling mul_floatnumbers function \n\tproduct = mul_floatnumbers(A, B); \n\n\t\/\/ Printing the output \n\tcout << product; \n\n\treturn 0; \n}\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\nFew_shot_example_1:\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        dont_initialize();\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n\nFew_shot_example_2:\n#include <systemc.h>\n\n\/\/ Module: BubbleSort\n\/\/ Sorts a small fixed-size array of integers using the bubble sort algorithm.\nSC_MODULE(BubbleSort) {\n    sc_in<bool>  clk;      \/\/ Clock signal\n    sc_in<bool>  start;    \/\/ Start signal to begin sorting\n    sc_out<bool> done;     \/\/ Signal asserted when sorting is complete\n\n    sc_in<int>   in_arr[4];  \/\/ Input array of 4 integers to be sorted\n    sc_out<int>  out_arr[4]; \/\/ Output array of 4 sorted integers\n\n    int buf[4];  \/\/ Internal buffer to hold array elements during sorting\n\n    \/\/ Constructor: registers the sorting process with the clock\n    SC_CTOR(BubbleSort) {\n        SC_THREAD(sort_proc);\n        sensitive << clk.pos();\n    }\n\n    \/\/ Thread: waits for start, performs bubble sort, writes results, toggles done\n    void sort_proc() {\n        const int N = 4;\n        while (true) {\n            wait();  \/\/ wait for next clock edge\n            if (start.read()) {\n                \/\/ Read inputs into internal buffer\n                for (int i = 0; i < N; ++i)\n                    buf[i] = in_arr[i].read();\n\n                \/\/ Perform bubble sort on buffer[]\n                for (int i = 0; i < N - 1; ++i)\n                    for (int j = 0; j < N - i - 1; ++j)\n                        if (buf[j] > buf[j + 1])\n                            std::swap(buf[j], buf[j + 1]);\n\n                \/\/ Write sorted results to output ports\n                for (int i = 0; i < N; ++i)\n                    out_arr[i].write(buf[i]);\n\n                \/\/ Signal done for one cycle\n                done.write(true);\n                wait();\n                done.write(false);\n            }\n        }\n    }\n};\n\nFew_shot_example_3:\n#include <systemc.h>\n\n\/\/ Module: MatrixAdder\n\/\/ Adds two 4×4 matrices of integers element-wise.\nSC_MODULE(MatrixAdder) {\n    sc_in<int> A[4*4];   \/\/ Flattened 4×4 input matrix A (16 elements)\n    sc_in<int> B[4*4];   \/\/ Flattened 4×4 input matrix B (16 elements)\n    sc_out<int> C[4*4];  \/\/ Flattened 4×4 output matrix C = A + B\n\n    \/\/ Constructor: registers a combinational add method sensitive to all inputs\n    SC_CTOR(MatrixAdder) {\n        SC_METHOD(do_add);\n        \/\/ Make the add method sensitive to every element of A and B\n        for (int i = 0; i < 4*4; i++) {\n            sensitive << A[i] << B[i];\n        }\n    }\n\n    \/\/ Method: reads A[i] and B[i], writes sum into C[i] for all 16 positions\n    void do_add() {\n        for (int i = 0; i < 4*4; i++) {\n            C[i].write(A[i].read() + B[i].read());\n        }\n    }\n};\n\n\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":51,
        "task":"MultiplyTwoMatrices",
        "code":"\/\/ C++ program to multiply two matrices\n\n#include <bits\/stdc++.h>\nusing namespace std;\n\n\/\/ Edit MACROs here, according to your Matrix Dimensions for\n\/\/ mat1[R1][C1] and mat2[R2][C2]\n#define R1 2 \/\/ number of rows in Matrix-1\n#define C1 2 \/\/ number of columns in Matrix-1\n#define R2 2 \/\/ number of rows in Matrix-2\n#define C2 3 \/\/ number of columns in Matrix-2\n\nvoid mulMat(int mat1[][C1], int mat2[][C2])\n{\n\tint rslt[R1][C2];\n\n\tcout << \"Multiplication of given two matrices is:\\n\";\n\n\tfor (int i = 0; i < R1; i++) {\n\t\tfor (int j = 0; j < C2; j++) {\n\t\t\trslt[i][j] = 0;\n\n\t\t\tfor (int k = 0; k < R2; k++) {\n\t\t\t\trslt[i][j] += mat1[i][k] * mat2[k][j];\n\t\t\t}\n\n\t\t\tcout << rslt[i][j] << \"\\t\";\n\t\t}\n\n\t\tcout << endl;\n\t}\n}\n\n\/\/ Driver code\nint main()\n{\n\t\/\/ R1 = 4, C1 = 4 and R2 = 4, C2 = 4 (Update these\n\t\/\/ values in MACROs)\n\tint mat1[R1][C1] = { { 1, 1 }, { 2, 2 } };\n\n\tint mat2[R2][C2] = { { 1, 1, 1 }, { 2, 2, 2 } };\n\n\tif (C1 != R2) {\n\t\tcout << \"The number of columns in Matrix-1 must \"\n\t\t\t\t\"be equal to the number of rows in \"\n\t\t\t\t\"Matrix-2\"\n\t\t\t<< endl;\n\t\tcout << \"Please update MACROs according to your \"\n\t\t\t\t\"array dimension in #define section\"\n\t\t\t<< endl;\n\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t\/\/ Function call\n\tmulMat(mat1, mat2);\n\n\treturn 0;\n}\n",
        "category":"Matrix Operation",
        "adoption":true,
        "reason":null,
        "module_name":"MatrixMultiplier",
        "testbench":"SC_MODULE(Testbench) {\n    \n    \/\/ Signals to connect to the MatrixMultiplier ports\n    sc_signal<int> A[2*2];\n    sc_signal<int> B[2*3];\n    sc_signal<int> C[2*3];\n\n    MatrixMultiplier* mm;\n\n    SC_CTOR(Testbench) {\n        \/\/ Instantiate the MatrixMultiplier module\n        mm = new MatrixMultiplier(\"mm\");\n        \/\/ Connect signals to the module's ports\n        for (int i = 0; i < 2*2; i++) {\n            mm->A[i](A[i]);\n        }\n        for (int i = 0; i < 2*3; i++) {\n            mm->B[i](B[i]);\n        }\n        for (int i = 0; i < 2*3; i++) {\n            mm->C[i](C[i]);\n        }\n        \/\/ Create a thread to run the test cases\n        SC_THREAD(run_tests);\n    }\n\n    \/\/ Thread that initializes inputs, checks outputs, and asserts correctness\n    void run_tests() {\n        \/\/ Initialize Matrix A (2x2):\n        \/\/ { {1, 1},\n        \/\/   {2, 2} }\n        A[0].write(1); \/\/ Row 0, Column 0\n        A[1].write(1); \/\/ Row 0, Column 1\n        A[2].write(2); \/\/ Row 1, Column 0\n        A[3].write(2); \/\/ Row 1, Column 1\n\n        \/\/ Initialize Matrix B (2x3):\n        \/\/ { {1, 1, 1},\n        \/\/   {2, 2, 2} }\n        B[0].write(1); \/\/ Row 0, Column 0\n        B[1].write(1); \/\/ Row 0, Column 1\n        B[2].write(1); \/\/ Row 0, Column 2\n        B[3].write(2); \/\/ Row 1, Column 0\n        B[4].write(2); \/\/ Row 1, Column 1\n        B[5].write(2); \/\/ Row 1, Column 2\n\n        \/\/ Wait for the signals to propagate\n        wait(1, SC_NS);\n\n        \/\/ Expected result after multiplication:\n        \/\/ For result[0][0]: 1*1 + 1*2 = 3\n        \/\/ For result[0][1]: 1*1 + 1*2 = 3\n        \/\/ For result[0][2]: 1*1 + 1*2 = 3\n        \/\/ For result[1][0]: 2*1 + 2*2 = 6\n        \/\/ For result[1][1]: 2*1 + 2*2 = 6\n        \/\/ For result[1][2]: 2*1 + 2*2 = 6\n        int expected[2*3] = {3, 3, 3, 6, 6, 6};\n\n        std::cout << \"Matrix multiplication result:\" << std::endl;\n        for (int i = 0; i < 2*3; i++) {\n            int res = C[i].read();\n            std::cout << res << \" \";\n            \/\/ Assert the computed result matches the expected value\n            assert(res == expected[i]);\n        }\n        std::cout << std::endl;\n        std::cout << \"All tests passed successfully.\" << std::endl;\n\n        sc_stop(); \/\/ Stop the simulation\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); \/\/ Instantiate the testbench\n    sc_start();         \/\/ Start simulation\n    return 0;\n}\n",
        "signal":"sc_in<int> A[2*2];\nsc_in<int> B[2*3];\nsc_out<int> C[2*3];",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input.\n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<int> A[2*2];\nsc_in<int> B[2*3];\nsc_out<int> C[2*3];\n> **Note**:\n   - Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n   - If the static const are provided, insure to write them in the SystemC code as well.\n\n**C++\/C Code**:\n```\n\/\/ C++ program to multiply two matrices\n\n#include <bits\/stdc++.h>\nusing namespace std;\n\n\/\/ Edit MACROs here, according to your Matrix Dimensions for\n\/\/ mat1[R1][C1] and mat2[R2][C2]\n#define R1 2 \/\/ number of rows in Matrix-1\n#define C1 2 \/\/ number of columns in Matrix-1\n#define R2 2 \/\/ number of rows in Matrix-2\n#define C2 3 \/\/ number of columns in Matrix-2\n\nvoid mulMat(int mat1[][C1], int mat2[][C2])\n{\n\tint rslt[R1][C2];\n\n\tcout << \"Multiplication of given two matrices is:\\n\";\n\n\tfor (int i = 0; i < R1; i++) {\n\t\tfor (int j = 0; j < C2; j++) {\n\t\t\trslt[i][j] = 0;\n\n\t\t\tfor (int k = 0; k < R2; k++) {\n\t\t\t\trslt[i][j] += mat1[i][k] * mat2[k][j];\n\t\t\t}\n\n\t\t\tcout << rslt[i][j] << \"\\t\";\n\t\t}\n\n\t\tcout << endl;\n\t}\n}\n\n\/\/ Driver code\nint main()\n{\n\t\/\/ R1 = 4, C1 = 4 and R2 = 4, C2 = 4 (Update these\n\t\/\/ values in MACROs)\n\tint mat1[R1][C1] = { { 1, 1 }, { 2, 2 } };\n\n\tint mat2[R2][C2] = { { 1, 1, 1 }, { 2, 2, 2 } };\n\n\tif (C1 != R2) {\n\t\tcout << \"The number of columns in Matrix-1 must \"\n\t\t\t\t\"be equal to the number of rows in \"\n\t\t\t\t\"Matrix-2\"\n\t\t\t<< endl;\n\t\tcout << \"Please update MACROs according to your \"\n\t\t\t\t\"array dimension in #define section\"\n\t\t\t<< endl;\n\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t\/\/ Function call\n\tmulMat(mat1, mat2);\n\n\treturn 0;\n}\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\nFew_shot_example_1:\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        dont_initialize();\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n\nFew_shot_example_2:\n#include <systemc.h>\n\n\/\/ Module: BubbleSort\n\/\/ Sorts a small fixed-size array of integers using the bubble sort algorithm.\nSC_MODULE(BubbleSort) {\n    sc_in<bool>  clk;      \/\/ Clock signal\n    sc_in<bool>  start;    \/\/ Start signal to begin sorting\n    sc_out<bool> done;     \/\/ Signal asserted when sorting is complete\n\n    sc_in<int>   in_arr[4];  \/\/ Input array of 4 integers to be sorted\n    sc_out<int>  out_arr[4]; \/\/ Output array of 4 sorted integers\n\n    int buf[4];  \/\/ Internal buffer to hold array elements during sorting\n\n    \/\/ Constructor: registers the sorting process with the clock\n    SC_CTOR(BubbleSort) {\n        SC_THREAD(sort_proc);\n        sensitive << clk.pos();\n    }\n\n    \/\/ Thread: waits for start, performs bubble sort, writes results, toggles done\n    void sort_proc() {\n        const int N = 4;\n        while (true) {\n            wait();  \/\/ wait for next clock edge\n            if (start.read()) {\n                \/\/ Read inputs into internal buffer\n                for (int i = 0; i < N; ++i)\n                    buf[i] = in_arr[i].read();\n\n                \/\/ Perform bubble sort on buffer[]\n                for (int i = 0; i < N - 1; ++i)\n                    for (int j = 0; j < N - i - 1; ++j)\n                        if (buf[j] > buf[j + 1])\n                            std::swap(buf[j], buf[j + 1]);\n\n                \/\/ Write sorted results to output ports\n                for (int i = 0; i < N; ++i)\n                    out_arr[i].write(buf[i]);\n\n                \/\/ Signal done for one cycle\n                done.write(true);\n                wait();\n                done.write(false);\n            }\n        }\n    }\n};\n\nFew_shot_example_3:\n#include <systemc.h>\n\n\/\/ Module: MatrixAdder\n\/\/ Adds two 4×4 matrices of integers element-wise.\nSC_MODULE(MatrixAdder) {\n    sc_in<int> A[4*4];   \/\/ Flattened 4×4 input matrix A (16 elements)\n    sc_in<int> B[4*4];   \/\/ Flattened 4×4 input matrix B (16 elements)\n    sc_out<int> C[4*4];  \/\/ Flattened 4×4 output matrix C = A + B\n\n    \/\/ Constructor: registers a combinational add method sensitive to all inputs\n    SC_CTOR(MatrixAdder) {\n        SC_METHOD(do_add);\n        \/\/ Make the add method sensitive to every element of A and B\n        for (int i = 0; i < 4*4; i++) {\n            sensitive << A[i] << B[i];\n        }\n    }\n\n    \/\/ Method: reads A[i] and B[i], writes sum into C[i] for all 16 positions\n    void do_add() {\n        for (int i = 0; i < 4*4; i++) {\n            C[i].write(A[i].read() + B[i].read());\n        }\n    }\n};\n\n\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":52,
        "task":"NumberofUniqueTripletsWhoseXORisZero",
        "code":"\/\/ CPP program to count the number of\n\/\/ unique triplets whose XOR is 0\n#include <bits\/stdc++.h>\nusing namespace std;\n\n\/\/ function to count the number of \n\/\/ unique triplets whose xor is 0\nint countTriplets(int a[], int n) \n{\n\t\/\/ To store values that are present\n\tunordered_set<int> s;\n\tfor (int i = 0; i < n; i++)\n\t\ts.insert(a[i]);\n\t\n\t\/\/ stores the count of unique triplets\n\tint count = 0;\n\t\n\t\/\/ traverse for all i, j pairs such that j>i\n\tfor (int i = 0; i < n-1; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\n\t\t\/\/ xor of a[i] and a[j]\n\t\tint xr = a[i] ^ a[j];\n\t\n\t\t\/\/ if xr of two numbers is present, \n\t\t\/\/ then increase the count\n\t\tif (s.find(xr) != s.end() && xr != a[i] && \n\t\t\t\t\t\t\t\t\txr != a[j])\n\t\t\tcount++;\n\t\t}\n\t}\n\t\n\t\/\/ returns answer\n\treturn count \/ 3;\n}\n\n\/\/ Driver code to test above function\nint main() \n{\n\tint a[] = {1, 3, 5, 10, 14, 15};\n\tint n = sizeof(a) \/ sizeof(a[0]); \n\tcout << countTriplets(a, n); \n\treturn 0;\n}\n",
        "category":"Array Operation",
        "adoption":true,
        "reason":null,
        "module_name":"TripletCounter",
        "testbench":"SC_MODULE(Testbench) {\n    sc_clock clk{\"clk\", 1, SC_NS};\n    sc_signal<bool> start, done;\n    sc_signal<int> sig_in[6];\n    sc_signal<int> sig_out;\n\n    TripletCounter* dut;\n\n    SC_CTOR(Testbench) {\n        dut = new TripletCounter(\"TripletCounter\");\n        dut->clk(clk);\n        dut->start(start);\n        dut->done(done);\n        dut->triplet_count(sig_out);\n        for (int i = 0; i < 6; ++i)\n            dut->in_arr[i](sig_in[i]);\n\n        SC_THREAD(run_test);\n    }\n\n    void run_test() {\n        int data[6] = {1, 3, 5, 10, 14, 15};\n\n        for (int i = 0; i < 6; ++i)\n            sig_in[i].write(data[i]);\n\n        wait(clk.posedge_event());\n        start.write(true);\n        wait(clk.posedge_event());\n        start.write(false);\n\n        wait(done.posedge_event());\n\n        int result = sig_out.read();\n        std::cout << \"Triplet XOR==0 count: \" << result << std::endl;\n        assert(result == 2); \/\/ Based on original C++ output\n\n        std::cout << \"All tests passed successfully.\\n\";\n        sc_stop();\n    }\n};\n\nint sc_main(int, char*[]) {\n    Testbench tb{\"tb\"};\n    sc_start();\n    return 0;\n}",
        "signal":"sc_in<bool>  clk;\nsc_in<bool>  start;\nsc_out<bool> done;\nsc_in<int>  in_arr[6];\nsc_out<int> triplet_count;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input.\n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<bool>  clk;\nsc_in<bool>  start;\nsc_out<bool> done;\nsc_in<int>  in_arr[6];\nsc_out<int> triplet_count;\n> **Note**:\n   - Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n   - If the static const are provided, insure to write them in the SystemC code as well.\n\n**C++\/C Code**:\n```\n\/\/ CPP program to count the number of\n\/\/ unique triplets whose XOR is 0\n#include <bits\/stdc++.h>\nusing namespace std;\n\n\/\/ function to count the number of \n\/\/ unique triplets whose xor is 0\nint countTriplets(int a[], int n) \n{\n\t\/\/ To store values that are present\n\tunordered_set<int> s;\n\tfor (int i = 0; i < n; i++)\n\t\ts.insert(a[i]);\n\t\n\t\/\/ stores the count of unique triplets\n\tint count = 0;\n\t\n\t\/\/ traverse for all i, j pairs such that j>i\n\tfor (int i = 0; i < n-1; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\n\t\t\/\/ xor of a[i] and a[j]\n\t\tint xr = a[i] ^ a[j];\n\t\n\t\t\/\/ if xr of two numbers is present, \n\t\t\/\/ then increase the count\n\t\tif (s.find(xr) != s.end() && xr != a[i] && \n\t\t\t\t\t\t\t\t\txr != a[j])\n\t\t\tcount++;\n\t\t}\n\t}\n\t\n\t\/\/ returns answer\n\treturn count \/ 3;\n}\n\n\/\/ Driver code to test above function\nint main() \n{\n\tint a[] = {1, 3, 5, 10, 14, 15};\n\tint n = sizeof(a) \/ sizeof(a[0]); \n\tcout << countTriplets(a, n); \n\treturn 0;\n}\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\nFew_shot_example_1:\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        dont_initialize();\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n\nFew_shot_example_2:\n#include <systemc.h>\n\n\/\/ Module: BubbleSort\n\/\/ Sorts a small fixed-size array of integers using the bubble sort algorithm.\nSC_MODULE(BubbleSort) {\n    sc_in<bool>  clk;      \/\/ Clock signal\n    sc_in<bool>  start;    \/\/ Start signal to begin sorting\n    sc_out<bool> done;     \/\/ Signal asserted when sorting is complete\n\n    sc_in<int>   in_arr[4];  \/\/ Input array of 4 integers to be sorted\n    sc_out<int>  out_arr[4]; \/\/ Output array of 4 sorted integers\n\n    int buf[4];  \/\/ Internal buffer to hold array elements during sorting\n\n    \/\/ Constructor: registers the sorting process with the clock\n    SC_CTOR(BubbleSort) {\n        SC_THREAD(sort_proc);\n        sensitive << clk.pos();\n    }\n\n    \/\/ Thread: waits for start, performs bubble sort, writes results, toggles done\n    void sort_proc() {\n        const int N = 4;\n        while (true) {\n            wait();  \/\/ wait for next clock edge\n            if (start.read()) {\n                \/\/ Read inputs into internal buffer\n                for (int i = 0; i < N; ++i)\n                    buf[i] = in_arr[i].read();\n\n                \/\/ Perform bubble sort on buffer[]\n                for (int i = 0; i < N - 1; ++i)\n                    for (int j = 0; j < N - i - 1; ++j)\n                        if (buf[j] > buf[j + 1])\n                            std::swap(buf[j], buf[j + 1]);\n\n                \/\/ Write sorted results to output ports\n                for (int i = 0; i < N; ++i)\n                    out_arr[i].write(buf[i]);\n\n                \/\/ Signal done for one cycle\n                done.write(true);\n                wait();\n                done.write(false);\n            }\n        }\n    }\n};\n\nFew_shot_example_3:\n#include <systemc.h>\n\n\/\/ Module: MatrixAdder\n\/\/ Adds two 4×4 matrices of integers element-wise.\nSC_MODULE(MatrixAdder) {\n    sc_in<int> A[4*4];   \/\/ Flattened 4×4 input matrix A (16 elements)\n    sc_in<int> B[4*4];   \/\/ Flattened 4×4 input matrix B (16 elements)\n    sc_out<int> C[4*4];  \/\/ Flattened 4×4 output matrix C = A + B\n\n    \/\/ Constructor: registers a combinational add method sensitive to all inputs\n    SC_CTOR(MatrixAdder) {\n        SC_METHOD(do_add);\n        \/\/ Make the add method sensitive to every element of A and B\n        for (int i = 0; i < 4*4; i++) {\n            sensitive << A[i] << B[i];\n        }\n    }\n\n    \/\/ Method: reads A[i] and B[i], writes sum into C[i] for all 16 positions\n    void do_add() {\n        for (int i = 0; i < 4*4; i++) {\n            C[i].write(A[i].read() + B[i].read());\n        }\n    }\n};\n\n\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":53,
        "task":"OctaltoDecimalConversion",
        "code":"\/\/ C++ program to convert octal \n\/\/ to decimal\n#include <iostream>\nusing namespace std;\n\n\/\/ Function to convert octal \n\/\/ to decimal\nint octalToDecimal(int n)\n{\n\tint num = n;\n\tint dec_value = 0;\n\n\t\/\/ Initializing base value to 1, \n\t\/\/ i.e 8^0\n\tint base = 1;\n\n\tint temp = num;\n\twhile (temp) \n\t{\n\t\t\/\/ Extracting last digit\n\t\tint last_digit = temp % 10;\n\t\ttemp = temp \/ 10;\n\n\t\t\/\/ Multiplying last digit with \n\t\t\/\/ appropriate base value and adding \n\t\t\/\/ it to dec_value\n\t\tdec_value += last_digit * base;\n\n\t\tbase = base * 8;\n\t}\n\n\treturn dec_value;\n}\n\n\/\/ Driver code\nint main()\n{\n\tint num = 67;\n\n\tcout << octalToDecimal(num) << endl;\n}\n",
        "category":"Basic Math",
        "adoption":true,
        "reason":null,
        "module_name":"OctalToDecimalConverter",
        "testbench":"SC_MODULE(Testbench) {\n    sc_signal<int> octal_input_sig; \/\/ Signal for the octal input\n    sc_signal<int> decimal_output_sig; \/\/ Signal for the decimal output\n\n    OctalToDecimalConverter converter_inst; \/\/ Instance of the converter module\n\n    \/\/ Constructor\n    SC_CTOR(Testbench) : converter_inst(\"converter\") {\n        \/\/ Connect signals to ports\n        converter_inst.octal_input(octal_input_sig);\n        converter_inst.decimal_output(decimal_output_sig);\n\n        \/\/ Process to run tests\n        SC_THREAD(run_tests);\n    }\n\n    \/\/ Thread to run test cases\n    void run_tests() {\n        \/\/ Test case 1: Convert 67 (octal) to decimal\n        octal_input_sig = 67;\n        wait(1, SC_NS); \/\/ Wait for the converter to process\n        int result = decimal_output_sig.read();\n        cout << \"Octal: 67 -> Decimal: \" << result << endl;\n        assert(result == 55); \/\/ 67 in octal is 55 in decimal\n\n        \/\/ Additional test case: Convert 123 (octal) to decimal\n        octal_input_sig = 123;\n        wait(1, SC_NS);\n        result = decimal_output_sig.read();\n        cout << \"Octal: 123 -> Decimal: \" << result << endl;\n        assert(result == 83); \/\/ 123 in octal is 83 in decimal\n\n        \/\/ Print success message\n        cout << \"All tests passed successfully.\" << endl;\n\n        sc_stop(); \/\/ Stop the simulation\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); \/\/ Create an instance of the Testbench\n\n    \/\/ Start the simulation\n    sc_start();\n\n    return 0;\n}\n",
        "signal":"sc_in<int> octal_input;\nsc_out<int> decimal_output;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input.\n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<int> octal_input;\nsc_out<int> decimal_output;\n> **Note**:\n   - Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n   - If the static const are provided, insure to write them in the SystemC code as well.\n\n**C++\/C Code**:\n```\n\/\/ C++ program to convert octal \n\/\/ to decimal\n#include <iostream>\nusing namespace std;\n\n\/\/ Function to convert octal \n\/\/ to decimal\nint octalToDecimal(int n)\n{\n\tint num = n;\n\tint dec_value = 0;\n\n\t\/\/ Initializing base value to 1, \n\t\/\/ i.e 8^0\n\tint base = 1;\n\n\tint temp = num;\n\twhile (temp) \n\t{\n\t\t\/\/ Extracting last digit\n\t\tint last_digit = temp % 10;\n\t\ttemp = temp \/ 10;\n\n\t\t\/\/ Multiplying last digit with \n\t\t\/\/ appropriate base value and adding \n\t\t\/\/ it to dec_value\n\t\tdec_value += last_digit * base;\n\n\t\tbase = base * 8;\n\t}\n\n\treturn dec_value;\n}\n\n\/\/ Driver code\nint main()\n{\n\tint num = 67;\n\n\tcout << octalToDecimal(num) << endl;\n}\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\nFew_shot_example_1:\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        dont_initialize();\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n\nFew_shot_example_2:\n#include <systemc.h>\n\n\/\/ Module: BubbleSort\n\/\/ Sorts a small fixed-size array of integers using the bubble sort algorithm.\nSC_MODULE(BubbleSort) {\n    sc_in<bool>  clk;      \/\/ Clock signal\n    sc_in<bool>  start;    \/\/ Start signal to begin sorting\n    sc_out<bool> done;     \/\/ Signal asserted when sorting is complete\n\n    sc_in<int>   in_arr[4];  \/\/ Input array of 4 integers to be sorted\n    sc_out<int>  out_arr[4]; \/\/ Output array of 4 sorted integers\n\n    int buf[4];  \/\/ Internal buffer to hold array elements during sorting\n\n    \/\/ Constructor: registers the sorting process with the clock\n    SC_CTOR(BubbleSort) {\n        SC_THREAD(sort_proc);\n        sensitive << clk.pos();\n    }\n\n    \/\/ Thread: waits for start, performs bubble sort, writes results, toggles done\n    void sort_proc() {\n        const int N = 4;\n        while (true) {\n            wait();  \/\/ wait for next clock edge\n            if (start.read()) {\n                \/\/ Read inputs into internal buffer\n                for (int i = 0; i < N; ++i)\n                    buf[i] = in_arr[i].read();\n\n                \/\/ Perform bubble sort on buffer[]\n                for (int i = 0; i < N - 1; ++i)\n                    for (int j = 0; j < N - i - 1; ++j)\n                        if (buf[j] > buf[j + 1])\n                            std::swap(buf[j], buf[j + 1]);\n\n                \/\/ Write sorted results to output ports\n                for (int i = 0; i < N; ++i)\n                    out_arr[i].write(buf[i]);\n\n                \/\/ Signal done for one cycle\n                done.write(true);\n                wait();\n                done.write(false);\n            }\n        }\n    }\n};\n\nFew_shot_example_3:\n#include <systemc.h>\n\n\/\/ Module: MatrixAdder\n\/\/ Adds two 4×4 matrices of integers element-wise.\nSC_MODULE(MatrixAdder) {\n    sc_in<int> A[4*4];   \/\/ Flattened 4×4 input matrix A (16 elements)\n    sc_in<int> B[4*4];   \/\/ Flattened 4×4 input matrix B (16 elements)\n    sc_out<int> C[4*4];  \/\/ Flattened 4×4 output matrix C = A + B\n\n    \/\/ Constructor: registers a combinational add method sensitive to all inputs\n    SC_CTOR(MatrixAdder) {\n        SC_METHOD(do_add);\n        \/\/ Make the add method sensitive to every element of A and B\n        for (int i = 0; i < 4*4; i++) {\n            sensitive << A[i] << B[i];\n        }\n    }\n\n    \/\/ Method: reads A[i] and B[i], writes sum into C[i] for all 16 positions\n    void do_add() {\n        for (int i = 0; i < 4*4; i++) {\n            C[i].write(A[i].read() + B[i].read());\n        }\n    }\n};\n\n\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":54,
        "task":"PrintMultiplicationTableofaNumber",
        "code":"\/\/ C++ program to print table\n\/\/ of a number\n#include <iostream>\nusing namespace std;\n\n\/\/ Driver code\nint main()\n{\n\t\/\/ Change here to change output\n\tint n = 5;\n\tfor (int i = 1; i <= 10; ++i)\n\t\tcout << n << \" * \" << i << \" = \" << n * i << endl;\n\treturn 0;\n}\n",
        "category":"Basic Math",
        "adoption":false,
        "reason":null,
        "module_name":null,
        "testbench":null,
        "signal":null,
        "prompt":null
    },
    {
        "task_id":55,
        "task":"PrintPascalsTriangle",
        "code":"\/\/  C++ code for Pascal's Triangle\n#include <iostream>\nusing namespace std;\n\n\/\/ See https:\/\/www.geeksforgeeks.org\/space-and-time-efficient-binomial-coefficient\/ \n\/\/ for details of this function\nint binomialCoeff(int n, int k);\n\n\/\/ Function to print first\n\/\/ n lines of Pascal's \n\/\/ Triangle\nvoid printPascal(int n)\n{\n    \/\/ Iterate through every line and\n    \/\/ print entries in it\n    for (int line = 0; line < n; line++)\n    {\n        \/\/ Every line has number of \n        \/\/ integers equal to line \n        \/\/ number\n        for (int i = 0; i <= line; i++)\n            cout <<\" \"<< binomialCoeff(line, i);\n        cout <<\"\\n\";\n    }\n}\n\n\/\/ See https:\/\/www.geeksforgeeks.org\/space-and-time-efficient-binomial-coefficient\/\n\/\/ for details of this function\nint binomialCoeff(int n, int k)\n{\n    int res = 1;\n    if (k > n - k)\n    k = n - k;\n    for (int i = 0; i < k; ++i)\n    {\n        res *= (n - i);\n        res \/= (i + 1);\n    }\n    \n    return res;\n}\n\n\/\/ Driver program \nint main()\n{\n    int n = 7;\n    printPascal(n);\n    return 0;\n}\n",
        "category":"Others",
        "adoption":false,
        "reason":null,
        "module_name":null,
        "testbench":null,
        "signal":null,
        "prompt":null
    },
    {
        "task_id":56,
        "task":"RemoveAllOccurrencesofanElementinanArray",
        "code":"\/\/ C++ program to remove all the \n\/\/ occurrences \n#include <iostream>\nusing namespace std;\n\nvoid remove_all_occurrence(int arr[],\n\t\t\t\t\t\tint target,\n\t\t\t\t\t\tint n)\n{\nint cnt = 0;\n\n\/\/ Counting all occurrence of \n\/\/ target element\nfor(int i = 0; i < n; i++)\n{\n\tif(arr[i] == target) \n\tcnt++;\n}\n\t\n\/\/ Creating new array of \n\/\/ size = original size - \n\/\/ no. of target element\nint new_arr[n - cnt];\nint ind = 0;\nfor(int i = 0; i < n; i++)\n{\n\tif(arr[i] != target)\n\t{\n\tnew_arr[ind] = arr[i];\n\tind++;\n\t}\n}\n\t\n\/\/ Printing the new array \nint m = (sizeof(new_arr) \/ \n\t\tsizeof(new_arr[0]));\nfor(int i = 0; i < m; i++)\n{\n\tcout << new_arr[i] << \" \"; \n}\nreturn;\n}\n\n\/\/ Driver code\nint main() \n{\nint arr[]={1, 4, 3, 6, 8,\n\t\t\t3, 9, 10, 3, 3, 7};\nint target = 3;\nint n = (sizeof(arr) \/ \n\t\tsizeof(arr[0]));\nremove_all_occurrence(arr, target, n);\nreturn 0;\n}\n",
        "category":"Array Operation",
        "adoption":true,
        "reason":null,
        "module_name":"RemoveAllOccurrences",
        "testbench":"SC_MODULE(Testbench) {\n    sc_clock clk{\"clk\", 1, SC_NS};\n    sc_signal<bool> start, done;\n    sc_signal<int> in_arr[11], out_arr[11];\n    sc_signal<int> target;\n\n    RemoveAllOccurrences* dut;\n\n    SC_CTOR(Testbench) {\n        dut = new RemoveAllOccurrences(\"RemoveAllOccurrences\");\n        dut->clk(clk);\n        dut->start(start);\n        dut->done(done);\n        dut->target(target);\n        for (int i = 0; i < 11; ++i) {\n            dut->in_arr[i](in_arr[i]);\n            dut->out_arr[i](out_arr[i]);\n        }\n\n        SC_THREAD(run_tests);\n    }\n\n    void run_tests() {\n        int data[11] = {1, 4, 3, 6, 8, 3, 9, 10, 3, 3, 7};\n        int t = 3;\n        int expected[11] = {1, 4, 6, 8, 9, 10, 7, -1, -1, -1, -1};\n\n        for (int i = 0; i < 11; ++i)\n            in_arr[i].write(data[i]);\n        target.write(t);\n\n        wait(clk.posedge_event());\n        start.write(true);\n        wait(clk.posedge_event());\n        start.write(false);\n\n        wait(done.posedge_event());\n\n        for (int i = 0; i < 7; ++i) {\n            int val = out_arr[i].read();\n            cout << \"out_arr[\" << i << \"]: \" << val << endl;\n            assert(val == expected[i]);\n        }\n\n        cout << \"All tests passed successfully.\\n\";\n        sc_stop();\n    }\n};\n\nint sc_main(int, char*[]) {\n    Testbench tb{\"tb\"};\n    sc_start();\n    return 0;\n}\n",
        "signal":"sc_in<bool> clk;\nsc_in<bool> start;\nsc_out<bool> done;\nsc_in<int>  in_arr[11];\nsc_out<int> out_arr[11];\nsc_in<int>  target;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input.\n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<bool> clk;\nsc_in<bool> start;\nsc_out<bool> done;\nsc_in<int>  in_arr[11];\nsc_out<int> out_arr[11];\nsc_in<int>  target;\n> **Note**:\n   - Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n   - If the static const are provided, insure to write them in the SystemC code as well.\n\n**C++\/C Code**:\n```\n\/\/ C++ program to remove all the \n\/\/ occurrences \n#include <iostream>\nusing namespace std;\n\nvoid remove_all_occurrence(int arr[],\n\t\t\t\t\t\tint target,\n\t\t\t\t\t\tint n)\n{\nint cnt = 0;\n\n\/\/ Counting all occurrence of \n\/\/ target element\nfor(int i = 0; i < n; i++)\n{\n\tif(arr[i] == target) \n\tcnt++;\n}\n\t\n\/\/ Creating new array of \n\/\/ size = original size - \n\/\/ no. of target element\nint new_arr[n - cnt];\nint ind = 0;\nfor(int i = 0; i < n; i++)\n{\n\tif(arr[i] != target)\n\t{\n\tnew_arr[ind] = arr[i];\n\tind++;\n\t}\n}\n\t\n\/\/ Printing the new array \nint m = (sizeof(new_arr) \/ \n\t\tsizeof(new_arr[0]));\nfor(int i = 0; i < m; i++)\n{\n\tcout << new_arr[i] << \" \"; \n}\nreturn;\n}\n\n\/\/ Driver code\nint main() \n{\nint arr[]={1, 4, 3, 6, 8,\n\t\t\t3, 9, 10, 3, 3, 7};\nint target = 3;\nint n = (sizeof(arr) \/ \n\t\tsizeof(arr[0]));\nremove_all_occurrence(arr, target, n);\nreturn 0;\n}\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\nFew_shot_example_1:\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        dont_initialize();\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n\nFew_shot_example_2:\n#include <systemc.h>\n\n\/\/ Module: BubbleSort\n\/\/ Sorts a small fixed-size array of integers using the bubble sort algorithm.\nSC_MODULE(BubbleSort) {\n    sc_in<bool>  clk;      \/\/ Clock signal\n    sc_in<bool>  start;    \/\/ Start signal to begin sorting\n    sc_out<bool> done;     \/\/ Signal asserted when sorting is complete\n\n    sc_in<int>   in_arr[4];  \/\/ Input array of 4 integers to be sorted\n    sc_out<int>  out_arr[4]; \/\/ Output array of 4 sorted integers\n\n    int buf[4];  \/\/ Internal buffer to hold array elements during sorting\n\n    \/\/ Constructor: registers the sorting process with the clock\n    SC_CTOR(BubbleSort) {\n        SC_THREAD(sort_proc);\n        sensitive << clk.pos();\n    }\n\n    \/\/ Thread: waits for start, performs bubble sort, writes results, toggles done\n    void sort_proc() {\n        const int N = 4;\n        while (true) {\n            wait();  \/\/ wait for next clock edge\n            if (start.read()) {\n                \/\/ Read inputs into internal buffer\n                for (int i = 0; i < N; ++i)\n                    buf[i] = in_arr[i].read();\n\n                \/\/ Perform bubble sort on buffer[]\n                for (int i = 0; i < N - 1; ++i)\n                    for (int j = 0; j < N - i - 1; ++j)\n                        if (buf[j] > buf[j + 1])\n                            std::swap(buf[j], buf[j + 1]);\n\n                \/\/ Write sorted results to output ports\n                for (int i = 0; i < N; ++i)\n                    out_arr[i].write(buf[i]);\n\n                \/\/ Signal done for one cycle\n                done.write(true);\n                wait();\n                done.write(false);\n            }\n        }\n    }\n};\n\nFew_shot_example_3:\n#include <systemc.h>\n\n\/\/ Module: MatrixAdder\n\/\/ Adds two 4×4 matrices of integers element-wise.\nSC_MODULE(MatrixAdder) {\n    sc_in<int> A[4*4];   \/\/ Flattened 4×4 input matrix A (16 elements)\n    sc_in<int> B[4*4];   \/\/ Flattened 4×4 input matrix B (16 elements)\n    sc_out<int> C[4*4];  \/\/ Flattened 4×4 output matrix C = A + B\n\n    \/\/ Constructor: registers a combinational add method sensitive to all inputs\n    SC_CTOR(MatrixAdder) {\n        SC_METHOD(do_add);\n        \/\/ Make the add method sensitive to every element of A and B\n        for (int i = 0; i < 4*4; i++) {\n            sensitive << A[i] << B[i];\n        }\n    }\n\n    \/\/ Method: reads A[i] and B[i], writes sum into C[i] for all 16 positions\n    void do_add() {\n        for (int i = 0; i < 4*4; i++) {\n            C[i].write(A[i].read() + B[i].read());\n        }\n    }\n};\n\n\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":57,
        "task":"RemoveDuplicateElementsFromanArray",
        "code":"\/\/ Simple C++ program to remove duplicates \n#include <iostream> \nusing namespace std; \n\n\/\/ Function to remove duplicate \n\/\/ elements This function returns \n\/\/ new size of modified array. \nint removeDuplicates(int arr[], int n) \n{ \n\t\/\/ Return, if array is empty or \n\t\/\/ contains a single element \n\tif (n == 0 || n == 1) \n\t\treturn n; \n\n\tint temp[n]; \n\n\t\/\/ Start traversing elements \n\tint j = 0; \n\n\t\/\/ If current element is not equal \n\t\/\/ to next element then store that \n\t\/\/ current element \n\tfor (int i = 0; i < n - 1; i++) \n\t\tif (arr[i] != arr[i + 1]) \n\t\t\ttemp[j++] = arr[i]; \n\n\t\/\/ Store the last element as whether \n\t\/\/ it is unique or repeated, it hasn't \n\t\/\/ stored previously \n\ttemp[j++] = arr[n - 1]; \n\n\t\/\/ Modify original array \n\tfor (int i = 0; i < j; i++) \n\t\tarr[i] = temp[i]; \n\n\treturn j; \n} \n\n\/\/ Driver code \nint main() \n{ \n\tint arr[] = {1, 2, 2, 3, 4, \n\t\t\t\t4, 4, 5, 5}; \n\tint n = sizeof(arr) \/ sizeof(arr[0]); \n\n\t\/\/ RemoveDuplicates() returns \n\t\/\/ new size of array. \n\tn = removeDuplicates(arr, n); \n\n\t\/\/ Print updated array \n\tfor (int i = 0; i < n; i++) \n\t\tcout << arr[i] << \" \"; \n\n\treturn 0; \n} \n\n\/\/ This code is contributed by Aditya Kumar (adityakumar129)\n",
        "category":"Array Operation",
        "adoption":true,
        "reason":null,
        "module_name":"RemoveDuplicates",
        "testbench":"SC_MODULE(Testbench) {\n    sc_clock clk{\"clk\", 1, SC_NS};\n    sc_signal<bool> start, done;\n    sc_signal<int> sig_in[9], sig_out[9];\n    sc_signal<int> sig_out_size;\n\n    RemoveDuplicates* dut;\n\n    SC_CTOR(Testbench) {\n        dut = new RemoveDuplicates(\"RemoveDuplicates\");\n        dut->clk(clk);\n        dut->start(start);\n        dut->done(done);\n        for (int i = 0; i < 9; ++i) {\n            dut->in_arr[i](sig_in[i]);\n            dut->out_arr[i](sig_out[i]);\n        }\n        dut->out_size(sig_out_size);\n\n        SC_THREAD(run_tests);\n    }\n\n    void run_tests() {\n        int data[9] = {1, 2, 2, 3, 4, 4, 4, 5, 5};\n        int expected[5] = {1, 2, 3, 4, 5};\n\n        for (int i = 0; i < 9; ++i)\n            sig_in[i].write(data[i]);\n\n        wait(clk.posedge_event());\n        start.write(true);\n        wait(clk.posedge_event());\n        start.write(false);\n\n        wait(done.posedge_event());\n\n        int new_size = sig_out_size.read();\n        cout << \"New size: \" << new_size << endl;\n\n        for (int i = 0; i < new_size; ++i) {\n            int v = sig_out[i].read();\n            cout << \"Element \" << i << \": \" << v << endl;\n            assert(v == expected[i]);\n        }\n\n        cout << \"All tests passed successfully.\" << endl;\n        sc_stop();\n    }\n};\n\n\/\/ ──────────────── sc_main ────────────────\nint sc_main(int, char*[]) {\n    Testbench tb{\"tb\"};\n    sc_start();\n    return 0;\n}\n",
        "signal":"sc_in<bool> clk;\nsc_in<bool> start;\nsc_out<bool> done;\nsc_in<int>   in_arr[9];\nsc_out<int>  out_arr[9];\nsc_out<int>  out_size;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input.\n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<bool> clk;\nsc_in<bool> start;\nsc_out<bool> done;\nsc_in<int>   in_arr[9];\nsc_out<int>  out_arr[9];\nsc_out<int>  out_size;\n> **Note**:\n   - Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n   - If the static const are provided, insure to write them in the SystemC code as well.\n\n**C++\/C Code**:\n```\n\/\/ Simple C++ program to remove duplicates \n#include <iostream> \nusing namespace std; \n\n\/\/ Function to remove duplicate \n\/\/ elements This function returns \n\/\/ new size of modified array. \nint removeDuplicates(int arr[], int n) \n{ \n\t\/\/ Return, if array is empty or \n\t\/\/ contains a single element \n\tif (n == 0 || n == 1) \n\t\treturn n; \n\n\tint temp[n]; \n\n\t\/\/ Start traversing elements \n\tint j = 0; \n\n\t\/\/ If current element is not equal \n\t\/\/ to next element then store that \n\t\/\/ current element \n\tfor (int i = 0; i < n - 1; i++) \n\t\tif (arr[i] != arr[i + 1]) \n\t\t\ttemp[j++] = arr[i]; \n\n\t\/\/ Store the last element as whether \n\t\/\/ it is unique or repeated, it hasn't \n\t\/\/ stored previously \n\ttemp[j++] = arr[n - 1]; \n\n\t\/\/ Modify original array \n\tfor (int i = 0; i < j; i++) \n\t\tarr[i] = temp[i]; \n\n\treturn j; \n} \n\n\/\/ Driver code \nint main() \n{ \n\tint arr[] = {1, 2, 2, 3, 4, \n\t\t\t\t4, 4, 5, 5}; \n\tint n = sizeof(arr) \/ sizeof(arr[0]); \n\n\t\/\/ RemoveDuplicates() returns \n\t\/\/ new size of array. \n\tn = removeDuplicates(arr, n); \n\n\t\/\/ Print updated array \n\tfor (int i = 0; i < n; i++) \n\t\tcout << arr[i] << \" \"; \n\n\treturn 0; \n} \n\n\/\/ This code is contributed by Aditya Kumar (adityakumar129)\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\nFew_shot_example_1:\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        dont_initialize();\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n\nFew_shot_example_2:\n#include <systemc.h>\n\n\/\/ Module: BubbleSort\n\/\/ Sorts a small fixed-size array of integers using the bubble sort algorithm.\nSC_MODULE(BubbleSort) {\n    sc_in<bool>  clk;      \/\/ Clock signal\n    sc_in<bool>  start;    \/\/ Start signal to begin sorting\n    sc_out<bool> done;     \/\/ Signal asserted when sorting is complete\n\n    sc_in<int>   in_arr[4];  \/\/ Input array of 4 integers to be sorted\n    sc_out<int>  out_arr[4]; \/\/ Output array of 4 sorted integers\n\n    int buf[4];  \/\/ Internal buffer to hold array elements during sorting\n\n    \/\/ Constructor: registers the sorting process with the clock\n    SC_CTOR(BubbleSort) {\n        SC_THREAD(sort_proc);\n        sensitive << clk.pos();\n    }\n\n    \/\/ Thread: waits for start, performs bubble sort, writes results, toggles done\n    void sort_proc() {\n        const int N = 4;\n        while (true) {\n            wait();  \/\/ wait for next clock edge\n            if (start.read()) {\n                \/\/ Read inputs into internal buffer\n                for (int i = 0; i < N; ++i)\n                    buf[i] = in_arr[i].read();\n\n                \/\/ Perform bubble sort on buffer[]\n                for (int i = 0; i < N - 1; ++i)\n                    for (int j = 0; j < N - i - 1; ++j)\n                        if (buf[j] > buf[j + 1])\n                            std::swap(buf[j], buf[j + 1]);\n\n                \/\/ Write sorted results to output ports\n                for (int i = 0; i < N; ++i)\n                    out_arr[i].write(buf[i]);\n\n                \/\/ Signal done for one cycle\n                done.write(true);\n                wait();\n                done.write(false);\n            }\n        }\n    }\n};\n\nFew_shot_example_3:\n#include <systemc.h>\n\n\/\/ Module: MatrixAdder\n\/\/ Adds two 4×4 matrices of integers element-wise.\nSC_MODULE(MatrixAdder) {\n    sc_in<int> A[4*4];   \/\/ Flattened 4×4 input matrix A (16 elements)\n    sc_in<int> B[4*4];   \/\/ Flattened 4×4 input matrix B (16 elements)\n    sc_out<int> C[4*4];  \/\/ Flattened 4×4 output matrix C = A + B\n\n    \/\/ Constructor: registers a combinational add method sensitive to all inputs\n    SC_CTOR(MatrixAdder) {\n        SC_METHOD(do_add);\n        \/\/ Make the add method sensitive to every element of A and B\n        for (int i = 0; i < 4*4; i++) {\n            sensitive << A[i] << B[i];\n        }\n    }\n\n    \/\/ Method: reads A[i] and B[i], writes sum into C[i] for all 16 positions\n    void do_add() {\n        for (int i = 0; i < 4*4; i++) {\n            C[i].write(A[i].read() + B[i].read());\n        }\n    }\n};\n\n\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":58,
        "task":"RemoveLeadingZeros",
        "code":"\/\/ C++ program to remove leading zeros \n\/\/ from a given string \n#include <iostream> \n\nusing namespace std; \n\nstring removeZero(string str) \n{ \n\t\/\/ Count leading zeros \n\tint i = 0; \n\twhile (str[i] == '0') \n\t\ti++; \n\n\t\/\/ The erase function removes i characters \n\t\/\/ from given index (0 here) \n\tstr.erase(0, i); \n\n\treturn str; \n} \n\n\/\/ Driver code \nint main() \n{ \n\tstring str; \n\tstr = \"00000123569\"; \n\tstr = removeZero(str); \n\tcout << str << endl; \n\treturn 0; \n}\n",
        "category":"Array Operation",
        "adoption":false,
        "reason":null,
        "module_name":null,
        "testbench":null,
        "signal":null,
        "prompt":null
    },
    {
        "task_id":59,
        "task":"ReverseaNumber",
        "code":"\/\/ C++ program to implement \n\/\/ the above approach \n#include <bits\/stdc++.h> \nusing namespace std; \n\n\/\/ Iterative function to \n\/\/ reverse digits of num \nint reverseDigits(int num) \n{ \n\tint rev_num = 0; \n\twhile (num > 0) { \n\t\trev_num = rev_num * 10 + num % 10; \n\t\tnum = num \/ 10; \n\t} \n\treturn rev_num; \n} \n\n\/\/ Driver code \nint main() \n{ \n\tint num = 4562; \n\tcout << \"Reverse of num is \" << reverseDigits(num); \n\n\tgetchar(); \n\n\treturn 0; \n}\n",
        "category":"Basic Math",
        "adoption":true,
        "reason":null,
        "module_name":"ReverseDigits",
        "testbench":"SC_MODULE(Testbench) {\n    sc_signal<int> num_sig, rev_sig;\n\n    ReverseDigits dut{\"ReverseDigits\"};\n\n    SC_CTOR(Testbench) {\n        dut.num_in(num_sig);\n        dut.rev_out(rev_sig);\n\n        SC_THREAD(run_tests);\n    }\n\n    void run_tests() {\n        int input = 4562;\n        int expected = 2654;\n\n        num_sig.write(input);\n        wait(1, SC_NS); \/\/ 等待 combinational logic 生效\n\n        int result = rev_sig.read();\n        std::cout << \"Input: \" << input << \", Reversed: \" << result << std::endl;\n        assert(result == expected);\n\n        std::cout << \"All tests passed successfully.\\n\";\n        sc_stop();\n    }\n};\n\n\/\/ ──────────────── sc_main ────────────────\nint sc_main(int, char*[]) {\n    Testbench tb{\"tb\"};\n    sc_start();\n    return 0;\n}\n",
        "signal":"sc_in<int> num_in;\nsc_out<int> rev_out;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input.\n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<int> num_in;\nsc_out<int> rev_out;\n> **Note**:\n   - Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n   - If the static const are provided, insure to write them in the SystemC code as well.\n\n**C++\/C Code**:\n```\n\/\/ C++ program to implement \n\/\/ the above approach \n#include <bits\/stdc++.h> \nusing namespace std; \n\n\/\/ Iterative function to \n\/\/ reverse digits of num \nint reverseDigits(int num) \n{ \n\tint rev_num = 0; \n\twhile (num > 0) { \n\t\trev_num = rev_num * 10 + num % 10; \n\t\tnum = num \/ 10; \n\t} \n\treturn rev_num; \n} \n\n\/\/ Driver code \nint main() \n{ \n\tint num = 4562; \n\tcout << \"Reverse of num is \" << reverseDigits(num); \n\n\tgetchar(); \n\n\treturn 0; \n}\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\nFew_shot_example_1:\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        dont_initialize();\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n\nFew_shot_example_2:\n#include <systemc.h>\n\n\/\/ Module: BubbleSort\n\/\/ Sorts a small fixed-size array of integers using the bubble sort algorithm.\nSC_MODULE(BubbleSort) {\n    sc_in<bool>  clk;      \/\/ Clock signal\n    sc_in<bool>  start;    \/\/ Start signal to begin sorting\n    sc_out<bool> done;     \/\/ Signal asserted when sorting is complete\n\n    sc_in<int>   in_arr[4];  \/\/ Input array of 4 integers to be sorted\n    sc_out<int>  out_arr[4]; \/\/ Output array of 4 sorted integers\n\n    int buf[4];  \/\/ Internal buffer to hold array elements during sorting\n\n    \/\/ Constructor: registers the sorting process with the clock\n    SC_CTOR(BubbleSort) {\n        SC_THREAD(sort_proc);\n        sensitive << clk.pos();\n    }\n\n    \/\/ Thread: waits for start, performs bubble sort, writes results, toggles done\n    void sort_proc() {\n        const int N = 4;\n        while (true) {\n            wait();  \/\/ wait for next clock edge\n            if (start.read()) {\n                \/\/ Read inputs into internal buffer\n                for (int i = 0; i < N; ++i)\n                    buf[i] = in_arr[i].read();\n\n                \/\/ Perform bubble sort on buffer[]\n                for (int i = 0; i < N - 1; ++i)\n                    for (int j = 0; j < N - i - 1; ++j)\n                        if (buf[j] > buf[j + 1])\n                            std::swap(buf[j], buf[j + 1]);\n\n                \/\/ Write sorted results to output ports\n                for (int i = 0; i < N; ++i)\n                    out_arr[i].write(buf[i]);\n\n                \/\/ Signal done for one cycle\n                done.write(true);\n                wait();\n                done.write(false);\n            }\n        }\n    }\n};\n\nFew_shot_example_3:\n#include <systemc.h>\n\n\/\/ Module: MatrixAdder\n\/\/ Adds two 4×4 matrices of integers element-wise.\nSC_MODULE(MatrixAdder) {\n    sc_in<int> A[4*4];   \/\/ Flattened 4×4 input matrix A (16 elements)\n    sc_in<int> B[4*4];   \/\/ Flattened 4×4 input matrix B (16 elements)\n    sc_out<int> C[4*4];  \/\/ Flattened 4×4 output matrix C = A + B\n\n    \/\/ Constructor: registers a combinational add method sensitive to all inputs\n    SC_CTOR(MatrixAdder) {\n        SC_METHOD(do_add);\n        \/\/ Make the add method sensitive to every element of A and B\n        for (int i = 0; i < 4*4; i++) {\n            sensitive << A[i] << B[i];\n        }\n    }\n\n    \/\/ Method: reads A[i] and B[i], writes sum into C[i] for all 16 positions\n    void do_add() {\n        for (int i = 0; i < 4*4; i++) {\n            C[i].write(A[i].read() + B[i].read());\n        }\n    }\n};\n\n\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":60,
        "task":"RotateMatrixElementsofaMatrix",
        "code":"\/\/ C++ program to rotate a matrix \n#include <iostream> \n#define R 4 \n#define C 4 \nusing namespace std; \n\n\/\/ A function to rotate a matrix \n\/\/ mat[][] of size R x C. \n\/\/ Initially, m = R and n = C \nvoid rotatematrix(int m, int n, \n\t\t\t\tint mat[R][C]) \n{ \n\tint row = 0, col = 0; \n\tint prev, curr; \n\n\t\/* row - Starting row index \n\tm - ending row index \n\tcol - starting column index \n\tn - ending column index \n\ti - iterator *\/\n\twhile (row < m && col < n) \n\t{ \n\t\tif (row + 1 == m || \n\t\t\tcol + 1 == n) \n\t\t\tbreak; \n\n\t\t\/\/ Store the first element of \n\t\t\/\/ next row, this element will \n\t\t\/\/ replace first element of current \n\t\t\/\/ row \n\t\tprev = mat[row + 1][col]; \n\n\t\t\/* Move elements of first row from \n\t\tthe remaining rows *\/\n\t\tfor (int i = col; i < n; i++) \n\t\t{ \n\t\t\tcurr = mat[row][i]; \n\t\t\tmat[row][i] = prev; \n\t\t\tprev = curr; \n\t\t} \n\t\trow++; \n\n\t\t\/* Move elements of last column \n\t\tfrom the remaining columns *\/\n\t\tfor (int i = row; i < m; i++) \n\t\t{ \n\t\t\tcurr = mat[i][n-1]; \n\t\t\tmat[i][n-1] = prev; \n\t\t\tprev = curr; \n\t\t} \n\t\tn--; \n\n\t\t\/* Move elements of last row from \n\t\tthe remaining rows *\/\n\t\tif (row < m) \n\t\t{ \n\t\t\tfor (int i = n-1; i >= col; i--) \n\t\t\t{ \n\t\t\t\tcurr = mat[m-1][i]; \n\t\t\t\tmat[m-1][i] = prev; \n\t\t\t\tprev = curr; \n\t\t\t} \n\t\t} \n\t\tm--; \n\n\t\t\/* Move elements of first column from \n\t\tthe remaining rows *\/\n\t\tif (col < n) \n\t\t{ \n\t\t\tfor (int i = m-1; i >= row; i--) \n\t\t\t{ \n\t\t\t\tcurr = mat[i][col]; \n\t\t\t\tmat[i][col] = prev; \n\t\t\t\tprev = curr; \n\t\t\t} \n\t\t} \n\t\tcol++; \n\t} \n\n\t\/\/ Print rotated matrix \n\tfor (int i=0; i<R; i++) \n\t{ \n\t\tfor (int j=0; j<C; j++) \n\t\tcout << mat[i][j] << \" \"; \n\t\tcout << endl; \n\t} \n} \n\n\/\/ Driver code \nint main() \n{ \n\t\/\/ Test Case 1 \n\tint a[R][C] = {{1, 2, 3, 4}, \n\t\t\t\t{5, 6, 7, 8}, \n\t\t\t\t{9, 10, 11, 12}, \n\t\t\t\t{13, 14, 15, 16}}; \n\n\t\/\/ Test Case 2 \n\t\/* int a[R][C] = {{1, 2, 3}, \n\t\t\t\t\t{4, 5, 6}, \n\t\t\t\t\t{7, 8, 9}}; \n\t*\/ rotatematrix(R, C, a); \n\treturn 0; \n} \n",
        "category":"Matrix Operation",
        "adoption":true,
        "reason":null,
        "module_name":"MatrixRotator",
        "testbench":"SC_MODULE(Testbench) {\n    \n    \/\/ Signals to connect to the MatrixRotator ports\n    sc_signal<int> in[4*4];\n    sc_signal<int> out[4*4];\n\n    MatrixRotator* matrixRotator;\n\n    SC_CTOR(Testbench) {\n        \/\/ Instantiate the MatrixRotator module\n        matrixRotator = new MatrixRotator(\"matrixRotator\");\n        \/\/ Connect the signals\n        for (int i = 0; i < 4*4; i++) {\n            matrixRotator->in[i](in[i]);\n            matrixRotator->out[i](out[i]);\n        }\n        SC_THREAD(run_tests);\n    }\n\n    \/\/ Thread to initialize the matrix, check outputs, and assert correctness\n    void run_tests() {\n        \/\/ Initialize the matrix with test values:\n        \/\/ { 1,  2,  3,  4,\n        \/\/   5,  6,  7,  8,\n        \/\/   9, 10, 11, 12,\n        \/\/  13, 14, 15, 16 }\n        int init[4*4] = {\n            1, 2, 3, 4,\n            5, 6, 7, 8,\n            9, 10, 11, 12,\n            13, 14, 15, 16\n        };\n        for (int i = 0; i < 4*4; i++) {\n            in[i].write(init[i]);\n        }\n\n        \/\/ Wait for the signals to propagate\n        wait(1, SC_NS);\n\n        \/\/ Expected rotated matrix is:\n        \/\/  5   1   2   3\n        \/\/  9  10   6   4\n        \/\/ 13  11   7   8\n        \/\/ 14  15  16  12\n        int expected[4*4] = {\n            5, 1, 2, 3,\n            9, 10, 6, 4,\n            13, 11, 7, 8,\n            14, 15, 16, 12\n        };\n\n        \/\/ Check the output matrix and print the result\n        std::cout << \"Rotated Matrix:\" << std::endl;\n        for (int i = 0; i < 4; i++) {\n            for (int j = 0; j < 4; j++) {\n                int index = i * 4 + j;\n                int result = out[index].read();\n                std::cout << result << \" \";\n                \/\/ Validate the result using assert\n                assert(result == expected[index]);\n            }\n            std::cout << std::endl;\n        }\n        std::cout << \"All tests passed successfully.\" << std::endl;\n\n        sc_stop(); \/\/ End the simulation\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); \/\/ Create an instance of the Testbench\n    sc_start();         \/\/ Start the simulation\n    return 0;\n}\n",
        "signal":"sc_in<int> in[4*4];\nsc_out<int> out[4*4];",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input.\n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<int> in[4*4];\nsc_out<int> out[4*4];\n> **Note**:\n   - Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n   - If the static const are provided, insure to write them in the SystemC code as well.\n\n**C++\/C Code**:\n```\n\/\/ C++ program to rotate a matrix \n#include <iostream> \n#define R 4 \n#define C 4 \nusing namespace std; \n\n\/\/ A function to rotate a matrix \n\/\/ mat[][] of size R x C. \n\/\/ Initially, m = R and n = C \nvoid rotatematrix(int m, int n, \n\t\t\t\tint mat[R][C]) \n{ \n\tint row = 0, col = 0; \n\tint prev, curr; \n\n\t\/* row - Starting row index \n\tm - ending row index \n\tcol - starting column index \n\tn - ending column index \n\ti - iterator *\/\n\twhile (row < m && col < n) \n\t{ \n\t\tif (row + 1 == m || \n\t\t\tcol + 1 == n) \n\t\t\tbreak; \n\n\t\t\/\/ Store the first element of \n\t\t\/\/ next row, this element will \n\t\t\/\/ replace first element of current \n\t\t\/\/ row \n\t\tprev = mat[row + 1][col]; \n\n\t\t\/* Move elements of first row from \n\t\tthe remaining rows *\/\n\t\tfor (int i = col; i < n; i++) \n\t\t{ \n\t\t\tcurr = mat[row][i]; \n\t\t\tmat[row][i] = prev; \n\t\t\tprev = curr; \n\t\t} \n\t\trow++; \n\n\t\t\/* Move elements of last column \n\t\tfrom the remaining columns *\/\n\t\tfor (int i = row; i < m; i++) \n\t\t{ \n\t\t\tcurr = mat[i][n-1]; \n\t\t\tmat[i][n-1] = prev; \n\t\t\tprev = curr; \n\t\t} \n\t\tn--; \n\n\t\t\/* Move elements of last row from \n\t\tthe remaining rows *\/\n\t\tif (row < m) \n\t\t{ \n\t\t\tfor (int i = n-1; i >= col; i--) \n\t\t\t{ \n\t\t\t\tcurr = mat[m-1][i]; \n\t\t\t\tmat[m-1][i] = prev; \n\t\t\t\tprev = curr; \n\t\t\t} \n\t\t} \n\t\tm--; \n\n\t\t\/* Move elements of first column from \n\t\tthe remaining rows *\/\n\t\tif (col < n) \n\t\t{ \n\t\t\tfor (int i = m-1; i >= row; i--) \n\t\t\t{ \n\t\t\t\tcurr = mat[i][col]; \n\t\t\t\tmat[i][col] = prev; \n\t\t\t\tprev = curr; \n\t\t\t} \n\t\t} \n\t\tcol++; \n\t} \n\n\t\/\/ Print rotated matrix \n\tfor (int i=0; i<R; i++) \n\t{ \n\t\tfor (int j=0; j<C; j++) \n\t\tcout << mat[i][j] << \" \"; \n\t\tcout << endl; \n\t} \n} \n\n\/\/ Driver code \nint main() \n{ \n\t\/\/ Test Case 1 \n\tint a[R][C] = {{1, 2, 3, 4}, \n\t\t\t\t{5, 6, 7, 8}, \n\t\t\t\t{9, 10, 11, 12}, \n\t\t\t\t{13, 14, 15, 16}}; \n\n\t\/\/ Test Case 2 \n\t\/* int a[R][C] = {{1, 2, 3}, \n\t\t\t\t\t{4, 5, 6}, \n\t\t\t\t\t{7, 8, 9}}; \n\t*\/ rotatematrix(R, C, a); \n\treturn 0; \n} \n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\nFew_shot_example_1:\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        dont_initialize();\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n\nFew_shot_example_2:\n#include <systemc.h>\n\n\/\/ Module: BubbleSort\n\/\/ Sorts a small fixed-size array of integers using the bubble sort algorithm.\nSC_MODULE(BubbleSort) {\n    sc_in<bool>  clk;      \/\/ Clock signal\n    sc_in<bool>  start;    \/\/ Start signal to begin sorting\n    sc_out<bool> done;     \/\/ Signal asserted when sorting is complete\n\n    sc_in<int>   in_arr[4];  \/\/ Input array of 4 integers to be sorted\n    sc_out<int>  out_arr[4]; \/\/ Output array of 4 sorted integers\n\n    int buf[4];  \/\/ Internal buffer to hold array elements during sorting\n\n    \/\/ Constructor: registers the sorting process with the clock\n    SC_CTOR(BubbleSort) {\n        SC_THREAD(sort_proc);\n        sensitive << clk.pos();\n    }\n\n    \/\/ Thread: waits for start, performs bubble sort, writes results, toggles done\n    void sort_proc() {\n        const int N = 4;\n        while (true) {\n            wait();  \/\/ wait for next clock edge\n            if (start.read()) {\n                \/\/ Read inputs into internal buffer\n                for (int i = 0; i < N; ++i)\n                    buf[i] = in_arr[i].read();\n\n                \/\/ Perform bubble sort on buffer[]\n                for (int i = 0; i < N - 1; ++i)\n                    for (int j = 0; j < N - i - 1; ++j)\n                        if (buf[j] > buf[j + 1])\n                            std::swap(buf[j], buf[j + 1]);\n\n                \/\/ Write sorted results to output ports\n                for (int i = 0; i < N; ++i)\n                    out_arr[i].write(buf[i]);\n\n                \/\/ Signal done for one cycle\n                done.write(true);\n                wait();\n                done.write(false);\n            }\n        }\n    }\n};\n\nFew_shot_example_3:\n#include <systemc.h>\n\n\/\/ Module: MatrixAdder\n\/\/ Adds two 4×4 matrices of integers element-wise.\nSC_MODULE(MatrixAdder) {\n    sc_in<int> A[4*4];   \/\/ Flattened 4×4 input matrix A (16 elements)\n    sc_in<int> B[4*4];   \/\/ Flattened 4×4 input matrix B (16 elements)\n    sc_out<int> C[4*4];  \/\/ Flattened 4×4 output matrix C = A + B\n\n    \/\/ Constructor: registers a combinational add method sensitive to all inputs\n    SC_CTOR(MatrixAdder) {\n        SC_METHOD(do_add);\n        \/\/ Make the add method sensitive to every element of A and B\n        for (int i = 0; i < 4*4; i++) {\n            sensitive << A[i] << B[i];\n        }\n    }\n\n    \/\/ Method: reads A[i] and B[i], writes sum into C[i] for all 16 positions\n    void do_add() {\n        for (int i = 0; i < 4*4; i++) {\n            C[i].write(A[i].read() + B[i].read());\n        }\n    }\n};\n\n\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":61,
        "task":"SearchanElementinanArray_BinarySearch",
        "code":"\/\/ C++ program to implement iterative \n\/\/ binary search\n#include <bits\/stdc++.h>\nusing namespace std;\n\nbool binarySearch(vector<int>& v, int target) {\n    \n      \/\/ Defining the part of the vector to be\n      \/\/ searched\n    int low = 0, high = v.size() - 1;\n      \n      \/\/ Till the element is found or vector cannot\n      \/\/ be divided into more parts\n    while (low <= high) {\n      \n          \/\/ Finding mid point\n        int mid = ((high - low) \/ 2) + low;\n\n        \/\/ If the middle element is equal to target\n        if (v[mid] == target) {\n            return true;\n        }\n\n        \/\/ If the middle element is greater than \n        \/\/ target, search in the left half \n        if (v[mid] > target)\n            high = mid - 1;\n        \n        \/\/ If the middle element is smaller than\n        \/\/ target, search the right half \n        else\n            low = mid + 1;\n    }\n      \n      \/\/ If we don't find the target\n      return false;\n}\n\nint main() {\n    vector<int> v = {1, 2, 3, 4, 5, 8, 9, 11};\n    \n      \/\/ Element to be searched\n      int target = 8;\n  \n      \/\/ Searching the target element\n    if (binarySearch(v, target)) {\n        cout << target << \" found.\";\n    } else {\n        cout << target << \" NOT found.\";\n    }\n    return 0;\n}\n",
        "category":"Array Operation",
        "adoption":true,
        "reason":null,
        "module_name":"BinarySearchModule",
        "testbench":"SC_MODULE(Testbench) {\n    sc_signal<int> sig_v0, sig_v1, sig_v2, sig_v3;\n    sc_signal<int> sig_v4, sig_v5, sig_v6, sig_v7;\n    sc_signal<int> target_sig;\n    sc_signal<bool> found_sig;\n\n    BinarySearchModule bs_inst;\n\n    SC_CTOR(Testbench)\n    : bs_inst(\"bs_inst\")\n    {\n        \/\/ Bind each port\n        bs_inst.v0(sig_v0);\n        bs_inst.v1(sig_v1);\n        bs_inst.v2(sig_v2);\n        bs_inst.v3(sig_v3);\n        bs_inst.v4(sig_v4);\n        bs_inst.v5(sig_v5);\n        bs_inst.v6(sig_v6);\n        bs_inst.v7(sig_v7);\n        bs_inst.target(target_sig);\n        bs_inst.found(found_sig);\n\n        SC_THREAD(run_tests);\n    }\n\n    void run_tests() {\n        \/\/ Initialize sorted vector\n        int vals[8] = {1,2,3,4,5,8,9,11};\n        sig_v0.write(vals[0]);\n        sig_v1.write(vals[1]);\n        sig_v2.write(vals[2]);\n        sig_v3.write(vals[3]);\n        sig_v4.write(vals[4]);\n        sig_v5.write(vals[5]);\n        sig_v6.write(vals[6]);\n        sig_v7.write(vals[7]);\n\n        \/\/ Test 1: found\n        target_sig.write(8);\n        wait(1, SC_NS);\n        assert(found_sig.read() == true);\n        std::cout << \"Found 8: \" << found_sig.read() << std::endl;\n\n        \/\/ Test 2: not found\n        target_sig.write(7);\n        wait(1, SC_NS);\n        assert(found_sig.read() == false);\n        std::cout << \"Found 7: \" << found_sig.read() << std::endl;\n\n        std::cout << \"All tests completed successfully.\" << std::endl;\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\");\n    sc_start();\n    return 0;\n}\n",
        "signal":"sc_in<int> v0, v1, v2, v3, v4, v5, v6, v7;\nsc_in<int> target;\nsc_out<bool> found;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input.\n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<int> v0, v1, v2, v3, v4, v5, v6, v7;\nsc_in<int> target;\nsc_out<bool> found;\n> **Note**:\n   - Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n   - If the static const are provided, insure to write them in the SystemC code as well.\n\n**C++\/C Code**:\n```\n\/\/ C++ program to implement iterative \n\/\/ binary search\n#include <bits\/stdc++.h>\nusing namespace std;\n\nbool binarySearch(vector<int>& v, int target) {\n    \n      \/\/ Defining the part of the vector to be\n      \/\/ searched\n    int low = 0, high = v.size() - 1;\n      \n      \/\/ Till the element is found or vector cannot\n      \/\/ be divided into more parts\n    while (low <= high) {\n      \n          \/\/ Finding mid point\n        int mid = ((high - low) \/ 2) + low;\n\n        \/\/ If the middle element is equal to target\n        if (v[mid] == target) {\n            return true;\n        }\n\n        \/\/ If the middle element is greater than \n        \/\/ target, search in the left half \n        if (v[mid] > target)\n            high = mid - 1;\n        \n        \/\/ If the middle element is smaller than\n        \/\/ target, search the right half \n        else\n            low = mid + 1;\n    }\n      \n      \/\/ If we don't find the target\n      return false;\n}\n\nint main() {\n    vector<int> v = {1, 2, 3, 4, 5, 8, 9, 11};\n    \n      \/\/ Element to be searched\n      int target = 8;\n  \n      \/\/ Searching the target element\n    if (binarySearch(v, target)) {\n        cout << target << \" found.\";\n    } else {\n        cout << target << \" NOT found.\";\n    }\n    return 0;\n}\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\nFew_shot_example_1:\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        dont_initialize();\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n\nFew_shot_example_2:\n#include <systemc.h>\n\n\/\/ Module: BubbleSort\n\/\/ Sorts a small fixed-size array of integers using the bubble sort algorithm.\nSC_MODULE(BubbleSort) {\n    sc_in<bool>  clk;      \/\/ Clock signal\n    sc_in<bool>  start;    \/\/ Start signal to begin sorting\n    sc_out<bool> done;     \/\/ Signal asserted when sorting is complete\n\n    sc_in<int>   in_arr[4];  \/\/ Input array of 4 integers to be sorted\n    sc_out<int>  out_arr[4]; \/\/ Output array of 4 sorted integers\n\n    int buf[4];  \/\/ Internal buffer to hold array elements during sorting\n\n    \/\/ Constructor: registers the sorting process with the clock\n    SC_CTOR(BubbleSort) {\n        SC_THREAD(sort_proc);\n        sensitive << clk.pos();\n    }\n\n    \/\/ Thread: waits for start, performs bubble sort, writes results, toggles done\n    void sort_proc() {\n        const int N = 4;\n        while (true) {\n            wait();  \/\/ wait for next clock edge\n            if (start.read()) {\n                \/\/ Read inputs into internal buffer\n                for (int i = 0; i < N; ++i)\n                    buf[i] = in_arr[i].read();\n\n                \/\/ Perform bubble sort on buffer[]\n                for (int i = 0; i < N - 1; ++i)\n                    for (int j = 0; j < N - i - 1; ++j)\n                        if (buf[j] > buf[j + 1])\n                            std::swap(buf[j], buf[j + 1]);\n\n                \/\/ Write sorted results to output ports\n                for (int i = 0; i < N; ++i)\n                    out_arr[i].write(buf[i]);\n\n                \/\/ Signal done for one cycle\n                done.write(true);\n                wait();\n                done.write(false);\n            }\n        }\n    }\n};\n\nFew_shot_example_3:\n#include <systemc.h>\n\n\/\/ Module: MatrixAdder\n\/\/ Adds two 4×4 matrices of integers element-wise.\nSC_MODULE(MatrixAdder) {\n    sc_in<int> A[4*4];   \/\/ Flattened 4×4 input matrix A (16 elements)\n    sc_in<int> B[4*4];   \/\/ Flattened 4×4 input matrix B (16 elements)\n    sc_out<int> C[4*4];  \/\/ Flattened 4×4 output matrix C = A + B\n\n    \/\/ Constructor: registers a combinational add method sensitive to all inputs\n    SC_CTOR(MatrixAdder) {\n        SC_METHOD(do_add);\n        \/\/ Make the add method sensitive to every element of A and B\n        for (int i = 0; i < 4*4; i++) {\n            sensitive << A[i] << B[i];\n        }\n    }\n\n    \/\/ Method: reads A[i] and B[i], writes sum into C[i] for all 16 positions\n    void do_add() {\n        for (int i = 0; i < 4*4; i++) {\n            C[i].write(A[i].read() + B[i].read());\n        }\n    }\n};\n\n\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":62,
        "task":"SearchanElementinanArray_LinearSearch",
        "code":"\/\/ C++ Program to implement linear search \n\/\/ algorithm iteratively\n#include <bits\/stdc++.h>\nusing namespace std;\n\nint linearSearch(vector<int> v, int key) {\n      \n      \/\/ We test all the elements of the vector\n      \/\/ v against the given key\n      for (int i = 0; i < v.size(); i++) {\n      \n          \/\/ If the KEY IS FOUND\n          if (v[i] == key) {\n              return i;\n        }\n    }\n      \n      \/\/ Return some value denoting KEY NOT FOUND\n      return -1;\n}\n\nint main() {\n    vector<int> v = {1, 2, 3, 4, 5, 8, 9, 11};\n  \n    \/\/ Value to search\n      int key = 8;\n\n    \/\/ Searching the key in the vector v\n      int i = linearSearch(v, key);\n      \n      \/\/ Checking if element is found or not\n    if (i != -1)\n        cout << key << \" Found at Position: \" <<\n              i + 1;\n    else\n        cout << key << \" NOT found.\";\n    return 0;\n}\n",
        "category":"Array Operation",
        "adoption":true,
        "reason":null,
        "module_name":"LinearSearch",
        "testbench":"SC_MODULE(Testbench) {\n    \/\/ Signals for data array\n    sc_signal<int> sig_data0, sig_data1, sig_data2, sig_data3;\n    sc_signal<int> sig_data4, sig_data5, sig_data6, sig_data7;\n\n    sc_signal<int> key_sig;    \/\/ key\n    sc_signal<int> index_sig;  \/\/ result\n\n    LinearSearch ls_inst;      \/\/ instance\n\n    SC_CTOR(Testbench)\n    : ls_inst(\"ls_inst\")\n    {\n        \/\/ bind data signals\n        ls_inst.data0(sig_data0);\n        ls_inst.data1(sig_data1);\n        ls_inst.data2(sig_data2);\n        ls_inst.data3(sig_data3);\n        ls_inst.data4(sig_data4);\n        ls_inst.data5(sig_data5);\n        ls_inst.data6(sig_data6);\n        ls_inst.data7(sig_data7);\n\n        ls_inst.key(key_sig);\n        ls_inst.index(index_sig);\n\n        \/\/ initialize array values\n        int vals[8] = {1,2,3,4,5,8,9,11};\n        sig_data0.write(vals[0]);\n        sig_data1.write(vals[1]);\n        sig_data2.write(vals[2]);\n        sig_data3.write(vals[3]);\n        sig_data4.write(vals[4]);\n        sig_data5.write(vals[5]);\n        sig_data6.write(vals[6]);\n        sig_data7.write(vals[7]);\n\n        SC_THREAD(run_tests);\n    }\n\n    void run_tests() {\n        \/\/ Test 1: expect index 5\n        key_sig.write(8);\n        wait(1, SC_NS);\n        assert(index_sig.read() == 5);\n        std::cout << \"Test 1 Passed: 8 found at index \" << index_sig.read() << std::endl;\n\n        \/\/ Test 2: expect -1\n        key_sig.write(10);\n        wait(1, SC_NS);\n        assert(index_sig.read() == -1);\n        std::cout << \"Test 2 Passed: 10 not found (index: \" << index_sig.read() << \")\" << std::endl;\n\n        \/\/ Test 3: expect 0\n        key_sig.write(1);\n        wait(1, SC_NS);\n        assert(index_sig.read() == 0);\n        std::cout << \"Test 3 Passed: 1 found at index \" << index_sig.read() << std::endl;\n\n        std::cout << \"All tests completed successfully.\" << std::endl;\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\");\n    sc_start();\n    return 0;\n}\n",
        "signal":"sc_in<int> data0, data1, data2, data3;\nsc_in<int> data4, data5, data6, data7;\nsc_in<int> key;\nsc_out<int> index;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input.\n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<int> data0, data1, data2, data3;\nsc_in<int> data4, data5, data6, data7;\nsc_in<int> key;\nsc_out<int> index;\n> **Note**:\n   - Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n   - If the static const are provided, insure to write them in the SystemC code as well.\n\n**C++\/C Code**:\n```\n\/\/ C++ Program to implement linear search \n\/\/ algorithm iteratively\n#include <bits\/stdc++.h>\nusing namespace std;\n\nint linearSearch(vector<int> v, int key) {\n      \n      \/\/ We test all the elements of the vector\n      \/\/ v against the given key\n      for (int i = 0; i < v.size(); i++) {\n      \n          \/\/ If the KEY IS FOUND\n          if (v[i] == key) {\n              return i;\n        }\n    }\n      \n      \/\/ Return some value denoting KEY NOT FOUND\n      return -1;\n}\n\nint main() {\n    vector<int> v = {1, 2, 3, 4, 5, 8, 9, 11};\n  \n    \/\/ Value to search\n      int key = 8;\n\n    \/\/ Searching the key in the vector v\n      int i = linearSearch(v, key);\n      \n      \/\/ Checking if element is found or not\n    if (i != -1)\n        cout << key << \" Found at Position: \" <<\n              i + 1;\n    else\n        cout << key << \" NOT found.\";\n    return 0;\n}\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\nFew_shot_example_1:\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        dont_initialize();\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n\nFew_shot_example_2:\n#include <systemc.h>\n\n\/\/ Module: BubbleSort\n\/\/ Sorts a small fixed-size array of integers using the bubble sort algorithm.\nSC_MODULE(BubbleSort) {\n    sc_in<bool>  clk;      \/\/ Clock signal\n    sc_in<bool>  start;    \/\/ Start signal to begin sorting\n    sc_out<bool> done;     \/\/ Signal asserted when sorting is complete\n\n    sc_in<int>   in_arr[4];  \/\/ Input array of 4 integers to be sorted\n    sc_out<int>  out_arr[4]; \/\/ Output array of 4 sorted integers\n\n    int buf[4];  \/\/ Internal buffer to hold array elements during sorting\n\n    \/\/ Constructor: registers the sorting process with the clock\n    SC_CTOR(BubbleSort) {\n        SC_THREAD(sort_proc);\n        sensitive << clk.pos();\n    }\n\n    \/\/ Thread: waits for start, performs bubble sort, writes results, toggles done\n    void sort_proc() {\n        const int N = 4;\n        while (true) {\n            wait();  \/\/ wait for next clock edge\n            if (start.read()) {\n                \/\/ Read inputs into internal buffer\n                for (int i = 0; i < N; ++i)\n                    buf[i] = in_arr[i].read();\n\n                \/\/ Perform bubble sort on buffer[]\n                for (int i = 0; i < N - 1; ++i)\n                    for (int j = 0; j < N - i - 1; ++j)\n                        if (buf[j] > buf[j + 1])\n                            std::swap(buf[j], buf[j + 1]);\n\n                \/\/ Write sorted results to output ports\n                for (int i = 0; i < N; ++i)\n                    out_arr[i].write(buf[i]);\n\n                \/\/ Signal done for one cycle\n                done.write(true);\n                wait();\n                done.write(false);\n            }\n        }\n    }\n};\n\nFew_shot_example_3:\n#include <systemc.h>\n\n\/\/ Module: MatrixAdder\n\/\/ Adds two 4×4 matrices of integers element-wise.\nSC_MODULE(MatrixAdder) {\n    sc_in<int> A[4*4];   \/\/ Flattened 4×4 input matrix A (16 elements)\n    sc_in<int> B[4*4];   \/\/ Flattened 4×4 input matrix B (16 elements)\n    sc_out<int> C[4*4];  \/\/ Flattened 4×4 output matrix C = A + B\n\n    \/\/ Constructor: registers a combinational add method sensitive to all inputs\n    SC_CTOR(MatrixAdder) {\n        SC_METHOD(do_add);\n        \/\/ Make the add method sensitive to every element of A and B\n        for (int i = 0; i < 4*4; i++) {\n            sensitive << A[i] << B[i];\n        }\n    }\n\n    \/\/ Method: reads A[i] and B[i], writes sum into C[i] for all 16 positions\n    void do_add() {\n        for (int i = 0; i < 4*4; i++) {\n            C[i].write(A[i].read() + B[i].read());\n        }\n    }\n};\n\n\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":63,
        "task":"SortanArray_BubbleSort",
        "code":"\/\/ C program for implementation of Bubble sort\n#include <stdio.h>\n\nvoid swap(int* arr, int i, int j) {\n    int temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n}\n\nvoid bubbleSort(int arr[], int n) {\n    for (int i = 0; i < n - 1; i++) {\n      \n        \/\/ Last i elements are already in place, so the loop\n        \/\/ will only num n - i - 1 times\n        for (int j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[j + 1])\n                swap(arr, j, j + 1);\n        }\n    }\n}\n\nint main() {\n    int arr[] = { 6, 0, 3, 5 };\n    int n = sizeof(arr) \/ sizeof(arr[0]);\n\n    \/\/ Calling bubble sort on array arr\n    bubbleSort(arr, n);\n\n    for (int i = 0; i < n; i++)\n        printf(\"%d \", arr[i]);\n\n    return 0;\n}\n",
        "category":"Array Operation",
        "adoption":false,
        "reason":null,
        "module_name":"BubbleSort",
        "testbench":"SC_MODULE(Testbench) {\n    sc_clock        clk{\"clk\", 1, SC_NS};\n    sc_signal<bool> start, done;\n    sc_signal<int>  sig_in[4], sig_out[4];\n\n    BubbleSort*     dut;\n\n    SC_CTOR(Testbench) {\n        \/* 例化並連線 *\/\n        dut = new BubbleSort(\"BubbleSort\");\n        dut->clk(clk);\n        dut->start(start);\n        dut->done(done);\n        for (int i = 0; i < 4; ++i) {\n            dut->in_arr[i](sig_in[i]);\n            dut->out_arr[i](sig_out[i]);\n        }\n\n        SC_THREAD(run_tests);   \/\/ thread 於模擬開始執行\n    }\n\n    void run_tests() {\n        int data[4]     = {6, 0, 3, 5};\n        int expected[4] = {0, 3, 5, 6};\n\n        \/* ▸ 餵入資料 *\/\n        for (int i = 0; i < 4; ++i)\n            sig_in[i].write(data[i]);\n\n        \/* ▸ 觸發排序 *\/\n        wait(clk.posedge_event());\n        start.write(true);\n        wait(clk.posedge_event());\n        start.write(false);\n\n        \/* ▸ 等待 done=1 *\/\n        wait(done.posedge_event());\n\n        \/* ▸ 讀出結果並驗證 *\/\n        for (int i = 0; i < 4; ++i) {\n            int v = sig_out[i].read();\n            std::cout << \"Element \" << i << \" sorted value: \" << v << '\\n';\n            assert(v == expected[i]);\n        }\n        std::cout << \"All tests passed successfully.\\n\";\n        sc_stop();\n    }\n};\n\n\/\/ ──────────────── sc_main ────────────────\nint sc_main(int, char*[]) {\n    Testbench tb{\"tb\"};\n    sc_start();\n    return 0;\n}\n",
        "signal":"sc_in<bool>  clk;\nsc_in<bool>  start;\nsc_out<bool> done;\nsc_in<int>   in_arr[4];\nsc_out<int>  out_arr[4];",
        "prompt":null
    },
    {
        "task_id":64,
        "task":"SortanArray_InsertionSort",
        "code":"\/\/ C++ program to sort \n\/\/ 2D matrix row-wise\n#include<bits\/stdc++.h>\nusing namespace std;\n\nvoid sortRowWise(int m[][4],\n\t\t\t\tint r, int c)\n{\n\/\/ Loop for rows of matrix\nfor (int i = 0; i < r; i++) \n{\n\t\/\/ Loop for column of matrix\n\tfor (int j = 0; j < c; j++) \n\t{\n\t\/\/ Loop for comparison and swapping\n\tfor (int k = 0; k < c - j - 1; k++) \n\t{\n\t\tif (m[i][k] > m[i][k + 1]) \n\t\t{\n\t\t\/\/ Swapping of elements\n\t\tswap(m[i][k], m[i][k + 1]);\n\t\t}\n\t}\n\t}\n}\n\n\/\/ Printing the sorted matrix\nfor (int i = 0; i < r; i++) \n{\n\tfor (int j = 0; j < c; j++)\n\tcout << m[i][j] << \" \";\n\tcout << endl;\n}\n}\n\n\/\/ Driver code\nint main()\n{\nint m[][4] = {{9, 8, 7, 1},\n\t\t\t\t{7, 3, 0, 2},\n\t\t\t\t{9, 5, 3, 2},\n\t\t\t\t{6, 3, 1, 2}};\nint c = sizeof(m[0]) \/ sizeof(m[0][0]);\nint r = sizeof(m) \/ sizeof(m[0]);\nsortRowWise(m, r, c);\nreturn 0;\n}\n",
        "category":"Matrix Operation",
        "adoption":true,
        "reason":null,
        "module_name":"RowWiseSorter",
        "testbench":"SC_MODULE(Testbench) {\n    sc_clock clk{\"clk\", 1, SC_NS};\n    sc_signal<bool> start, done;\n    sc_signal<int> sig_in[4][4], sig_out[4][4];\n\n    RowWiseSorter* dut;\n\n    SC_CTOR(Testbench) {\n        dut = new RowWiseSorter(\"RowWiseSorter\");\n        dut->clk(clk);\n        dut->start(start);\n        dut->done(done);\n        for (int i = 0; i < 4; ++i)\n            for (int j = 0; j < 4; ++j) {\n                dut->in_mat[i][j](sig_in[i][j]);\n                dut->out_mat[i][j](sig_out[i][j]);\n            }\n\n        SC_THREAD(run_tests);\n    }\n\n    void run_tests() {\n        int data[4][4] = {\n            {9, 8, 7, 1},\n            {7, 3, 0, 2},\n            {9, 5, 3, 2},\n            {6, 3, 1, 2}\n        };\n\n        int expected[4][4] = {\n            {1, 7, 8, 9},\n            {0, 2, 3, 7},\n            {2, 3, 5, 9},\n            {1, 2, 3, 6}\n        };\n\n        \/\/ Write input\n        for (int i = 0; i < 4; ++i)\n            for (int j = 0; j < 4; ++j)\n                sig_in[i][j].write(data[i][j]);\n\n        \/\/ Trigger sort\n        wait(clk.posedge_event());\n        start.write(true);\n        wait(clk.posedge_event());\n        start.write(false);\n\n        \/\/ Wait for done signal\n        wait(done.posedge_event());\n\n        \/\/ Check result\n        for (int i = 0; i < 4; ++i)\n            for (int j = 0; j < 4; ++j) {\n                int val = sig_out[i][j].read();\n                std::cout << \"out[\" << i << \"][\" << j << \"] = \" << val << std::endl;\n                assert(val == expected[i][j]);\n            }\n\n        cout << \"All tests passed successfully.\\n\";\n        sc_stop();\n    }\n};\n\n\/\/ ─────────────── sc_main ───────────────\nint sc_main(int, char*[]) {\n    Testbench tb(\"tb\");\n    sc_start();\n    return 0;\n}",
        "signal":"sc_in<bool> clk;\nsc_in<bool> start;\nsc_out<bool> done;\nsc_in<int>  in_mat[4][4];\nsc_out<int> out_mat[4][4];",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input.\n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<bool> clk;\nsc_in<bool> start;\nsc_out<bool> done;\nsc_in<int>  in_mat[4][4];\nsc_out<int> out_mat[4][4];\n> **Note**:\n   - Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n   - If the static const are provided, insure to write them in the SystemC code as well.\n\n**C++\/C Code**:\n```\n\/\/ C++ program to sort \n\/\/ 2D matrix row-wise\n#include<bits\/stdc++.h>\nusing namespace std;\n\nvoid sortRowWise(int m[][4],\n\t\t\t\tint r, int c)\n{\n\/\/ Loop for rows of matrix\nfor (int i = 0; i < r; i++) \n{\n\t\/\/ Loop for column of matrix\n\tfor (int j = 0; j < c; j++) \n\t{\n\t\/\/ Loop for comparison and swapping\n\tfor (int k = 0; k < c - j - 1; k++) \n\t{\n\t\tif (m[i][k] > m[i][k + 1]) \n\t\t{\n\t\t\/\/ Swapping of elements\n\t\tswap(m[i][k], m[i][k + 1]);\n\t\t}\n\t}\n\t}\n}\n\n\/\/ Printing the sorted matrix\nfor (int i = 0; i < r; i++) \n{\n\tfor (int j = 0; j < c; j++)\n\tcout << m[i][j] << \" \";\n\tcout << endl;\n}\n}\n\n\/\/ Driver code\nint main()\n{\nint m[][4] = {{9, 8, 7, 1},\n\t\t\t\t{7, 3, 0, 2},\n\t\t\t\t{9, 5, 3, 2},\n\t\t\t\t{6, 3, 1, 2}};\nint c = sizeof(m[0]) \/ sizeof(m[0][0]);\nint r = sizeof(m) \/ sizeof(m[0]);\nsortRowWise(m, r, c);\nreturn 0;\n}\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\nFew_shot_example_1:\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        dont_initialize();\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n\nFew_shot_example_2:\n#include <systemc.h>\n\n\/\/ Module: BubbleSort\n\/\/ Sorts a small fixed-size array of integers using the bubble sort algorithm.\nSC_MODULE(BubbleSort) {\n    sc_in<bool>  clk;      \/\/ Clock signal\n    sc_in<bool>  start;    \/\/ Start signal to begin sorting\n    sc_out<bool> done;     \/\/ Signal asserted when sorting is complete\n\n    sc_in<int>   in_arr[4];  \/\/ Input array of 4 integers to be sorted\n    sc_out<int>  out_arr[4]; \/\/ Output array of 4 sorted integers\n\n    int buf[4];  \/\/ Internal buffer to hold array elements during sorting\n\n    \/\/ Constructor: registers the sorting process with the clock\n    SC_CTOR(BubbleSort) {\n        SC_THREAD(sort_proc);\n        sensitive << clk.pos();\n    }\n\n    \/\/ Thread: waits for start, performs bubble sort, writes results, toggles done\n    void sort_proc() {\n        const int N = 4;\n        while (true) {\n            wait();  \/\/ wait for next clock edge\n            if (start.read()) {\n                \/\/ Read inputs into internal buffer\n                for (int i = 0; i < N; ++i)\n                    buf[i] = in_arr[i].read();\n\n                \/\/ Perform bubble sort on buffer[]\n                for (int i = 0; i < N - 1; ++i)\n                    for (int j = 0; j < N - i - 1; ++j)\n                        if (buf[j] > buf[j + 1])\n                            std::swap(buf[j], buf[j + 1]);\n\n                \/\/ Write sorted results to output ports\n                for (int i = 0; i < N; ++i)\n                    out_arr[i].write(buf[i]);\n\n                \/\/ Signal done for one cycle\n                done.write(true);\n                wait();\n                done.write(false);\n            }\n        }\n    }\n};\n\nFew_shot_example_3:\n#include <systemc.h>\n\n\/\/ Module: MatrixAdder\n\/\/ Adds two 4×4 matrices of integers element-wise.\nSC_MODULE(MatrixAdder) {\n    sc_in<int> A[4*4];   \/\/ Flattened 4×4 input matrix A (16 elements)\n    sc_in<int> B[4*4];   \/\/ Flattened 4×4 input matrix B (16 elements)\n    sc_out<int> C[4*4];  \/\/ Flattened 4×4 output matrix C = A + B\n\n    \/\/ Constructor: registers a combinational add method sensitive to all inputs\n    SC_CTOR(MatrixAdder) {\n        SC_METHOD(do_add);\n        \/\/ Make the add method sensitive to every element of A and B\n        for (int i = 0; i < 4*4; i++) {\n            sensitive << A[i] << B[i];\n        }\n    }\n\n    \/\/ Method: reads A[i] and B[i], writes sum into C[i] for all 16 positions\n    void do_add() {\n        for (int i = 0; i < 4*4; i++) {\n            C[i].write(A[i].read() + B[i].read());\n        }\n    }\n};\n\n\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":65,
        "task":"SortanArray_SelectionSort",
        "code":"\/\/ C++ program for implementation of \n\/\/ selection sort \n#include <bits\/stdc++.h> \nusing namespace std; \n\n\/\/Swap function \nvoid swap(int *xp, int *yp) \n{ \n\tint temp = *xp; \n\t*xp = *yp; \n\t*yp = temp; \n} \n\nvoid selectionSort(int arr[], int n) \n{ \n\tint i, j, min_idx; \n\n\t\/\/ One by one move boundary of \n\t\/\/ unsorted subarray \n\tfor (i = 0; i < n-1; i++) \n\t{ \n\t\t\n\t\t\/\/ Find the minimum element in \n\t\t\/\/ unsorted array \n\t\tmin_idx = i; \n\t\tfor (j = i+1; j < n; j++) \n\t\tif (arr[j] < arr[min_idx]) \n\t\t\tmin_idx = j; \n\n\t\t\/\/ Swap the found minimum element \n\t\t\/\/ with the first element \n\t\tswap(&arr[min_idx], &arr[i]); \n\t} \n} \n\n\/\/Function to print an array \nvoid printArray(int arr[], int size) \n{ \n\tint i; \n\tfor (i=0; i < size; i++) \n\t\tcout << arr[i] << \" \"; \n\tcout << endl; \n} \n\n\/\/ Driver program to test above functions \nint main() \n{ \n\tint arr[] = {64, 25, 12, 22, 11}; \n\tint n = sizeof(arr)\/sizeof(arr[0]); \n\tselectionSort(arr, n); \n\tcout << \"Sorted array: \"; \n\tprintArray(arr, n); \n\treturn 0; \n} \n",
        "category":"Array Operation",
        "adoption":true,
        "reason":null,
        "module_name":"SelectionSort",
        "testbench":"SC_MODULE(Testbench) {\n    sc_clock        clk{\"clk\", 1, SC_NS};\n    sc_signal<bool> start, done;\n    sc_signal<int>  sig_in[5], sig_out[5];\n\n    SelectionSort*  dut;\n\n    SC_CTOR(Testbench) {\n        dut = new SelectionSort(\"SelectionSort\");\n        dut->clk(clk);\n        dut->start(start);\n        dut->done(done);\n        for (int i = 0; i < 5; ++i) {\n            dut->in_arr[i](sig_in[i]);\n            dut->out_arr[i](sig_out[i]);\n        }\n\n        SC_THREAD(run_tests);\n    }\n\n    void run_tests() {\n        int data[5]     = {64, 25, 12, 22, 11};\n        int expected[5] = {11, 12, 22, 25, 64};\n\n        \/*  驅動輸入  *\/\n        for (int i = 0; i < 5; ++i)\n            sig_in[i].write(data[i]);\n\n        \/*  觸發排序  *\/\n        wait(clk.posedge_event());\n        start.write(true);\n        wait(clk.posedge_event());\n        start.write(false);\n\n        \/*  等待 done  *\/\n        wait(done.posedge_event());\n\n        \/*  讀取結果並驗證  *\/\n        for (int i = 0; i < 5; ++i) {\n            int v = sig_out[i].read();\n            std::cout << \"Element \" << i << \" sorted value: \" << v << '\\n';\n            assert(v == expected[i]);\n        }\n        std::cout << \"All tests passed successfully.\\n\";\n        sc_stop();\n    }\n};\n\n\/\/─────────────────── sc_main ───────────────────\nint sc_main(int argc, char* argv[]) {\n    Testbench tb{\"tb\"};\n    sc_start();\n    return 0;\n}\n",
        "signal":"sc_in<bool>  clk;\nsc_in<bool>  start;\nsc_out<bool> done;\nsc_in<int>   in_arr[5];\nsc_out<int>  out_arr[5];",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input.\n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<bool>  clk;\nsc_in<bool>  start;\nsc_out<bool> done;\nsc_in<int>   in_arr[5];\nsc_out<int>  out_arr[5];\n> **Note**:\n   - Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n   - If the static const are provided, insure to write them in the SystemC code as well.\n\n**C++\/C Code**:\n```\n\/\/ C++ program for implementation of \n\/\/ selection sort \n#include <bits\/stdc++.h> \nusing namespace std; \n\n\/\/Swap function \nvoid swap(int *xp, int *yp) \n{ \n\tint temp = *xp; \n\t*xp = *yp; \n\t*yp = temp; \n} \n\nvoid selectionSort(int arr[], int n) \n{ \n\tint i, j, min_idx; \n\n\t\/\/ One by one move boundary of \n\t\/\/ unsorted subarray \n\tfor (i = 0; i < n-1; i++) \n\t{ \n\t\t\n\t\t\/\/ Find the minimum element in \n\t\t\/\/ unsorted array \n\t\tmin_idx = i; \n\t\tfor (j = i+1; j < n; j++) \n\t\tif (arr[j] < arr[min_idx]) \n\t\t\tmin_idx = j; \n\n\t\t\/\/ Swap the found minimum element \n\t\t\/\/ with the first element \n\t\tswap(&arr[min_idx], &arr[i]); \n\t} \n} \n\n\/\/Function to print an array \nvoid printArray(int arr[], int size) \n{ \n\tint i; \n\tfor (i=0; i < size; i++) \n\t\tcout << arr[i] << \" \"; \n\tcout << endl; \n} \n\n\/\/ Driver program to test above functions \nint main() \n{ \n\tint arr[] = {64, 25, 12, 22, 11}; \n\tint n = sizeof(arr)\/sizeof(arr[0]); \n\tselectionSort(arr, n); \n\tcout << \"Sorted array: \"; \n\tprintArray(arr, n); \n\treturn 0; \n} \n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\nFew_shot_example_1:\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        dont_initialize();\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n\nFew_shot_example_2:\n#include <systemc.h>\n\n\/\/ Module: BubbleSort\n\/\/ Sorts a small fixed-size array of integers using the bubble sort algorithm.\nSC_MODULE(BubbleSort) {\n    sc_in<bool>  clk;      \/\/ Clock signal\n    sc_in<bool>  start;    \/\/ Start signal to begin sorting\n    sc_out<bool> done;     \/\/ Signal asserted when sorting is complete\n\n    sc_in<int>   in_arr[4];  \/\/ Input array of 4 integers to be sorted\n    sc_out<int>  out_arr[4]; \/\/ Output array of 4 sorted integers\n\n    int buf[4];  \/\/ Internal buffer to hold array elements during sorting\n\n    \/\/ Constructor: registers the sorting process with the clock\n    SC_CTOR(BubbleSort) {\n        SC_THREAD(sort_proc);\n        sensitive << clk.pos();\n    }\n\n    \/\/ Thread: waits for start, performs bubble sort, writes results, toggles done\n    void sort_proc() {\n        const int N = 4;\n        while (true) {\n            wait();  \/\/ wait for next clock edge\n            if (start.read()) {\n                \/\/ Read inputs into internal buffer\n                for (int i = 0; i < N; ++i)\n                    buf[i] = in_arr[i].read();\n\n                \/\/ Perform bubble sort on buffer[]\n                for (int i = 0; i < N - 1; ++i)\n                    for (int j = 0; j < N - i - 1; ++j)\n                        if (buf[j] > buf[j + 1])\n                            std::swap(buf[j], buf[j + 1]);\n\n                \/\/ Write sorted results to output ports\n                for (int i = 0; i < N; ++i)\n                    out_arr[i].write(buf[i]);\n\n                \/\/ Signal done for one cycle\n                done.write(true);\n                wait();\n                done.write(false);\n            }\n        }\n    }\n};\n\nFew_shot_example_3:\n#include <systemc.h>\n\n\/\/ Module: MatrixAdder\n\/\/ Adds two 4×4 matrices of integers element-wise.\nSC_MODULE(MatrixAdder) {\n    sc_in<int> A[4*4];   \/\/ Flattened 4×4 input matrix A (16 elements)\n    sc_in<int> B[4*4];   \/\/ Flattened 4×4 input matrix B (16 elements)\n    sc_out<int> C[4*4];  \/\/ Flattened 4×4 output matrix C = A + B\n\n    \/\/ Constructor: registers a combinational add method sensitive to all inputs\n    SC_CTOR(MatrixAdder) {\n        SC_METHOD(do_add);\n        \/\/ Make the add method sensitive to every element of A and B\n        for (int i = 0; i < 4*4; i++) {\n            sensitive << A[i] << B[i];\n        }\n    }\n\n    \/\/ Method: reads A[i] and B[i], writes sum into C[i] for all 16 positions\n    void do_add() {\n        for (int i = 0; i < 4*4; i++) {\n            C[i].write(A[i].read() + B[i].read());\n        }\n    }\n};\n\n\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":66,
        "task":"Sortthe2DArrayAcrossRows",
        "code":"\/\/ C++ code to \n\/\/ sort 2D matrix row-wise\n#include<bits\/stdc++.h>\nusing namespace std;\n\n\/\/Swap function \nvoid swap(int *xp, int *yp) \n{ \n\tint temp = *xp; \n\t*xp = *yp; \n\t*yp = temp; \n} \nvoid sortRowWise(int m[][4],\n\t\t\t\tint r, int c)\n{\n\/\/ loop for rows of matrix\nfor (int i = 0; i < r; i++) \n{\n\t\/\/ loop for column of matrix\n\tfor (int j = 0; j < c; j++) \n\t{\n\t\/\/ loop for comparison and swapping\n\tfor (int k = 0; k < c - j - 1; k++) \n\t{\n\t\tif (m[i][k] > m[i][k + 1]) \n\t\t{\n\t\t\/\/ swapping of elements\n\t\tswap(m[i][k], m[i][k + 1]);\n\t\t}\n\t}\n\t}\n}\n\n\/\/ printing the sorted matrix\nfor (int i = 0; i < r; i++) \n{\n\tfor (int j = 0; j < c; j++)\n\tcout << m[i][j] << \" \";\n\tcout << endl;\n}\n}\n\n\/\/ Driver code\nint main()\n{\nint m[][4] = {{9, 8, 7, 1},\n\t\t\t\t{7, 3, 0, 2},\n\t\t\t\t{9, 5, 3, 2},\n\t\t\t\t{6, 3, 1, 2}};\nint c = sizeof(m[0]) \/ sizeof(m[0][0]);\nint r = sizeof(m) \/ sizeof(m[0]);\nsortRowWise(m, r, c);\nreturn 0;\n}\n\n\/\/ This code is contributed by Rutvik_56\n",
        "category":"Matrix Operation",
        "adoption":true,
        "reason":null,
        "module_name":"RowWiseSorter",
        "testbench":"SC_MODULE(Testbench)\n{\n    sc_clock        clk;\n    sc_signal<bool> start, done;\n\n    sc_signal<int> din [16];\n    sc_signal<int> dout[16];\n\n    RowWiseSorter* sorter;\n\n    SC_CTOR(Testbench)\n        : clk(\"clk\", 1, SC_NS)\n    {\n        sorter = new RowWiseSorter(\"RowWiseSorter\");\n        sorter->clk(clk);\n        sorter->start(start);\n        sorter->done(done);\n        for (int i = 0; i < 16; ++i) {\n            sorter->data_in [i](din [i]);\n            sorter->data_out[i](dout[i]);\n        }\n\n        SC_THREAD(run_tests);\n    }\n\n    void run_tests()\n    {\n        int matrix_in[4][4] = {\n            {9, 8, 7, 1},\n            {7, 3, 0, 2},\n            {9, 5, 3, 2},\n            {6, 3, 1, 2}\n        };\n        int expected[4][4] = {\n            {1, 7, 8, 9},\n            {0, 2, 3, 7},\n            {2, 3, 5, 9},\n            {1, 2, 3, 6}\n        };\n\n        \/\/ 輸入資料\n        for (int i = 0; i < 4; ++i)\n            for (int j = 0; j < 4; ++j)\n                din[i*4 + j].write(matrix_in[i][j]);\n\n        \/\/ 觸發排序\n        start.write(true);\n\n        \/\/ *** FIX ②：直接等待 done 的上升沿，不會 miss\n        wait(done.posedge_event());\n\n        start.write(false);  \/\/ 告知 sorter 已接收完成訊號\n\n        \/\/ 讀回並驗證\n        for (int i = 0; i < 4; ++i)\n            for (int j = 0; j < 4; ++j) {\n                int val = dout[i*4 + j].read();\n                assert(val == expected[i][j]);\n                std::cout << \"Row \" << i << \", Col \" << j\n                          << \" sorted value: \" << val << '\\n';\n            }\n\n        std::cout << \"All tests passed successfully.\\n\";\n        sc_stop();\n    }\n};\n\n\/\/--------------------------------------\n\/\/  sc_main\n\/\/--------------------------------------\nint sc_main(int argc, char* argv[])\n{\n    Testbench tb(\"tb\");\n    sc_start();\n    return 0;\n}\n",
        "signal":"sc_in<bool>  clk;\nsc_in<bool>  start;\nsc_out<bool> done;\nsc_in <int> data_in [16];\nsc_out<int> data_out[16];",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input.\n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<bool>  clk;\nsc_in<bool>  start;\nsc_out<bool> done;\nsc_in <int> data_in [16];\nsc_out<int> data_out[16];\n> **Note**:\n   - Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n   - If the static const are provided, insure to write them in the SystemC code as well.\n\n**C++\/C Code**:\n```\n\/\/ C++ code to \n\/\/ sort 2D matrix row-wise\n#include<bits\/stdc++.h>\nusing namespace std;\n\n\/\/Swap function \nvoid swap(int *xp, int *yp) \n{ \n\tint temp = *xp; \n\t*xp = *yp; \n\t*yp = temp; \n} \nvoid sortRowWise(int m[][4],\n\t\t\t\tint r, int c)\n{\n\/\/ loop for rows of matrix\nfor (int i = 0; i < r; i++) \n{\n\t\/\/ loop for column of matrix\n\tfor (int j = 0; j < c; j++) \n\t{\n\t\/\/ loop for comparison and swapping\n\tfor (int k = 0; k < c - j - 1; k++) \n\t{\n\t\tif (m[i][k] > m[i][k + 1]) \n\t\t{\n\t\t\/\/ swapping of elements\n\t\tswap(m[i][k], m[i][k + 1]);\n\t\t}\n\t}\n\t}\n}\n\n\/\/ printing the sorted matrix\nfor (int i = 0; i < r; i++) \n{\n\tfor (int j = 0; j < c; j++)\n\tcout << m[i][j] << \" \";\n\tcout << endl;\n}\n}\n\n\/\/ Driver code\nint main()\n{\nint m[][4] = {{9, 8, 7, 1},\n\t\t\t\t{7, 3, 0, 2},\n\t\t\t\t{9, 5, 3, 2},\n\t\t\t\t{6, 3, 1, 2}};\nint c = sizeof(m[0]) \/ sizeof(m[0][0]);\nint r = sizeof(m) \/ sizeof(m[0]);\nsortRowWise(m, r, c);\nreturn 0;\n}\n\n\/\/ This code is contributed by Rutvik_56\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\nFew_shot_example_1:\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        dont_initialize();\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n\nFew_shot_example_2:\n#include <systemc.h>\n\n\/\/ Module: BubbleSort\n\/\/ Sorts a small fixed-size array of integers using the bubble sort algorithm.\nSC_MODULE(BubbleSort) {\n    sc_in<bool>  clk;      \/\/ Clock signal\n    sc_in<bool>  start;    \/\/ Start signal to begin sorting\n    sc_out<bool> done;     \/\/ Signal asserted when sorting is complete\n\n    sc_in<int>   in_arr[4];  \/\/ Input array of 4 integers to be sorted\n    sc_out<int>  out_arr[4]; \/\/ Output array of 4 sorted integers\n\n    int buf[4];  \/\/ Internal buffer to hold array elements during sorting\n\n    \/\/ Constructor: registers the sorting process with the clock\n    SC_CTOR(BubbleSort) {\n        SC_THREAD(sort_proc);\n        sensitive << clk.pos();\n    }\n\n    \/\/ Thread: waits for start, performs bubble sort, writes results, toggles done\n    void sort_proc() {\n        const int N = 4;\n        while (true) {\n            wait();  \/\/ wait for next clock edge\n            if (start.read()) {\n                \/\/ Read inputs into internal buffer\n                for (int i = 0; i < N; ++i)\n                    buf[i] = in_arr[i].read();\n\n                \/\/ Perform bubble sort on buffer[]\n                for (int i = 0; i < N - 1; ++i)\n                    for (int j = 0; j < N - i - 1; ++j)\n                        if (buf[j] > buf[j + 1])\n                            std::swap(buf[j], buf[j + 1]);\n\n                \/\/ Write sorted results to output ports\n                for (int i = 0; i < N; ++i)\n                    out_arr[i].write(buf[i]);\n\n                \/\/ Signal done for one cycle\n                done.write(true);\n                wait();\n                done.write(false);\n            }\n        }\n    }\n};\n\nFew_shot_example_3:\n#include <systemc.h>\n\n\/\/ Module: MatrixAdder\n\/\/ Adds two 4×4 matrices of integers element-wise.\nSC_MODULE(MatrixAdder) {\n    sc_in<int> A[4*4];   \/\/ Flattened 4×4 input matrix A (16 elements)\n    sc_in<int> B[4*4];   \/\/ Flattened 4×4 input matrix B (16 elements)\n    sc_out<int> C[4*4];  \/\/ Flattened 4×4 output matrix C = A + B\n\n    \/\/ Constructor: registers a combinational add method sensitive to all inputs\n    SC_CTOR(MatrixAdder) {\n        SC_METHOD(do_add);\n        \/\/ Make the add method sensitive to every element of A and B\n        for (int i = 0; i < 4*4; i++) {\n            sensitive << A[i] << B[i];\n        }\n    }\n\n    \/\/ Method: reads A[i] and B[i], writes sum into C[i] for all 16 positions\n    void do_add() {\n        for (int i = 0; i < 4*4; i++) {\n            C[i].write(A[i].read() + B[i].read());\n        }\n    }\n};\n\n\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":67,
        "task":"SorttheElementsofanArrayinAscendingOrder",
        "code":"\/\/ C++ program to sort array \n\/\/ in ascending order using\n\/\/ Brute-force approach\n\/\/ using bubble sort\n#include <bits\/stdc++.h>\nusing namespace std;\n\nvoid sort(int num[], int len);\nvoid swapNums(int nums[], \n\t\t\tint first, int second);\n\n\/\/ Driver code\nint main()\n{\n\t\/\/ Initializing arrya\n\tint nums[] = {1, 12, 6, 8, 10};\n\tint size_nums = (sizeof(nums) \/ \n\t\t\t\t\tsizeof(nums[0]));\n\n\tcout << \"Before sorting the array is: \\n\";\n\tfor (int i = 0; i < size_nums; i++)\n\t\tcout << nums[i] << \" \";\n\tcout << \"\\n\\n\";\n\n\tsort(nums, size_nums);\n\n\tcout << \"After sorting the array is: \\n\";\n\n\tfor (int i = 0; i < size_nums; i++)\n\t\tcout << nums[i] << \" \";\n\tcout << \"\\n\";\n\treturn 0;\n}\n\n\/\/ Sort function\nvoid sort(int num[], int len)\n{\n\tbool isSwapped;\n\n\t\/**\n\t* Here we are running n-1 steps, \n\tfor each step, max item will \n\tcome at the last respective \n\tindex and swap element if the \n\telement is smaller than the \n\tprevious one.\n\t**\/\n\tfor (int i = 0; i < len; i++) \n\t{\n\t\tisSwapped = false;\n\t\tfor (int j = 1; j < len - i; j++) \n\t\t{\n\t\t\tif (num[j] < num[j - 1]) \n\t\t\t{\n\t\t\t\tswapNums(num, j, (j - 1));\n\t\t\t\tisSwapped = true;\n\t\t\t}\n\t\t}\n\t\tif (!isSwapped) \n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n\/\/ Swaps two numbers in array\nvoid swapNums(int nums[], \n\t\t\tint first, int second)\n{\n\tint curr = nums[first];\n\tnums[first] = nums[second];\n\tnums[second] = curr;\n}\n",
        "category":"Array Operation",
        "adoption":true,
        "reason":null,
        "module_name":"BubbleSort",
        "testbench":"SC_MODULE(Testbench) {\n    sc_clock        clk{\"clk\", 1, SC_NS};\n    sc_signal<bool> start, done;\n    sc_signal<int>  sig_in[5], sig_out[5];\n\n    BubbleSort*     dut;\n\n    SC_CTOR(Testbench) {\n        \/\/ 建立 DUT 並連線\n        dut = new BubbleSort(\"BubbleSort\");\n        dut->clk(clk);\n        dut->start(start);\n        dut->done(done);\n        for (int i = 0; i < 5; ++i) {\n            dut->in_arr[i](sig_in[i]);\n            dut->out_arr[i](sig_out[i]);\n        }\n\n        SC_THREAD(run_tests);             \/\/ thread 一開始即執行\n    }\n\n    void run_tests() {\n        int data[5]     = {1, 12, 6, 8, 10};\n        int expected[5] = {1, 6, 8, 10, 12};\n\n        \/* ▸ 驅動輸入 *\/\n        std::cout << \"Before sorting: \";\n        for (int i = 0; i < 5; ++i) {\n            sig_in[i].write(data[i]);\n            std::cout << data[i] << \" \";\n        }\n        std::cout << std::endl;\n\n        \/* ▸ 觸發排序 *\/\n        wait(clk.posedge_event());\n        start.write(true);\n        wait(clk.posedge_event());\n        start.write(false);\n\n        \/* ▸ 等待 done=1 *\/\n        wait(done.posedge_event());\n\n        \/* ▸ 讀取結果並驗證 *\/\n        std::cout << \"After sorting:  \";\n        for (int i = 0; i < 5; ++i) {\n            int v = sig_out[i].read();\n            std::cout << v << \" \";\n            assert(v == expected[i]);\n        }\n        std::cout << \"\\nAll tests passed successfully.\\n\";\n\n        sc_stop();\n    }\n};\n\n\/\/ ───────────────────── sc_main ─────────────────────\nint sc_main(int argc, char* argv[]) {\n    Testbench tb{\"tb\"};\n    sc_start();\n    return 0;\n}\n",
        "signal":"sc_in<bool>  clk;\nsc_in<bool>  start;\nsc_out<bool> done;\nsc_in<int>   in_arr[5];\nsc_out<int>  out_arr[5];",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input.\n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<bool>  clk;\nsc_in<bool>  start;\nsc_out<bool> done;\nsc_in<int>   in_arr[5];\nsc_out<int>  out_arr[5];\n> **Note**:\n   - Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n   - If the static const are provided, insure to write them in the SystemC code as well.\n\n**C++\/C Code**:\n```\n\/\/ C++ program to sort array \n\/\/ in ascending order using\n\/\/ Brute-force approach\n\/\/ using bubble sort\n#include <bits\/stdc++.h>\nusing namespace std;\n\nvoid sort(int num[], int len);\nvoid swapNums(int nums[], \n\t\t\tint first, int second);\n\n\/\/ Driver code\nint main()\n{\n\t\/\/ Initializing arrya\n\tint nums[] = {1, 12, 6, 8, 10};\n\tint size_nums = (sizeof(nums) \/ \n\t\t\t\t\tsizeof(nums[0]));\n\n\tcout << \"Before sorting the array is: \\n\";\n\tfor (int i = 0; i < size_nums; i++)\n\t\tcout << nums[i] << \" \";\n\tcout << \"\\n\\n\";\n\n\tsort(nums, size_nums);\n\n\tcout << \"After sorting the array is: \\n\";\n\n\tfor (int i = 0; i < size_nums; i++)\n\t\tcout << nums[i] << \" \";\n\tcout << \"\\n\";\n\treturn 0;\n}\n\n\/\/ Sort function\nvoid sort(int num[], int len)\n{\n\tbool isSwapped;\n\n\t\/**\n\t* Here we are running n-1 steps, \n\tfor each step, max item will \n\tcome at the last respective \n\tindex and swap element if the \n\telement is smaller than the \n\tprevious one.\n\t**\/\n\tfor (int i = 0; i < len; i++) \n\t{\n\t\tisSwapped = false;\n\t\tfor (int j = 1; j < len - i; j++) \n\t\t{\n\t\t\tif (num[j] < num[j - 1]) \n\t\t\t{\n\t\t\t\tswapNums(num, j, (j - 1));\n\t\t\t\tisSwapped = true;\n\t\t\t}\n\t\t}\n\t\tif (!isSwapped) \n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n\/\/ Swaps two numbers in array\nvoid swapNums(int nums[], \n\t\t\tint first, int second)\n{\n\tint curr = nums[first];\n\tnums[first] = nums[second];\n\tnums[second] = curr;\n}\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\nFew_shot_example_1:\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        dont_initialize();\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n\nFew_shot_example_2:\n#include <systemc.h>\n\n\/\/ Module: BubbleSort\n\/\/ Sorts a small fixed-size array of integers using the bubble sort algorithm.\nSC_MODULE(BubbleSort) {\n    sc_in<bool>  clk;      \/\/ Clock signal\n    sc_in<bool>  start;    \/\/ Start signal to begin sorting\n    sc_out<bool> done;     \/\/ Signal asserted when sorting is complete\n\n    sc_in<int>   in_arr[4];  \/\/ Input array of 4 integers to be sorted\n    sc_out<int>  out_arr[4]; \/\/ Output array of 4 sorted integers\n\n    int buf[4];  \/\/ Internal buffer to hold array elements during sorting\n\n    \/\/ Constructor: registers the sorting process with the clock\n    SC_CTOR(BubbleSort) {\n        SC_THREAD(sort_proc);\n        sensitive << clk.pos();\n    }\n\n    \/\/ Thread: waits for start, performs bubble sort, writes results, toggles done\n    void sort_proc() {\n        const int N = 4;\n        while (true) {\n            wait();  \/\/ wait for next clock edge\n            if (start.read()) {\n                \/\/ Read inputs into internal buffer\n                for (int i = 0; i < N; ++i)\n                    buf[i] = in_arr[i].read();\n\n                \/\/ Perform bubble sort on buffer[]\n                for (int i = 0; i < N - 1; ++i)\n                    for (int j = 0; j < N - i - 1; ++j)\n                        if (buf[j] > buf[j + 1])\n                            std::swap(buf[j], buf[j + 1]);\n\n                \/\/ Write sorted results to output ports\n                for (int i = 0; i < N; ++i)\n                    out_arr[i].write(buf[i]);\n\n                \/\/ Signal done for one cycle\n                done.write(true);\n                wait();\n                done.write(false);\n            }\n        }\n    }\n};\n\nFew_shot_example_3:\n#include <systemc.h>\n\n\/\/ Module: MatrixAdder\n\/\/ Adds two 4×4 matrices of integers element-wise.\nSC_MODULE(MatrixAdder) {\n    sc_in<int> A[4*4];   \/\/ Flattened 4×4 input matrix A (16 elements)\n    sc_in<int> B[4*4];   \/\/ Flattened 4×4 input matrix B (16 elements)\n    sc_out<int> C[4*4];  \/\/ Flattened 4×4 output matrix C = A + B\n\n    \/\/ Constructor: registers a combinational add method sensitive to all inputs\n    SC_CTOR(MatrixAdder) {\n        SC_METHOD(do_add);\n        \/\/ Make the add method sensitive to every element of A and B\n        for (int i = 0; i < 4*4; i++) {\n            sensitive << A[i] << B[i];\n        }\n    }\n\n    \/\/ Method: reads A[i] and B[i], writes sum into C[i] for all 16 positions\n    void do_add() {\n        for (int i = 0; i < 4*4; i++) {\n            C[i].write(A[i].read() + B[i].read());\n        }\n    }\n};\n\n\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":68,
        "task":"SorttheElementsofanArrayinDescendingOrder",
        "code":"\/\/ C++ program to sort array \n\/\/ in ascending order using\n\/\/ Brute-force approach\n\/\/ using bubble sort\n#include <bits\/stdc++.h>\nusing namespace std;\n\nvoid sort(int num[], int len);\nvoid swapNums(int nums[], \n\t\t\tint first, int second);\n\n\/\/ Driver code\nint main()\n{\n\t\/\/ Initializing arrya\n\tint nums[] = {1, 12, 6, 8, 10};\n\tint size_nums = (sizeof(nums) \/ \n\t\t\t\t\tsizeof(nums[0]));\n\n\tcout << \"Before sorting the array is: \\n\";\n\tfor (int i = 0; i < size_nums; i++)\n\t\tcout << nums[i] << \" \";\n\tcout << \"\\n\\n\";\n\n\tsort(nums, size_nums);\n\n\tcout << \"After sorting the array is: \\n\";\n\n\tfor (int i = 0; i < size_nums; i++)\n\t\tcout << nums[i] << \" \";\n\tcout << \"\\n\";\n\treturn 0;\n}\n\n\/\/ Sort function\nvoid sort(int num[], int len)\n{\n\tbool isSwapped;\n\n\t\/**\n\t* Here we are running n-1 steps, \n\tfor each step, max item will \n\tcome at the last respective \n\tindex and swap element if the \n\telement is smaller than the \n\tprevious one.\n\t**\/\n\tfor (int i = 0; i < len; i++) \n\t{\n\t\tisSwapped = false;\n\t\tfor (int j = 1; j < len - i; j++) \n\t\t{\n\t\t\tif (num[j] < num[j - 1]) \n\t\t\t{\n\t\t\t\tswapNums(num, j, (j - 1));\n\t\t\t\tisSwapped = true;\n\t\t\t}\n\t\t}\n\t\tif (!isSwapped) \n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n\/\/ Swaps two numbers in array\nvoid swapNums(int nums[], \n\t\t\tint first, int second)\n{\n\tint curr = nums[first];\n\tnums[first] = nums[second];\n\tnums[second] = curr;\n}\n",
        "category":"Array Operation",
        "adoption":true,
        "reason":null,
        "module_name":"BubbleSort",
        "testbench":"SC_MODULE(Testbench) {\n    sc_clock        clk{\"clk\", 1, SC_NS};\n    sc_signal<bool> start, done;\n    sc_signal<int>  sig_in[5], sig_out[5];\n\n    BubbleSort*     dut;\n\n    SC_CTOR(Testbench) {\n        dut = new BubbleSort(\"BubbleSort\");\n        dut->clk(clk);\n        dut->start(start);\n        dut->done(done);\n        for (int i = 0; i < 5; ++i) {\n            dut->in_arr[i](sig_in[i]);\n            dut->out_arr[i](sig_out[i]);\n        }\n\n        SC_THREAD(run_tests);   \/\/ thread 在模擬一開始執行\n    }\n\n    void run_tests() {\n        int data[5]     = {1, 12, 6, 8, 10};\n        int expected[5] = {1, 6, 8, 10, 12};\n\n        \/* ▸ 驅動輸入 *\/\n        for (int i = 0; i < 5; ++i)\n            sig_in[i].write(data[i]);\n\n        \/* ▸ 觸發排序 *\/\n        wait(clk.posedge_event());\n        start.write(true);\n        wait(clk.posedge_event());\n        start.write(false);\n\n        \/* ▸ 等待 done=1 *\/\n        wait(done.posedge_event());\n\n        \/* ▸ 讀取結果並驗證 *\/\n        std::cout << \"Sorted result: \";\n        for (int i = 0; i < 5; ++i) {\n            int v = sig_out[i].read();\n            std::cout << v << \" \";\n            assert(v == expected[i]);\n        }\n        std::cout << \"\\nAll tests passed successfully.\\n\";\n\n        sc_stop();\n    }\n};\n\n\/\/ ──────────────── sc_main ────────────────\nint sc_main(int argc, char* argv[]) {\n    Testbench tb{\"tb\"};\n    sc_start();\n    return 0;\n}\n",
        "signal":"sc_in<bool>  clk;\nsc_in<bool>  start;\nsc_out<bool> done;\nsc_in<int>   in_arr[5];\nsc_out<int>  out_arr[5];",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input.\n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<bool>  clk;\nsc_in<bool>  start;\nsc_out<bool> done;\nsc_in<int>   in_arr[5];\nsc_out<int>  out_arr[5];\n> **Note**:\n   - Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n   - If the static const are provided, insure to write them in the SystemC code as well.\n\n**C++\/C Code**:\n```\n\/\/ C++ program to sort array \n\/\/ in ascending order using\n\/\/ Brute-force approach\n\/\/ using bubble sort\n#include <bits\/stdc++.h>\nusing namespace std;\n\nvoid sort(int num[], int len);\nvoid swapNums(int nums[], \n\t\t\tint first, int second);\n\n\/\/ Driver code\nint main()\n{\n\t\/\/ Initializing arrya\n\tint nums[] = {1, 12, 6, 8, 10};\n\tint size_nums = (sizeof(nums) \/ \n\t\t\t\t\tsizeof(nums[0]));\n\n\tcout << \"Before sorting the array is: \\n\";\n\tfor (int i = 0; i < size_nums; i++)\n\t\tcout << nums[i] << \" \";\n\tcout << \"\\n\\n\";\n\n\tsort(nums, size_nums);\n\n\tcout << \"After sorting the array is: \\n\";\n\n\tfor (int i = 0; i < size_nums; i++)\n\t\tcout << nums[i] << \" \";\n\tcout << \"\\n\";\n\treturn 0;\n}\n\n\/\/ Sort function\nvoid sort(int num[], int len)\n{\n\tbool isSwapped;\n\n\t\/**\n\t* Here we are running n-1 steps, \n\tfor each step, max item will \n\tcome at the last respective \n\tindex and swap element if the \n\telement is smaller than the \n\tprevious one.\n\t**\/\n\tfor (int i = 0; i < len; i++) \n\t{\n\t\tisSwapped = false;\n\t\tfor (int j = 1; j < len - i; j++) \n\t\t{\n\t\t\tif (num[j] < num[j - 1]) \n\t\t\t{\n\t\t\t\tswapNums(num, j, (j - 1));\n\t\t\t\tisSwapped = true;\n\t\t\t}\n\t\t}\n\t\tif (!isSwapped) \n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n\/\/ Swaps two numbers in array\nvoid swapNums(int nums[], \n\t\t\tint first, int second)\n{\n\tint curr = nums[first];\n\tnums[first] = nums[second];\n\tnums[second] = curr;\n}\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\nFew_shot_example_1:\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        dont_initialize();\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n\nFew_shot_example_2:\n#include <systemc.h>\n\n\/\/ Module: BubbleSort\n\/\/ Sorts a small fixed-size array of integers using the bubble sort algorithm.\nSC_MODULE(BubbleSort) {\n    sc_in<bool>  clk;      \/\/ Clock signal\n    sc_in<bool>  start;    \/\/ Start signal to begin sorting\n    sc_out<bool> done;     \/\/ Signal asserted when sorting is complete\n\n    sc_in<int>   in_arr[4];  \/\/ Input array of 4 integers to be sorted\n    sc_out<int>  out_arr[4]; \/\/ Output array of 4 sorted integers\n\n    int buf[4];  \/\/ Internal buffer to hold array elements during sorting\n\n    \/\/ Constructor: registers the sorting process with the clock\n    SC_CTOR(BubbleSort) {\n        SC_THREAD(sort_proc);\n        sensitive << clk.pos();\n    }\n\n    \/\/ Thread: waits for start, performs bubble sort, writes results, toggles done\n    void sort_proc() {\n        const int N = 4;\n        while (true) {\n            wait();  \/\/ wait for next clock edge\n            if (start.read()) {\n                \/\/ Read inputs into internal buffer\n                for (int i = 0; i < N; ++i)\n                    buf[i] = in_arr[i].read();\n\n                \/\/ Perform bubble sort on buffer[]\n                for (int i = 0; i < N - 1; ++i)\n                    for (int j = 0; j < N - i - 1; ++j)\n                        if (buf[j] > buf[j + 1])\n                            std::swap(buf[j], buf[j + 1]);\n\n                \/\/ Write sorted results to output ports\n                for (int i = 0; i < N; ++i)\n                    out_arr[i].write(buf[i]);\n\n                \/\/ Signal done for one cycle\n                done.write(true);\n                wait();\n                done.write(false);\n            }\n        }\n    }\n};\n\nFew_shot_example_3:\n#include <systemc.h>\n\n\/\/ Module: MatrixAdder\n\/\/ Adds two 4×4 matrices of integers element-wise.\nSC_MODULE(MatrixAdder) {\n    sc_in<int> A[4*4];   \/\/ Flattened 4×4 input matrix A (16 elements)\n    sc_in<int> B[4*4];   \/\/ Flattened 4×4 input matrix B (16 elements)\n    sc_out<int> C[4*4];  \/\/ Flattened 4×4 output matrix C = A + B\n\n    \/\/ Constructor: registers a combinational add method sensitive to all inputs\n    SC_CTOR(MatrixAdder) {\n        SC_METHOD(do_add);\n        \/\/ Make the add method sensitive to every element of A and B\n        for (int i = 0; i < 4*4; i++) {\n            sensitive << A[i] << B[i];\n        }\n    }\n\n    \/\/ Method: reads A[i] and B[i], writes sum into C[i] for all 16 positions\n    void do_add() {\n        for (int i = 0; i < 4*4; i++) {\n            C[i].write(A[i].read() + B[i].read());\n        }\n    }\n};\n\n\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":69,
        "task":"SumofFibonacciNumbersatEvenIndexesuptoNTerms",
        "code":"\/\/ C++ Program to find sum of \n\/\/ even-indiced Fibonacci numbers\n#include <bits\/stdc++.h>\nusing namespace std;\n\n\/\/ Computes value of first \n\/\/ fibonacci numbers and \n\/\/ stores the even-indexed sum\nint calculateEvenSum(int n)\n{\n\tif (n <= 0)\n\t\treturn 0;\n\n\tint fibo[2 * n + 1];\n\tfibo[0] = 0, fibo[1] = 1;\n\n\t\/\/ Initialize result\n\tint sum = 0;\n\n\t\/\/ Add remaining terms\n\tfor (int i = 2; i <= 2 * n; i++) \n\t{\n\t\tfibo[i] = fibo[i - 1] + fibo[i - 2];\n\n\t\t\/\/ For even indices\n\t\tif (i % 2 == 0)\n\t\t\tsum += fibo[i];\n\t}\n\n\t\/\/ Return the alternating sum\n\treturn sum;\n}\n\n\/\/ Driver code\nint main()\n{\n\n\t\/\/ Get n\n\tint n = 8;\n\n\t\/\/ Find the even-indiced sum\n\tcout << \"Even indexed Fibonacci Sum upto \" << \n\t\t\tn << \" terms: \" << calculateEvenSum(n) << \n\t\t\tendl;\n\n\treturn 0;\n}\n",
        "category":"Basic Math",
        "adoption":true,
        "reason":null,
        "module_name":"FibonacciSumCalculator",
        "testbench":"SC_MODULE(Testbench) {\n    sc_signal<int> n_sig; \/\/ Signal for the number of terms\n    sc_signal<int> sum_sig; \/\/ Signal for the sum of even-indexed Fibonacci numbers\n\n    \/\/ Instance of the FibonacciSumCalculator module\n    FibonacciSumCalculator fib_sum_calc_inst;\n\n    \/\/ Constructor\n    SC_CTOR(Testbench)\n    : fib_sum_calc_inst(\"fib_sum_calc_inst\") {\n        \/\/ Connect signals to module ports\n        fib_sum_calc_inst.n(n_sig);\n        fib_sum_calc_inst.sum(sum_sig);\n\n        \/\/ Create a test thread to provide stimulus and check the result\n        SC_THREAD(run_tests);\n    }\n\n    \/\/ Thread to run test cases\n    void run_tests() {\n        \/\/ Test case: n = 8 (expected sum = 44)\n        n_sig.write(8);\n        wait(1, SC_NS); \/\/ Wait for the process to update\n        int result = sum_sig.read();\n        std::cout << \"Even indexed Fibonacci Sum upto \" << n_sig.read() << \" terms: \" << result << std::endl;\n        assert(result == 1596);\n\n        \/\/ Additional test case: n = 5 (expected sum = 10)\n        n_sig.write(5);\n        wait(1, SC_NS);\n        result = sum_sig.read();\n        std::cout << \"Even indexed Fibonacci Sum upto \" << n_sig.read() << \" terms: \" << result << std::endl;\n        assert(result == 88);\n\n        \/\/ End simulation after successful tests\n        std::cout << \"All tests passed successfully.\" << std::endl;\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); \/\/ Instantiate the testbench module\n    sc_start();         \/\/ Start the simulation\n    return 0;\n}\n",
        "signal":"sc_in<int> n;\nsc_out<int> sum;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input.\n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<int> n;\nsc_out<int> sum;\n> **Note**:\n   - Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n   - If the static const are provided, insure to write them in the SystemC code as well.\n\n**C++\/C Code**:\n```\n\/\/ C++ Program to find sum of \n\/\/ even-indiced Fibonacci numbers\n#include <bits\/stdc++.h>\nusing namespace std;\n\n\/\/ Computes value of first \n\/\/ fibonacci numbers and \n\/\/ stores the even-indexed sum\nint calculateEvenSum(int n)\n{\n\tif (n <= 0)\n\t\treturn 0;\n\n\tint fibo[2 * n + 1];\n\tfibo[0] = 0, fibo[1] = 1;\n\n\t\/\/ Initialize result\n\tint sum = 0;\n\n\t\/\/ Add remaining terms\n\tfor (int i = 2; i <= 2 * n; i++) \n\t{\n\t\tfibo[i] = fibo[i - 1] + fibo[i - 2];\n\n\t\t\/\/ For even indices\n\t\tif (i % 2 == 0)\n\t\t\tsum += fibo[i];\n\t}\n\n\t\/\/ Return the alternating sum\n\treturn sum;\n}\n\n\/\/ Driver code\nint main()\n{\n\n\t\/\/ Get n\n\tint n = 8;\n\n\t\/\/ Find the even-indiced sum\n\tcout << \"Even indexed Fibonacci Sum upto \" << \n\t\t\tn << \" terms: \" << calculateEvenSum(n) << \n\t\t\tendl;\n\n\treturn 0;\n}\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\nFew_shot_example_1:\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        dont_initialize();\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n\nFew_shot_example_2:\n#include <systemc.h>\n\n\/\/ Module: BubbleSort\n\/\/ Sorts a small fixed-size array of integers using the bubble sort algorithm.\nSC_MODULE(BubbleSort) {\n    sc_in<bool>  clk;      \/\/ Clock signal\n    sc_in<bool>  start;    \/\/ Start signal to begin sorting\n    sc_out<bool> done;     \/\/ Signal asserted when sorting is complete\n\n    sc_in<int>   in_arr[4];  \/\/ Input array of 4 integers to be sorted\n    sc_out<int>  out_arr[4]; \/\/ Output array of 4 sorted integers\n\n    int buf[4];  \/\/ Internal buffer to hold array elements during sorting\n\n    \/\/ Constructor: registers the sorting process with the clock\n    SC_CTOR(BubbleSort) {\n        SC_THREAD(sort_proc);\n        sensitive << clk.pos();\n    }\n\n    \/\/ Thread: waits for start, performs bubble sort, writes results, toggles done\n    void sort_proc() {\n        const int N = 4;\n        while (true) {\n            wait();  \/\/ wait for next clock edge\n            if (start.read()) {\n                \/\/ Read inputs into internal buffer\n                for (int i = 0; i < N; ++i)\n                    buf[i] = in_arr[i].read();\n\n                \/\/ Perform bubble sort on buffer[]\n                for (int i = 0; i < N - 1; ++i)\n                    for (int j = 0; j < N - i - 1; ++j)\n                        if (buf[j] > buf[j + 1])\n                            std::swap(buf[j], buf[j + 1]);\n\n                \/\/ Write sorted results to output ports\n                for (int i = 0; i < N; ++i)\n                    out_arr[i].write(buf[i]);\n\n                \/\/ Signal done for one cycle\n                done.write(true);\n                wait();\n                done.write(false);\n            }\n        }\n    }\n};\n\nFew_shot_example_3:\n#include <systemc.h>\n\n\/\/ Module: MatrixAdder\n\/\/ Adds two 4×4 matrices of integers element-wise.\nSC_MODULE(MatrixAdder) {\n    sc_in<int> A[4*4];   \/\/ Flattened 4×4 input matrix A (16 elements)\n    sc_in<int> B[4*4];   \/\/ Flattened 4×4 input matrix B (16 elements)\n    sc_out<int> C[4*4];  \/\/ Flattened 4×4 output matrix C = A + B\n\n    \/\/ Constructor: registers a combinational add method sensitive to all inputs\n    SC_CTOR(MatrixAdder) {\n        SC_METHOD(do_add);\n        \/\/ Make the add method sensitive to every element of A and B\n        for (int i = 0; i < 4*4; i++) {\n            sensitive << A[i] << B[i];\n        }\n    }\n\n    \/\/ Method: reads A[i] and B[i], writes sum into C[i] for all 16 positions\n    void do_add() {\n        for (int i = 0; i < 4*4; i++) {\n            C[i].write(A[i].read() + B[i].read());\n        }\n    }\n};\n\n\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":70,
        "task":"Swaptwonumbers",
        "code":"\/\/ C++ program to swap two\n\/\/ numbers using 3rd variable\n#include <bits\/stdc++.h>\nusing namespace std;\n\n\/\/ Driver code\nint main()\n{\n    int a = 2, b = 3;\n\n    cout << \"Before swapping a = \" << a << \" , b = \" << b\n         << endl;\n\n    \/\/ temporary variable\n    int temp;\n\n    \/\/ appying swapping algorithm\n    temp = a;\n    a = b;\n    b = temp;\n    cout << \"After swapping a = \" << a << \" , b = \" << b\n         << endl;\n\n    return 0;\n}\n",
        "category":"Basic Math",
        "adoption":true,
        "reason":null,
        "module_name":"Swapper",
        "testbench":"SC_MODULE(Testbench) {\n    sc_signal<int> a;      \/\/ Signal for the first number.\n    sc_signal<int> b;      \/\/ Signal for the second number.\n    sc_signal<int> out_a;  \/\/ Signal for the swapped output of a.\n    sc_signal<int> out_b;  \/\/ Signal for the swapped output of b.\n\n    Swapper swapper_inst;  \/\/ Instance of the Swapper module.\n\n    SC_CTOR(Testbench) : swapper_inst(\"swapper_inst\") {\n        \/\/ Connect the signals to the Swapper module ports.\n        swapper_inst.a(a);\n        swapper_inst.b(b);\n        swapper_inst.out_a(out_a);\n        swapper_inst.out_b(out_b);\n\n        \/\/ Create a thread to run test cases.\n        SC_THREAD(run_tests);\n    }\n\n    void run_tests() {\n        \/\/ Set initial values (equivalent to a = 2, b = 3 in the C++ code).\n        a.write(2);\n        b.write(3);\n        wait(1, SC_NS); \/\/ Allow time for the Swapper module to process the inputs.\n\n        \/\/ Assert that the swap operation has been performed correctly.\n        assert(out_a.read() == 3); \/\/ After swapping, out_a should be 3.\n        assert(out_b.read() == 2); \/\/ After swapping, out_b should be 2.\n\n        \/\/ Print the values before and after the swap.\n        cout << \"Before swapping a = \" << a.read() << \" , b = \" << b.read() << endl;\n        cout << \"After swapping a = \" << out_a.read() << \" , b = \" << out_b.read() << endl;\n        cout << \"All tests passed successfully.\" << endl;\n\n        sc_stop(); \/\/ Stop the simulation.\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); \/\/ Instantiate the Testbench.\n    sc_start();         \/\/ Start the simulation.\n    return 0;\n}\n",
        "signal":"sc_in<int> a;\nsc_in<int> b;\nsc_out<int> out_a;\nsc_out<int> out_b;",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input.\n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<int> a;\nsc_in<int> b;\nsc_out<int> out_a;\nsc_out<int> out_b;\n> **Note**:\n   - Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n   - If the static const are provided, insure to write them in the SystemC code as well.\n\n**C++\/C Code**:\n```\n\/\/ C++ program to swap two\n\/\/ numbers using 3rd variable\n#include <bits\/stdc++.h>\nusing namespace std;\n\n\/\/ Driver code\nint main()\n{\n    int a = 2, b = 3;\n\n    cout << \"Before swapping a = \" << a << \" , b = \" << b\n         << endl;\n\n    \/\/ temporary variable\n    int temp;\n\n    \/\/ appying swapping algorithm\n    temp = a;\n    a = b;\n    b = temp;\n    cout << \"After swapping a = \" << a << \" , b = \" << b\n         << endl;\n\n    return 0;\n}\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\nFew_shot_example_1:\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        dont_initialize();\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n\nFew_shot_example_2:\n#include <systemc.h>\n\n\/\/ Module: BubbleSort\n\/\/ Sorts a small fixed-size array of integers using the bubble sort algorithm.\nSC_MODULE(BubbleSort) {\n    sc_in<bool>  clk;      \/\/ Clock signal\n    sc_in<bool>  start;    \/\/ Start signal to begin sorting\n    sc_out<bool> done;     \/\/ Signal asserted when sorting is complete\n\n    sc_in<int>   in_arr[4];  \/\/ Input array of 4 integers to be sorted\n    sc_out<int>  out_arr[4]; \/\/ Output array of 4 sorted integers\n\n    int buf[4];  \/\/ Internal buffer to hold array elements during sorting\n\n    \/\/ Constructor: registers the sorting process with the clock\n    SC_CTOR(BubbleSort) {\n        SC_THREAD(sort_proc);\n        sensitive << clk.pos();\n    }\n\n    \/\/ Thread: waits for start, performs bubble sort, writes results, toggles done\n    void sort_proc() {\n        const int N = 4;\n        while (true) {\n            wait();  \/\/ wait for next clock edge\n            if (start.read()) {\n                \/\/ Read inputs into internal buffer\n                for (int i = 0; i < N; ++i)\n                    buf[i] = in_arr[i].read();\n\n                \/\/ Perform bubble sort on buffer[]\n                for (int i = 0; i < N - 1; ++i)\n                    for (int j = 0; j < N - i - 1; ++j)\n                        if (buf[j] > buf[j + 1])\n                            std::swap(buf[j], buf[j + 1]);\n\n                \/\/ Write sorted results to output ports\n                for (int i = 0; i < N; ++i)\n                    out_arr[i].write(buf[i]);\n\n                \/\/ Signal done for one cycle\n                done.write(true);\n                wait();\n                done.write(false);\n            }\n        }\n    }\n};\n\nFew_shot_example_3:\n#include <systemc.h>\n\n\/\/ Module: MatrixAdder\n\/\/ Adds two 4×4 matrices of integers element-wise.\nSC_MODULE(MatrixAdder) {\n    sc_in<int> A[4*4];   \/\/ Flattened 4×4 input matrix A (16 elements)\n    sc_in<int> B[4*4];   \/\/ Flattened 4×4 input matrix B (16 elements)\n    sc_out<int> C[4*4];  \/\/ Flattened 4×4 output matrix C = A + B\n\n    \/\/ Constructor: registers a combinational add method sensitive to all inputs\n    SC_CTOR(MatrixAdder) {\n        SC_METHOD(do_add);\n        \/\/ Make the add method sensitive to every element of A and B\n        for (int i = 0; i < 4*4; i++) {\n            sensitive << A[i] << B[i];\n        }\n    }\n\n    \/\/ Method: reads A[i] and B[i], writes sum into C[i] for all 16 positions\n    void do_add() {\n        for (int i = 0; i < 4*4; i++) {\n            C[i].write(A[i].read() + B[i].read());\n        }\n    }\n};\n\n\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    },
    {
        "task_id":71,
        "task":"MergeSort",
        "code":"\/\/ C++ program for the implementation of merge sort\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n\/\/ Merges two subarrays of vec.\n\/\/ First subarray is vec[left..mid]\n\/\/ Second subarray is vec[mid+1..right]\nvoid merge(vector<int>& vec, int left, int mid, int right) {\n    int i, j, k;\n    int n1 = mid - left + 1;\n    int n2 = right - mid;\n\n    \/\/ Create temporary vectors\n    vector<int> leftVec(n1), rightVec(n2);\n\n    \/\/ Copy data to temporary vectors\n    for (i = 0; i < n1; i++)\n        leftVec[i] = vec[left + i];\n    for (j = 0; j < n2; j++)\n        rightVec[j] = vec[mid + 1 + j];\n\n    \/\/ Merge the temporary vectors back into vec[left..right]\n    i = 0;\n    j = 0;\n    k = left;\n    while (i < n1 && j < n2) {\n        if (leftVec[i] <= rightVec[j]) {\n            vec[k] = leftVec[i];\n            i++;\n        } else {\n            vec[k] = rightVec[j];\n            j++;\n        }\n        k++;\n    }\n\n    \/\/ Copy the remaining elements of leftVec[], if any\n    while (i < n1) {\n        vec[k] = leftVec[i];\n        i++;\n        k++;\n    }\n\n    \/\/ Copy the remaining elements of rightVec[], if any\n    while (j < n2) {\n        vec[k] = rightVec[j];\n        j++;\n        k++;\n    }\n}\n\n\/\/ The subarray to be sorted is in the index range [left..right]\nvoid mergeSort(vector<int>& vec, int left, int right) {\n    if (left < right) {\n      \n        \/\/ Calculate the midpoint\n        int mid = left + (right - left) \/ 2;\n\n        \/\/ Sort first and second halves\n        mergeSort(vec, left, mid);\n        mergeSort(vec, mid + 1, right);\n\n        \/\/ Merge the sorted halves\n        merge(vec, left, mid, right);\n    }\n}\n\nint main() {\n    vector<int> vec = {12, 11, 13, 5, 6, 7};\n    int n = vec.size();\n\n    \/\/ Sorting vec using mergesort\n    mergeSort(vec, 0, n - 1);\n\n    for (auto i: vec)\n        cout << i << \" \";\n    return 0;\n}\n",
        "category":"Array Operation",
        "adoption":true,
        "reason":null,
        "module_name":"MergeSort",
        "testbench":"SC_MODULE(Testbench) {\n    sc_clock clk{\"clk\", 1, SC_NS};\n    sc_signal<bool> start, done;\n    sc_signal<int> sig_in[6], sig_out[6];\n\n    MergeSort* dut;\n\n    SC_CTOR(Testbench) {\n        dut = new MergeSort(\"MergeSort\");\n        dut->clk(clk);\n        dut->start(start);\n        dut->done(done);\n        for (int i = 0; i < 6; ++i) {\n            dut->in_arr[i](sig_in[i]);\n            dut->out_arr[i](sig_out[i]);\n        }\n\n        SC_THREAD(run_tests);\n    }\n\n    void run_tests() {\n        int data[6]     = {12, 11, 13, 5, 6, 7};\n        int expected[6] = {5, 6, 7, 11, 12, 13};\n\n        for (int i = 0; i < 6; ++i)\n            sig_in[i].write(data[i]);\n\n        wait(clk.posedge_event());\n        start.write(true);\n        wait(clk.posedge_event());\n        start.write(false);\n\n        wait(done.posedge_event());\n\n        for (int i = 0; i < 6; ++i) {\n            int v = sig_out[i].read();\n            std::cout << \"Element \" << i << \" sorted value: \" << v << '\\n';\n            assert(v == expected[i]);\n        }\n        std::cout << \"All tests passed successfully.\\n\";\n        sc_stop();\n    }\n};\n\n\/\/ ─────────────── sc_main ───────────────\nint sc_main(int, char*[]) {\n    Testbench tb{\"tb\"};\n    sc_start();\n    return 0;\n}\n",
        "signal":"sc_in<bool> clk;\nsc_in<bool> start;\nsc_out<bool> done;\nsc_in<int>  in_arr[N];\nsc_out<int> out_arr[N];",
        "prompt":[
            {
                "role":"system",
                "content":"You are Qwen, created by Alibaba Cloud. You are a coding expert in C++\/C code analysis and SystemC."
            },
            {
                "role":"user",
                "content":"You will receive C++\/C code as input.\n\n**Tasks**:\n1. Read and thoroughly analyze the provided C++\/C code.\n2. Identify the input(s) and output(s) of the code.\n3. Provide a detailed, line-by-line or block-by-block natural language summary that explains:\n   - The inputs and outputs of the code.\n   - Each major line or block of code and its functionality (e.g., declarations, loops, conditions, data transformations).\n4. Finally, based on your analysis, generate an equivalent SystemC code snippet that preserves the logic and can be used in a high-level synthesis flow.\n\n**Provided Signals** (for testbench integration):\nsc_in<bool> clk;\nsc_in<bool> start;\nsc_out<bool> done;\nsc_in<int>  in_arr[N];\nsc_out<int> out_arr[N];\n> **Note**:\n   - Your generated SystemC code **must** utilize these signals (or equivalent named ports) so it can integrate seamlessly with our existing testbench.\n   - If the static const are provided, insure to write them in the SystemC code as well.\n\n**C++\/C Code**:\n```\n\/\/ C++ program for the implementation of merge sort\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n\/\/ Merges two subarrays of vec.\n\/\/ First subarray is vec[left..mid]\n\/\/ Second subarray is vec[mid+1..right]\nvoid merge(vector<int>& vec, int left, int mid, int right) {\n    int i, j, k;\n    int n1 = mid - left + 1;\n    int n2 = right - mid;\n\n    \/\/ Create temporary vectors\n    vector<int> leftVec(n1), rightVec(n2);\n\n    \/\/ Copy data to temporary vectors\n    for (i = 0; i < n1; i++)\n        leftVec[i] = vec[left + i];\n    for (j = 0; j < n2; j++)\n        rightVec[j] = vec[mid + 1 + j];\n\n    \/\/ Merge the temporary vectors back into vec[left..right]\n    i = 0;\n    j = 0;\n    k = left;\n    while (i < n1 && j < n2) {\n        if (leftVec[i] <= rightVec[j]) {\n            vec[k] = leftVec[i];\n            i++;\n        } else {\n            vec[k] = rightVec[j];\n            j++;\n        }\n        k++;\n    }\n\n    \/\/ Copy the remaining elements of leftVec[], if any\n    while (i < n1) {\n        vec[k] = leftVec[i];\n        i++;\n        k++;\n    }\n\n    \/\/ Copy the remaining elements of rightVec[], if any\n    while (j < n2) {\n        vec[k] = rightVec[j];\n        j++;\n        k++;\n    }\n}\n\n\/\/ The subarray to be sorted is in the index range [left..right]\nvoid mergeSort(vector<int>& vec, int left, int right) {\n    if (left < right) {\n      \n        \/\/ Calculate the midpoint\n        int mid = left + (right - left) \/ 2;\n\n        \/\/ Sort first and second halves\n        mergeSort(vec, left, mid);\n        mergeSort(vec, mid + 1, right);\n\n        \/\/ Merge the sorted halves\n        merge(vec, left, mid, right);\n    }\n}\n\nint main() {\n    vector<int> vec = {12, 11, 13, 5, 6, 7};\n    int n = vec.size();\n\n    \/\/ Sorting vec using mergesort\n    mergeSort(vec, 0, n - 1);\n\n    for (auto i: vec)\n        cout << i << \" \";\n    return 0;\n}\n\n```\n\n**Instructions**:\n- Your answer must explicitly list the inputs and outputs.\n- Your answer must include a clear, line-by-line or block-by-block natural language explanation.\n- After the summary, generate SystemC code that reflects the same behavior.\n- In your SystemC code, incorporate the signals defined above.\n- Provide the SystemC code in a compilable snippet, for example:\n\n\n```\nFew_shot_example_1:\n#include <systemc.h>\n\n\/\/ Module that adds two integers\nSC_MODULE(Adder) {\n    sc_in<int> a;  \/\/ Input port for the first number\n    sc_in<int> b;  \/\/ Input port for the second number\n    sc_out<int> sum; \/\/ Output port for the sum\n\n    \/\/ Constructor\n    SC_CTOR(Adder) {\n        \/\/ Process to perform addition\n        SC_METHOD(add);\n        dont_initialize();\n        sensitive << a << b;\n    }\n\n    \/\/ Method to add the two numbers\n    void add() {\n        sum.write(a.read() + b.read());\n    }\n};\n\nFew_shot_example_2:\n#include <systemc.h>\n\n\/\/ Module: BubbleSort\n\/\/ Sorts a small fixed-size array of integers using the bubble sort algorithm.\nSC_MODULE(BubbleSort) {\n    sc_in<bool>  clk;      \/\/ Clock signal\n    sc_in<bool>  start;    \/\/ Start signal to begin sorting\n    sc_out<bool> done;     \/\/ Signal asserted when sorting is complete\n\n    sc_in<int>   in_arr[4];  \/\/ Input array of 4 integers to be sorted\n    sc_out<int>  out_arr[4]; \/\/ Output array of 4 sorted integers\n\n    int buf[4];  \/\/ Internal buffer to hold array elements during sorting\n\n    \/\/ Constructor: registers the sorting process with the clock\n    SC_CTOR(BubbleSort) {\n        SC_THREAD(sort_proc);\n        sensitive << clk.pos();\n    }\n\n    \/\/ Thread: waits for start, performs bubble sort, writes results, toggles done\n    void sort_proc() {\n        const int N = 4;\n        while (true) {\n            wait();  \/\/ wait for next clock edge\n            if (start.read()) {\n                \/\/ Read inputs into internal buffer\n                for (int i = 0; i < N; ++i)\n                    buf[i] = in_arr[i].read();\n\n                \/\/ Perform bubble sort on buffer[]\n                for (int i = 0; i < N - 1; ++i)\n                    for (int j = 0; j < N - i - 1; ++j)\n                        if (buf[j] > buf[j + 1])\n                            std::swap(buf[j], buf[j + 1]);\n\n                \/\/ Write sorted results to output ports\n                for (int i = 0; i < N; ++i)\n                    out_arr[i].write(buf[i]);\n\n                \/\/ Signal done for one cycle\n                done.write(true);\n                wait();\n                done.write(false);\n            }\n        }\n    }\n};\n\nFew_shot_example_3:\n#include <systemc.h>\n\n\/\/ Module: MatrixAdder\n\/\/ Adds two 4×4 matrices of integers element-wise.\nSC_MODULE(MatrixAdder) {\n    sc_in<int> A[4*4];   \/\/ Flattened 4×4 input matrix A (16 elements)\n    sc_in<int> B[4*4];   \/\/ Flattened 4×4 input matrix B (16 elements)\n    sc_out<int> C[4*4];  \/\/ Flattened 4×4 output matrix C = A + B\n\n    \/\/ Constructor: registers a combinational add method sensitive to all inputs\n    SC_CTOR(MatrixAdder) {\n        SC_METHOD(do_add);\n        \/\/ Make the add method sensitive to every element of A and B\n        for (int i = 0; i < 4*4; i++) {\n            sensitive << A[i] << B[i];\n        }\n    }\n\n    \/\/ Method: reads A[i] and B[i], writes sum into C[i] for all 16 positions\n    void do_add() {\n        for (int i = 0; i < 4*4; i++) {\n            C[i].write(A[i].read() + B[i].read());\n        }\n    }\n};\n\n\n```\n\n\nEnsure that the SystemC code you provide faithfully captures the logic of the original C++\/C source.\nMake the explanation thorough and accessible."
            }
        ]
    }
]