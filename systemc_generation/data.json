[
    {
        "task_id": 1,
        "task": "DecimaltoHexadecimalConversion.cpp",
        "code": "// C++ program to convert a decimal number to hexadecimal number \n#include <iostream> \nusing namespace std; \n\n// Function to convert decimal to hexadecimal \nvoid decToHexa(int n) \n{ \n\t// char array to store hexadecimal number \n\tchar hexaDeciNum[100]; \n\n\t// Counter for hexadecimal number array \n\tint i = 0; \n\twhile (n != 0) { \n\t\t// Temporary variable to store remainder \n\t\tint temp = 0; \n\n\t\t// Storing remainder in temp variable. \n\t\ttemp = n % 16; \n\n\t\t// Check if temp < 10 \n\t\tif (temp < 10) { \n\t\t\thexaDeciNum[i] = temp + 48; \n\t\t\ti++; \n\t\t} \n\t\telse { \n\t\t\thexaDeciNum[i] = temp + 55; \n\t\t\ti++; \n\t\t} \n\n\t\tn = n / 16; \n\t} \n\n\t// Printing hexadecimal number \n\t// array in reverse order \n\tfor (int j = i - 1; j >= 0; j--) \n\t\tcout << hexaDeciNum[j]; \n} \n\n// Driver code \nint main() \n{ \n\tint n = 2545; \n\tdecToHexa(n); \n\treturn 0; \n}\n",
        "private_test": "SC_MODULE(Testbench) {\n    sc_signal<int> decimal_in; // Signal for the decimal input\n    sc_signal<sc_bv<32>> hex_out; // Signal for the hexadecimal output\n\n    DecToHexa dec_to_hexa_inst; // Instance of the DecToHexa module\n\n    // Constructor\n    SC_CTOR(Testbench) : dec_to_hexa_inst(\"dec_to_hexa_inst\") {\n        // Connect signals to ports\n        dec_to_hexa_inst.decimal_in(decimal_in);\n        dec_to_hexa_inst.hex_out(hex_out);\n\n        // Process to run tests\n        SC_THREAD(run_tests);\n    }\n\n    // Thread to run test cases\n    void run_tests() {\n        // Test case 1: Convert 2545 to hexadecimal\n        decimal_in = 2545;\n        wait(1, SC_NS); // Wait for the conversion to process\n        std::cout << \"Decimal: 2545 -> Hexadecimal: \" << hex_out.read().to_string() << std::endl;\n\n        // Test case 2: Convert 0 to hexadecimal\n        decimal_in = 0;\n        wait(1, SC_NS);\n        std::cout << \"Decimal: 0 -> Hexadecimal: \" << hex_out.read().to_string() << std::endl;\n\n        // Test case 3: Convert 16 to hexadecimal\n        decimal_in = 16;\n        wait(1, SC_NS);\n        std::cout << \"Decimal: 16 -> Hexadecimal: \" << hex_out.read().to_string() << std::endl;\n\n        // Test case 4: Convert 255 to hexadecimal\n        decimal_in = 255;\n        wait(1, SC_NS);\n        std::cout << \"Decimal: 255 -> Hexadecimal: \" << hex_out.read().to_string() << std::endl;\n\n        // End simulation after successful test\n        std::cout << \"All tests passed successfully.\" << std::endl;\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); // Create an instance of the Testbench\n\n    // Start the simulation\n    sc_start();\n\n    return 0;\n}\n",
        "module_name": "DecToHexa"
    },
    {
        "task_id": 2,
        "task": "SortanArray_InsertionSort.cpp",
        "code": "// C++ program to sort \n// 2D matrix row-wise\n#include<bits/stdc++.h>\nusing namespace std;\n\nvoid sortRowWise(int m[][4],\n\t\t\t\tint r, int c)\n{\n// Loop for rows of matrix\nfor (int i = 0; i < r; i++) \n{\n\t// Loop for column of matrix\n\tfor (int j = 0; j < c; j++) \n\t{\n\t// Loop for comparison and swapping\n\tfor (int k = 0; k < c - j - 1; k++) \n\t{\n\t\tif (m[i][k] > m[i][k + 1]) \n\t\t{\n\t\t// Swapping of elements\n\t\tswap(m[i][k], m[i][k + 1]);\n\t\t}\n\t}\n\t}\n}\n\n// Printing the sorted matrix\nfor (int i = 0; i < r; i++) \n{\n\tfor (int j = 0; j < c; j++)\n\tcout << m[i][j] << \" \";\n\tcout << endl;\n}\n}\n\n// Driver code\nint main()\n{\nint m[][4] = {{9, 8, 7, 1},\n\t\t\t\t{7, 3, 0, 2},\n\t\t\t\t{9, 5, 3, 2},\n\t\t\t\t{6, 3, 1, 2}};\nint c = sizeof(m[0]) / sizeof(m[0][0]);\nint r = sizeof(m) / sizeof(m[0]);\nsortRowWise(m, r, c);\nreturn 0;\n}\n",
        "private_test": "SC_MODULE(Testbench) {\n    sc_signal<int> rows;          // Signal for number of rows\n    sc_signal<int> cols;          // Signal for number of columns\n    sc_signal<sc_uint<16>> mat_in[4][4]; // Signal for input matrix\n    sc_signal<sc_uint<16>> mat_out[4][4]; // Signal for output matrix\n\n    // Instance of the MatrixSorter module\n    MatrixSorter sorter_inst;\n\n    // Constructor\n    SC_CTOR(Testbench) : sorter_inst(\"sorter\") {\n        // Connect signals to ports\n        sorter_inst.rows(rows);\n        sorter_inst.cols(cols);\n        for (int i = 0; i < 4; ++i) {\n            for (int j = 0; j < 4; ++j) {\n                sorter_inst.mat_in[i][j](mat_in[i][j]);\n                sorter_inst.mat_out[i][j](mat_out[i][j]);\n            }\n        }\n\n        // Process to run tests\n        SC_THREAD(run_tests);\n    }\n\n    // Thread to run test cases\n    void run_tests() {\n        // Initialize matrix\n        int init_mat[4][4] = {{9, 8, 7, 1},\n                              {7, 3, 0, 2},\n                              {9, 5, 3, 2},\n                              {6, 3, 1, 2}};\n\n        // Set matrix dimensions\n        rows.write(4);\n        cols.write(4);\n\n        // Set matrix values\n        for (int i = 0; i < 4; i++) {\n            for (int j = 0; j < 4; j++) {\n                mat_in[i][j].write(init_mat[i][j]);\n            }\n        }\n\n        // Wait for the sorter to process\n        wait(1, SC_NS);\n\n        // Print sorted matrix\n        cout << \"Sorted Matrix:\" << endl;\n        for (int i = 0; i < 4; i++) {\n            for (int j = 0; j < 4; j++) {\n                cout << mat_out[i][j].read() << \" \";\n            }\n            cout << endl;\n        }\n\n        // End simulation\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); // Create an instance of the Testbench\n\n    // Start the simulation\n    sc_start();\n\n    return 0;\n}\n",
        "module_name": "MatrixSorter"
    },
    {
        "task_id": 3,
        "task": "PrintMultiplicationTableofaNumber.cpp",
        "code": "// C++ program to print table\n// of a number\n#include <iostream>\nusing namespace std;\n\n// Driver code\nint main()\n{\n\t// Change here to change output\n\tint n = 5;\n\tfor (int i = 1; i <= 10; ++i)\n\t\tcout << n << \" * \" << i << \" = \" << n * i << endl;\n\treturn 0;\n}\n",
        "private_test": "SC_MODULE(Testbench) {\n    sc_signal<int> n_sig; // Signal for the number\n\n    // Instance of the MultiplicationTable module\n    MultiplicationTable mul_table_inst;\n\n    // Constructor\n    SC_CTOR(Testbench)\n    : mul_table_inst(\"mul_table_inst\") {\n        // Connect signals to ports\n        mul_table_inst.n(n_sig);\n\n        // Process to set the value of n and trigger the table print\n        SC_THREAD(set_value);\n    }\n\n    // Thread to set the value of n\n    void set_value() {\n        // Set the number to 5\n        n_sig.write(5);\n        wait(1, SC_NS); // Wait for the process to update\n\n        sc_stop(); // Stop the simulation\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); // Create an instance of the Testbench\n\n    // Start the simulation\n    sc_start();\n\n    return 0;\n}\n",
        "module_name": "MultiplicationTable"
    },
    {
        "task_id": 4,
        "task": "CopyAlltheElementsofOneArraytoAnotherintheReverseOrder.cpp",
        "code": "// C program to copy the contents \n// of one array into another \n// in the reverse order \n\n#include <stdio.h> \n\n// Function to print the array \nvoid printArray(int arr[], int len) \n{ \n\tint i; \n\tfor (i = 0; i < len; i++) { \n\t\tprintf(\"%d \", arr[i]); \n\t} \n} \n\n// Driver code \nint main() \n{ \n\tint original_arr[] = {1, 2, 3, 4, 5}; \n\tint len = sizeof(original_arr)/sizeof(original_arr[0]); \n\n\tint copied_arr[len], i, j; \n\t\n\t// Copy the elements of the array \n\t// in the copied_arr in Reverse Order \n\tfor (i = 0; i < len; i++) { \n\t\tcopied_arr[i] = original_arr[len - i - 1]; \n\t} \n\n\t// Print the original_arr \n\tprintf(\" Original array: \"); \n\tprintArray(original_arr, len); \n\n\t// Print the copied array \n\tprintf(\" Resultant array: \"); \n\tprintArray(copied_arr, len); \n\n\treturn 0; \n} \n",
        "private_test": "SC_MODULE(Testbench) {\n    sc_signal<bool> clk; // Clock signal\n    sc_signal<bool> rst; // Reset signal\n\n    ArrayReverser reverser_inst; // Instance of the ArrayReverser module\n\n    // Constructor\n    SC_CTOR(Testbench) : reverser_inst(\"reverser\") {\n        // Connect signals to ports\n        reverser_inst.clk(clk);\n        reverser_inst.rst(rst);\n\n        // Create a clock generator\n        SC_THREAD(clock_gen);\n        // Create a reset signal generator\n        SC_THREAD(reset_gen);\n    }\n\n    // Clock generator thread\n    void clock_gen() {\n        clk = 0;\n        while (true) {\n            wait(1, SC_NS); // Toggle every 1 ns\n            clk = !clk;\n        }\n    }\n\n    // Reset generator thread\n    void reset_gen() {\n        rst = 1; // Assert reset\n        wait(2, SC_NS);\n        rst = 0; // Deassert reset\n        wait(SC_ZERO_TIME); // Wait for one delta cycle\n        sc_start(); // Continue simulation\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); // Create an instance of the Testbench\n\n    // Start the simulation\n    sc_start();\n\n    return 0;\n}\n",
        "module_name": "ArrayReverser"
    },
    {
        "task_id": 5,
        "task": "CalculateSumofFirstnNaturalNumbers.cpp",
        "code": "// C++ program to find sum of first n natural numbers. \n#include <iostream> \nusing namespace std; \n\n// Returns sum of first n natural \n// numbers \nint findSum(int n) \n{ \n\tint sum = 0; \n\tfor (int i = 1; i <= n; i++) \n\t\tsum = sum + i; \n\treturn sum; \n} \n\n// Driver code \nint main() \n{ \n\tint n = 5; \n\tcout << findSum(n); \n\treturn 0; \n}\n",
        "private_test": "SC_MODULE(Testbench) {\n    sc_signal<unsigned int> n_sig;    // Signal for the number of natural numbers\n    sc_signal<unsigned int> result_sig; // Signal for the sum result\n\n    // Instance of the SumCalculator module\n    SumCalculator sum_calc_inst;\n\n    // Constructor\n    SC_CTOR(Testbench) : sum_calc_inst(\"sum_calc_inst\") {\n        // Connect signals to module ports\n        sum_calc_inst.n(n_sig);\n        sum_calc_inst.result(result_sig);\n\n        // Create a test thread to provide stimulus and check the result\n        SC_THREAD(run_tests);\n    }\n\n    // Thread to run test cases\n    void run_tests() {\n        // Test case: n = 5 (expected sum = 15)\n        n_sig.write(5);\n        wait(1, SC_NS); // Wait for the process to update\n        unsigned int result = result_sig.read();\n        std::cout << \"Sum of first \" << n_sig.read() << \" natural numbers: \" << result << std::endl;\n        assert(result == 15);\n\n        // Additional test case: n = 10 (expected sum = 55)\n        n_sig.write(10);\n        wait(1, SC_NS);\n        result = result_sig.read();\n        std::cout << \"Sum of first \" << n_sig.read() << \" natural numbers: \" << result << std::endl;\n        assert(result == 55);\n\n        // End simulation after successful test\n        std::cout << \"All tests passed successfully.\" << std::endl;\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); // Instantiate the testbench module\n    sc_start();         // Start the simulation\n    return 0;\n}\n",
        "module_name": "SumCalculator"
    },
    {
        "task_id": 6,
        "task": "DisplayPrimeNumbersBetweenTwoIntervals.cpp",
        "code": "// C++ program to find the prime numbers between a given interval\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Driver code\nint main()\n{\n    // Declare the variables\n    int a, b, i, j, flag;\n\n    // Ask user to enter lower value\n    // of interval\n    cout << \"Enter lower bound of the interval: \";\n\n    // Take input\n    // cin >> a;\n    a = 100;\n\n    // Ask user to enter upper value\n    // of interval\n    cout << \"Enter upper bound of the interval: \";\n\n    // Take input\n    // cin >> b;\n    b = 300;\n    // Print display message\n    cout << \"Prime numbers between \" << a << \" and \" << b\n         << \" are: \";\n\n    // Traverse each number in the interval\n    // with the help of for loop\n    for (i = a; i <= b; i++) {\n        // Skip 0 and 1 as they are\n        // neither prime nor composite\n        if (i == 1 || i == 0)\n            continue;\n\n        // flag variable to tell\n        // if i is prime or not\n        flag = 1;\n\n        for (j = 2; j <= i / 2; ++j) {\n            if (i % j == 0) {\n                flag = 0;\n                break;\n            }\n        }\n\n        // flag = 1 means i is prime\n        // and flag = 0 means i is not prime\n        if (flag == 1)\n            cout << i << \" \";\n    }\n\n    return 0;\n}\n",
        "private_test": "SC_MODULE(Testbench) {\n    sc_signal<int> lower_bound; // Signal for the lower bound of the interval\n    sc_signal<int> upper_bound; // Signal for the upper bound of the interval\n    sc_signal<sc_bv<10>> prime_numbers; // Signal for the prime numbers\n\n    PrimeFinder prime_finder_inst; // Instance of the PrimeFinder module\n\n    // Constructor\n    SC_CTOR(Testbench) : prime_finder_inst(\"prime_finder\") {\n        // Connect signals to ports\n        prime_finder_inst.lower_bound(lower_bound);\n        prime_finder_inst.upper_bound(upper_bound);\n        prime_finder_inst.prime_numbers(prime_numbers);\n\n        // Process to run tests\n        SC_THREAD(run_tests);\n    }\n\n    // Thread to run test cases\n    void run_tests() {\n        // Set the interval bounds\n        lower_bound = 100;\n        upper_bound = 300;\n        wait(1, SC_NS); // Wait for the prime finder to process\n\n        // Print success message\n        cout << \"Test passed successfully.\" << endl;\n\n        sc_stop(); // Stop the simulation\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); // Create an instance of the Testbench\n\n    // Start the simulation\n    sc_start();\n\n    return 0;\n}\n",
        "module_name": "PrimeFinder"
    },
    {
        "task_id": 7,
        "task": "OctaltoDecimalConversion.cpp",
        "code": "// C++ program to convert octal \n// to decimal\n#include <iostream>\nusing namespace std;\n\n// Function to convert octal \n// to decimal\nint octalToDecimal(int n)\n{\n\tint num = n;\n\tint dec_value = 0;\n\n\t// Initializing base value to 1, \n\t// i.e 8^0\n\tint base = 1;\n\n\tint temp = num;\n\twhile (temp) \n\t{\n\t\t// Extracting last digit\n\t\tint last_digit = temp % 10;\n\t\ttemp = temp / 10;\n\n\t\t// Multiplying last digit with \n\t\t// appropriate base value and adding \n\t\t// it to dec_value\n\t\tdec_value += last_digit * base;\n\n\t\tbase = base * 8;\n\t}\n\n\treturn dec_value;\n}\n\n// Driver code\nint main()\n{\n\tint num = 67;\n\n\tcout << octalToDecimal(num) << endl;\n}\n",
        "private_test": "SC_MODULE(Testbench) {\n    sc_signal<int> octal_input_sig; // Signal for the octal input\n    sc_signal<int> decimal_output_sig; // Signal for the decimal output\n\n    OctalToDecimalConverter converter_inst; // Instance of the converter module\n\n    // Constructor\n    SC_CTOR(Testbench) : converter_inst(\"converter\") {\n        // Connect signals to ports\n        converter_inst.octal_input(octal_input_sig);\n        converter_inst.decimal_output(decimal_output_sig);\n\n        // Process to run tests\n        SC_THREAD(run_tests);\n    }\n\n    // Thread to run test cases\n    void run_tests() {\n        // Test case 1: Convert 67 (octal) to decimal\n        octal_input_sig = 67;\n        wait(1, SC_NS); // Wait for the converter to process\n        int result = decimal_output_sig.read();\n        cout << \"Octal: 67 -> Decimal: \" << result << endl;\n        assert(result == 55); // 67 in octal is 55 in decimal\n\n        // Additional test case: Convert 123 (octal) to decimal\n        octal_input_sig = 123;\n        wait(1, SC_NS);\n        result = decimal_output_sig.read();\n        cout << \"Octal: 123 -> Decimal: \" << result << endl;\n        assert(result == 83); // 123 in octal is 83 in decimal\n\n        // Print success message\n        cout << \"All tests passed successfully.\" << endl;\n\n        sc_stop(); // Stop the simulation\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); // Create an instance of the Testbench\n\n    // Start the simulation\n    sc_start();\n\n    return 0;\n}\n",
        "module_name": "OctalToDecimalConverter"
    },
    {
        "task_id": 8,
        "task": "SearchanElementinanArray_BinarySearch.cpp",
        "code": "// C++ program to implement iterative \n// binary search\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool binarySearch(vector<int>& v, int target) {\n    \n      // Defining the part of the vector to be\n      // searched\n    int low = 0, high = v.size() - 1;\n      \n      // Till the element is found or vector cannot\n      // be divided into more parts\n    while (low <= high) {\n      \n          // Finding mid point\n        int mid = ((high - low) / 2) + low;\n\n        // If the middle element is equal to target\n        if (v[mid] == target) {\n            return true;\n        }\n\n        // If the middle element is greater than \n        // target, search in the left half \n        if (v[mid] > target)\n            high = mid - 1;\n        \n        // If the middle element is smaller than\n        // target, search the right half \n        else\n            low = mid + 1;\n    }\n      \n      // If we don't find the target\n      return false;\n}\n\nint main() {\n    vector<int> v = {1, 2, 3, 4, 5, 8, 9, 11};\n    \n      // Element to be searched\n      int target = 8;\n  \n      // Searching the target element\n    if (binarySearch(v, target)) {\n        cout << target << \" found.\";\n    } else {\n        cout << target << \" NOT found.\";\n    }\n    return 0;\n}\n",
        "private_test": "SC_MODULE(Testbench) {\n    sc_vector<sc_signal<int>> v_sig; // Signals for the vector elements\n    sc_signal<int> target_sig;       // Signal for the target value\n    sc_signal<bool> found_sig;       // Signal for the result\n\n    BinarySearchModule bs_inst; // Instance of the BinarySearchModule\n\n    // Constructor\n    SC_CTOR(Testbench)\n    : bs_inst(\"bs_inst\"), v_sig(\"v_sig\", 8) { // Initialize vector size to 8\n        // Connect signals to module ports\n        for (size_t i = 0; i < v_sig.size(); ++i) {\n            bs_inst.v[i](v_sig[i]);\n        }\n        bs_inst.target(target_sig);\n        bs_inst.found(found_sig);\n\n        // Process to run tests\n        SC_THREAD(run_tests);\n    }\n\n    // Thread to run test cases\n    void run_tests() {\n        // Initialize the vector with sorted values\n        std::vector<int> v_values = {1, 2, 3, 4, 5, 8, 9, 11};\n        for (size_t i = 0; i < v_values.size(); ++i) {\n            v_sig[i].write(v_values[i]);\n        }\n\n        // Test case 1: Target found\n        target_sig.write(8);\n        wait(1, SC_NS); // Wait for the module to process\n        assert(found_sig.read() == true);\n        cout << \"Target \" << target_sig.read() << \" found: \" << found_sig.read() << endl;\n\n        // Test case 2: Target not found\n        target_sig.write(7);\n        wait(1, SC_NS); // Wait for the module to process\n        assert(found_sig.read() == false);\n        cout << \"Target \" << target_sig.read() << \" found: \" << found_sig.read() << endl;\n\n        // End simulation after successful test\n        cout << \"All tests passed successfully.\" << endl;\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); // Create an instance of the Testbench\n\n    // Start the simulation\n    sc_start();\n\n    return 0;\n}\n",
        "module_name": "BinarySearchModule"
    },
    {
        "task_id": 9,
        "task": "SumofFibonacciNumbersatEvenIndexesuptoNTerms.cpp",
        "code": "// C++ Program to find sum of \n// even-indiced Fibonacci numbers\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Computes value of first \n// fibonacci numbers and \n// stores the even-indexed sum\nint calculateEvenSum(int n)\n{\n\tif (n <= 0)\n\t\treturn 0;\n\n\tint fibo[2 * n + 1];\n\tfibo[0] = 0, fibo[1] = 1;\n\n\t// Initialize result\n\tint sum = 0;\n\n\t// Add remaining terms\n\tfor (int i = 2; i <= 2 * n; i++) \n\t{\n\t\tfibo[i] = fibo[i - 1] + fibo[i - 2];\n\n\t\t// For even indices\n\t\tif (i % 2 == 0)\n\t\t\tsum += fibo[i];\n\t}\n\n\t// Return the alternating sum\n\treturn sum;\n}\n\n// Driver code\nint main()\n{\n\n\t// Get n\n\tint n = 8;\n\n\t// Find the even-indiced sum\n\tcout << \"Even indexed Fibonacci Sum upto \" << \n\t\t\tn << \" terms: \" << calculateEvenSum(n) << \n\t\t\tendl;\n\n\treturn 0;\n}\n",
        "private_test": "SC_MODULE(Testbench) {\n    sc_signal<int> n_sig; // Signal for the number of terms\n    sc_signal<int> sum_sig; // Signal for the sum of even-indexed Fibonacci numbers\n\n    // Instance of the FibonacciSumCalculator module\n    FibonacciSumCalculator fib_sum_calc_inst;\n\n    // Constructor\n    SC_CTOR(Testbench)\n    : fib_sum_calc_inst(\"fib_sum_calc_inst\") {\n        // Connect signals to module ports\n        fib_sum_calc_inst.n(n_sig);\n        fib_sum_calc_inst.sum(sum_sig);\n\n        // Create a test thread to provide stimulus and check the result\n        SC_THREAD(run_tests);\n    }\n\n    // Thread to run test cases\n    void run_tests() {\n        // Test case: n = 8 (expected sum = 44)\n        n_sig.write(8);\n        wait(1, SC_NS); // Wait for the process to update\n        int result = sum_sig.read();\n        std::cout << \"Even indexed Fibonacci Sum upto \" << n_sig.read() << \" terms: \" << result << std::endl;\n        assert(result == 44);\n\n        // Additional test case: n = 5 (expected sum = 10)\n        n_sig.write(5);\n        wait(1, SC_NS);\n        result = sum_sig.read();\n        std::cout << \"Even indexed Fibonacci Sum upto \" << n_sig.read() << \" terms: \" << result << std::endl;\n        assert(result == 10);\n\n        // End simulation after successful tests\n        std::cout << \"All tests passed successfully.\" << std::endl;\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); // Instantiate the testbench module\n    sc_start();         // Start the simulation\n    return 0;\n}\n",
        "module_name": "FibonacciSumCalculator"
    },
    {
        "task_id": 10,
        "task": "CheckWhetheraNumberisPrimeorNot.cpp",
        "code": "// C++ Program to check for prime number using Simple Trial Division\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int n = 29;\n\n    int cnt = 0;\n\n    // If number is less than/equal to 1,\n    // it is not prime\n    if (n <= 1)\n        cout << n << \" is NOT prime\" << endl;\n    else {\n\n        // Check for divisors from 1 to n\n        for (int i = 1; i <= n; i++) {\n\n            // Check how many number is divisible\n            // by n\n            if (n % i == 0)\n                cnt++;\n        }\n\n        // If n is divisible by more than 2 numbers\n        // then it is not prime\n        if (cnt > 2)\n            cout << n << \" is NOT prime\" << endl;\n\n        // else it is prime\n        else\n            cout << n << \" is prime\" << endl;\n    }\n\n    return 0;\n}\n\n",
        "private_test": "SC_MODULE(Testbench) {\n    sc_signal<int> n_sig;       // Signal for the input number\n    sc_signal<bool> prime_sig;  // Signal for the prime check result\n\n    // Instance of the PrimeChecker module\n    PrimeChecker prime_checker_inst;\n\n    // Constructor: Initialize the module and run the test thread\n    SC_CTOR(Testbench)\n    : prime_checker_inst(\"prime_checker_inst\") {\n        // Connect signals to module ports\n        prime_checker_inst.n(n_sig);\n        prime_checker_inst.is_prime(prime_sig);\n\n        // Create a test thread to provide stimulus and check the result\n        SC_THREAD(run_tests);\n    }\n\n    // Thread to run test cases\n    void run_tests() {\n        // Test case: n = 29 (expected: prime)\n        n_sig.write(29);\n        wait(1, SC_NS); // Wait for the process to update\n        bool result = prime_sig.read();\n        std::cout << \"Number \" << n_sig.read() << \" is \" << (result ? \"prime\" : \"NOT prime\") << std::endl;\n        assert(result == true);\n\n        // Test case: n = 1 (expected: NOT prime)\n        n_sig.write(1);\n        wait(1, SC_NS);\n        result = prime_sig.read();\n        std::cout << \"Number \" << n_sig.read() << \" is \" << (result ? \"prime\" : \"NOT prime\") << std::endl;\n        assert(result == false);\n\n        // Test case: n = 10 (expected: NOT prime)\n        n_sig.write(10);\n        wait(1, SC_NS);\n        result = prime_sig.read();\n        std::cout << \"Number \" << n_sig.read() << \" is \" << (result ? \"prime\" : \"NOT prime\") << std::endl;\n        assert(result == false);\n\n        // Test case: n = 13 (expected: prime)\n        n_sig.write(13);\n        wait(1, SC_NS);\n        result = prime_sig.read();\n        std::cout << \"Number \" << n_sig.read() << \" is \" << (result ? \"prime\" : \"NOT prime\") << std::endl;\n        assert(result == true);\n\n        // End simulation after successful tests\n        std::cout << \"All tests passed successfully.\" << std::endl;\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); // Instantiate the testbench module\n    sc_start();         // Start the simulation\n    return 0;\n}\n",
        "module_name": "PrimeChecker"
    },
    {
        "task_id": 11,
        "task": "SorttheElementsofanArrayinDescendingOrder.cpp",
        "code": "// C++ program to sort array \n// in ascending order using\n// Brute-force approach\n// using bubble sort\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid sort(int num[], int len);\nvoid swapNums(int nums[], \n\t\t\tint first, int second);\n\n// Driver code\nint main()\n{\n\t// Initializing arrya\n\tint nums[] = {1, 12, 6, 8, 10};\n\tint size_nums = (sizeof(nums) / \n\t\t\t\t\tsizeof(nums[0]));\n\n\tcout << \"Before sorting the array is: \\n\";\n\tfor (int i = 0; i < size_nums; i++)\n\t\tcout << nums[i] << \" \";\n\tcout << \"\\n\\n\";\n\n\tsort(nums, size_nums);\n\n\tcout << \"After sorting the array is: \\n\";\n\n\tfor (int i = 0; i < size_nums; i++)\n\t\tcout << nums[i] << \" \";\n\tcout << \"\\n\";\n\treturn 0;\n}\n\n// Sort function\nvoid sort(int num[], int len)\n{\n\tbool isSwapped;\n\n\t/**\n\t* Here we are running n-1 steps, \n\tfor each step, max item will \n\tcome at the last respective \n\tindex and swap element if the \n\telement is smaller than the \n\tprevious one.\n\t**/\n\tfor (int i = 0; i < len; i++) \n\t{\n\t\tisSwapped = false;\n\t\tfor (int j = 1; j < len - i; j++) \n\t\t{\n\t\t\tif (num[j] < num[j - 1]) \n\t\t\t{\n\t\t\t\tswapNums(num, j, (j - 1));\n\t\t\t\tisSwapped = true;\n\t\t\t}\n\t\t}\n\t\tif (!isSwapped) \n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n// Swaps two numbers in array\nvoid swapNums(int nums[], \n\t\t\tint first, int second)\n{\n\tint curr = nums[first];\n\tnums[first] = nums[second];\n\tnums[second] = curr;\n}\n",
        "private_test": "SC_MODULE(Testbench) {\n    sc_clock clk;              // Clock signal\n    sc_signal<bool> reset;      // Reset signal\n    sc_vector<sc_signal<int>> nums; // Signals representing the array elements\n    sc_signal<bool> done;       // Signal indicating sorting completion\n\n    BubbleSort sorter;         // Instance of the BubbleSort module\n\n    // Constructor\n    SC_CTOR(Testbench) : clk(\"clk\", 10, SC_NS), nums(\"nums\", 5), sorter(\"sorter\") {\n        // Connect signals to module ports\n        sorter.clk(clk);\n        sorter.reset(reset);\n        sorter.done(done);\n        for (int i = 0; i < 5; i++) {\n            sorter.nums[i](nums[i]);\n        }\n\n        // Process to run tests\n        SC_THREAD(run_tests);\n    }\n\n    // Thread to run test cases\n    void run_tests() {\n        // Initialize the array\n        nums[0].write(1);\n        nums[1].write(12);\n        nums[2].write(6);\n        nums[3].write(8);\n        nums[4].write(10);\n\n        // Apply reset\n        reset.write(true);\n        wait(1, SC_NS);\n        reset.write(false);\n        wait(1, SC_NS);\n\n        // Wait until sorting is done\n        while (!done.read()) {\n            wait(1, SC_NS);\n        }\n\n        // Print the sorted array\n        cout << \"After sorting the array is: \\n\";\n        for (int i = 0; i < 5; i++) {\n            cout << nums[i].read() << \" \";\n        }\n        cout << \"\\n\";\n\n        // End simulation\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); // Create an instance of the Testbench\n\n    // Start the simulation\n    sc_start();\n\n    return 0;\n}\n",
        "module_name": "BubbleSort"
    },
    {
        "task_id": 12,
        "task": "InterchangeElementsofFirstAndLastColumnsInMatrix.cpp",
        "code": "// C++ code to swap the element of first \n// and last row and display the result \n#include <iostream> \nusing namespace std; \n\n#define n 4 \n\nvoid interchangeFirstLast(int m[][n]) \n{ \n\t\tint rows = n; \n\t\t\n\t\t// Swapping of element between first \n\t\t// and last rows \n\t\tfor (int i = 0; i < n; i++) \n\t\t{ \n\t\t\tint t = m[0][i]; \n\t\t\tm[0][i] = m[rows - 1][i]; \n\t\t\tm[rows - 1][i] = t; \n\t\t} \n} \n\n// Driver code \nint main() \n{ \n\t// input in the array \n\tint m[n][n] = {{8, 9, 7, 6}, \n\t\t\t\t{4, 7, 6, 5}, \n\t\t\t\t{3, 2, 1, 8}, \n\t\t\t\t{9, 9, 7, 7}}; \n\t\t\t\t\n\tinterchangeFirstLast(m); \n\t\n\t// Printing the interchanged matrix \n\tfor (int i = 0; i < n; i++) \n\t{ \n\t\tfor (int j = 0; j < n; j++) \n\t\t\tcout << m[i][j] << \" \"; \n\t\tcout << endl; \n\t} \n} \n\n// This code is contributed by Anant Agarwal. \n",
        "private_test": "SC_MODULE(Testbench) {\n    sc_clock clk; // Clock signal\n    sc_signal<bool> rst; // Reset signal\n    sc_signal<sc_matrix<int, 4, 4>> input_matrix; // Input matrix signal\n    sc_signal<sc_matrix<int, 4, 4>> output_matrix; // Output matrix signal\n\n    MatrixInterchanger matrix_interchanger_inst; // Instance of the MatrixInterchanger module\n\n    // Constructor\n    SC_CTOR(Testbench) : matrix_interchanger_inst(\"matrix_interchanger\"), clk(\"clk\", 10, SC_NS) {\n        // Connect signals to ports\n        matrix_interchanger_inst.clk(clk);\n        matrix_interchanger_inst.rst(rst);\n        matrix_interchanger_inst.input_matrix(input_matrix);\n        matrix_interchanger_inst.output_matrix(output_matrix);\n\n        // Process to initialize and run the test\n        SC_THREAD(run_test);\n    }\n\n    // Thread to run test cases\n    void run_test() {\n        // Initialize the input matrix\n        sc_matrix<int, 4, 4> init_matrix = {{8, 9, 7, 6},\n                                            {4, 7, 6, 5},\n                                            {3, 2, 1, 8},\n                                            {9, 9, 7, 7}};\n        input_matrix.write(init_matrix);\n        rst.write(true); // Assert reset\n        wait(1, SC_NS);\n        rst.write(false); // Deassert reset\n        wait(1, SC_NS);\n\n        // Print the output matrix\n        sc_matrix<int, 4, 4> result_matrix = output_matrix.read();\n        for (int i = 0; i < 4; ++i) {\n            for (int j = 0; j < 4; ++j) {\n                cout << result_matrix[i][j] << \" \";\n            }\n            cout << endl;\n        }\n\n        // Stop the simulation\n        sc_stop();\n    }\n};\n\n// Custom matrix type definition\ntemplate<typename T, int ROWS, int COLS>\nclass sc_matrix : public sc_vector<sc_vector<T>> {\npublic:\n    sc_matrix(sc_module_name name) : sc_vector<sc_vector<T>>(name, ROWS, sc_gen_unique_name(\"row\")) {\n        for (int i = 0; i < ROWS; ++i) {\n            (*this)[i].init(COLS, sc_gen_unique_name(\"col\"));\n        }\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); // Create an instance of the Testbench\n\n    // Start the simulation\n    sc_start();\n\n    return 0;\n}\n",
        "module_name": "MatrixInterchanger"
    },
    {
        "task_id": 13,
        "task": "AddTwoMatrices.cpp",
        "code": "// C++ program for addition of two matrices\n#include <bits/stdc++.h>\nusing namespace std;\n#define N 4\n\n// This function adds A[][] and B[][],\n// and stores the result in C[][]\nvoid add(int A[][N], int B[][N], int C[][N])\n{\n    int i, j;\n    for (i = 0; i < N; i++)\n        for (j = 0; j < N; j++)\n            C[i][j] = A[i][j] + B[i][j];\n}\n\n// Driver code\nint main()\n{\n    int A[N][N] = { { 1, 1, 1, 1 },\n                    { 2, 2, 2, 2 },\n                    { 3, 3, 3, 3 },\n                    { 4, 4, 4, 4 } };\n\n    int B[N][N] = { { 1, 1, 1, 1 },\n                    { 2, 2, 2, 2 },\n                    { 3, 3, 3, 3 },\n                    { 4, 4, 4, 4 } };\n\n    // To store the result\n    int C[N][N];\n    int i, j;\n    add(A, B, C);\n\n    cout << \"Result matrix is \" << endl;\n    for (i = 0; i < N; i++) {\n        for (j = 0; j < N; j++)\n            cout << C[i][j] << \" \";\n        cout << endl;\n    }\n\n    return 0;\n}\n",
        "private_test": "SC_MODULE(Testbench) {\n    sc_signal<sc_matrix_int> A; // Signal for the first matrix\n    sc_signal<sc_matrix_int> B; // Signal for the second matrix\n    sc_signal<sc_matrix_int> C; // Signal for the result matrix\n\n    MatrixAdder matrix_adder_inst; // Instance of the MatrixAdder module\n\n    // Constructor\n    SC_CTOR(Testbench) : matrix_adder_inst(\"matrix_adder\") {\n        // Connect signals to ports\n        matrix_adder_inst.A(A);\n        matrix_adder_inst.B(B);\n        matrix_adder_inst.C(C);\n\n        // Process to run tests\n        SC_THREAD(run_tests);\n    }\n\n    // Thread to run test cases\n    void run_tests() {\n        // Initialize matrices A and B\n        sc_matrix_int A_val(4, 4);\n        sc_matrix_int B_val(4, 4);\n\n        // Assign values to matrix A\n        A_val(0, 0) = 1; A_val(0, 1) = 1; A_val(0, 2) = 1; A_val(0, 3) = 1;\n        A_val(1, 0) = 2; A_val(1, 1) = 2; A_val(1, 2) = 2; A_val(1, 3) = 2;\n        A_val(2, 0) = 3; A_val(2, 1) = 3; A_val(2, 2) = 3; A_val(2, 3) = 3;\n        A_val(3, 0) = 4; A_val(3, 1) = 4; A_val(3, 2) = 4; A_val(3, 3) = 4;\n\n        // Assign values to matrix B\n        B_val(0, 0) = 1; B_val(0, 1) = 1; B_val(0, 2) = 1; B_val(0, 3) = 1;\n        B_val(1, 0) = 2; B_val(1, 1) = 2; B_val(1, 2) = 2; B_val(1, 3) = 2;\n        B_val(2, 0) = 3; B_val(2, 1) = 3; B_val(2, 2) = 3; B_val(2, 3) = 3;\n        B_val(3, 0) = 4; B_val(3, 1) = 4; B_val(3, 2) = 4; B_val(3, 3) = 4;\n\n        // Write matrices A and B to signals\n        A.write(A_val);\n        B.write(B_val);\n\n        // Wait for the matrix adder to process\n        wait(1, SC_NS);\n\n        // Read and print the result matrix C\n        sc_matrix_int C_val = C.read();\n        cout << \"Result matrix is \" << endl;\n        for (int i = 0; i < 4; i++) {\n            for (int j = 0; j < 4; j++) {\n                cout << C_val(i, j) << \" \";\n            }\n            cout << endl;\n        }\n\n        // Stop the simulation\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); // Create an instance of the Testbench\n\n    // Start the simulation\n    sc_start();\n\n    return 0;\n}\n",
        "module_name": "MatrixAdder"
    },
    {
        "task_id": 14,
        "task": "CheckifaGivenYearisaLeapYear.cpp",
        "code": "// C++ program to check if a given year is a leap year or not\n#include <iostream>\nusing namespace std;\n\n// Function to check leap year\nbool checkYear(int year)\n{\n\tif (year % 400 == 0) {\n\t\treturn true;\n\t}\n\n\t// not a leap year if divisible by 100\n\t// but not divisible by 400\n\telse if (year % 100 == 0) {\n\t\treturn false;\n\t}\n\n\t// leap year if not divisible by 100\n\t// but divisible by 4\n\telse if (year % 4 == 0) {\n\t\treturn true;\n\t}\n\n\t// all other years are not leap years\n\telse {\n\t\treturn false;\n\t}\n}\n\n// Driver code\nint main()\n{\n\tint year = 2000;\n\n\tcheckYear(year) ? cout << \"Leap Year\"\n\t\t\t\t\t: cout << \"Not a Leap Year\";\n\n\treturn 0;\n}\n",
        "private_test": "SC_MODULE(Testbench) {\n    sc_signal<int> year;             // Signal for the year\n    sc_signal<bool> is_leap_year;    // Signal for the leap year check result\n\n    LeapYearChecker checker_inst;    // Instance of the LeapYearChecker module\n\n    // Constructor\n    SC_CTOR(Testbench) : checker_inst(\"checker\") {\n        // Connect signals to ports\n        checker_inst.year(year);\n        checker_inst.is_leap_year(is_leap_year);\n\n        // Process to run tests\n        SC_THREAD(run_tests);\n    }\n\n    // Thread to run test cases\n    void run_tests() {\n        // Test case 1: Year 2000 (Leap Year)\n        year = 2000;\n        wait(1, SC_NS);\n        assert(is_leap_year.read() == true);\n        cout << \"Year 2000: \" << (is_leap_year.read() ? \"Leap Year\" : \"Not a Leap Year\") << endl;\n\n        // Test case 2: Year 1900 (Not a Leap Year)\n        year = 1900;\n        wait(1, SC_NS);\n        assert(is_leap_year.read() == false);\n        cout << \"Year 1900: \" << (is_leap_year.read() ? \"Leap Year\" : \"Not a Leap Year\") << endl;\n\n        // Test case 3: Year 2004 (Leap Year)\n        year = 2004;\n        wait(1, SC_NS);\n        assert(is_leap_year.read() == true);\n        cout << \"Year 2004: \" << (is_leap_year.read() ? \"Leap Year\" : \"Not a Leap Year\") << endl;\n\n        // Test case 4: Year 2001 (Not a Leap Year)\n        year = 2001;\n        wait(1, SC_NS);\n        assert(is_leap_year.read() == false);\n        cout << \"Year 2001: \" << (is_leap_year.read() ? \"Leap Year\" : \"Not a Leap Year\") << endl;\n\n        // Print success message\n        cout << \"All tests passed successfully.\" << endl;\n\n        sc_stop(); // Stop the simulation\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); // Create an instance of the Testbench\n\n    // Start the simulation\n    sc_start();\n\n    return 0;\n}\n",
        "module_name": "LeapYearChecker"
    },
    {
        "task_id": 15,
        "task": "CalculatetheAverageofalltheElementsPresentinanArray.cpp",
        "code": "// C++ program to calculate average of array elements\n#include <iostream>\nusing namespace std;\n\n// Function that return average\n// of an array.\ndouble average(int a[], int n)\n{\n    // Find sum of array element\n    int sum = 0;\n    for (int i = 0; i < n; i++)\n        sum += a[i];\n\n    return (double)sum / n;\n}\n\n// Driver code\nint main()\n{\n    int arr[] = { 10, 2, 3, 4, 5, 6, 7, 8, 9 };\n    int n = sizeof(arr) / sizeof(arr[0]);\n\n    cout << average(arr, n) << endl;\n    return 0;\n}\n",
        "private_test": "SC_MODULE(Testbench) {\n    sc_clock clk;             // Clock signal\n    sc_signal<bool> rst;      // Reset signal\n    sc_signal<int> arr[9];    // Array of input signals\n    sc_signal<double> avg;    // Average output signal\n\n    // Instance of the AverageCalculator module\n    AverageCalculator avg_inst;\n\n    // Constructor\n    SC_CTOR(Testbench)\n    : avg_inst(\"avg_inst\"), clk(\"clk\", 10, SC_NS, 0.5, 0, SC_NS, true) {\n        // Connect signals to module ports\n        avg_inst.clk(clk);\n        avg_inst.rst(rst);\n        for (int i = 0; i < 9; i++) {\n            avg_inst.arr[i](arr[i]);\n        }\n        avg_inst.avg(avg);\n\n        // Process to run tests\n        SC_THREAD(run_tests);\n    }\n\n    // Thread to run test cases\n    void run_tests() {\n        // Reset the system\n        rst.write(true);\n        wait(10, SC_NS);\n        rst.write(false);\n\n        // Initialize array values\n        for (int i = 0; i < 9; i++) {\n            arr[i].write(i + 10); // Values 10, 11, ..., 18\n        }\n\n        // Wait for the calculation to complete\n        wait(100, SC_NS);\n\n        // Print the result\n        cout << \"Average: \" << avg.read() << endl;\n\n        // Stop the simulation\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); // Create an instance of the Testbench\n\n    // Start the simulation\n    sc_start();\n\n    return 0;\n}\n",
        "module_name": "AverageCalculator"
    },
    {
        "task_id": 16,
        "task": "CheckWhetheraNumberCanbeExpressedasSumofTwoPrimeNumbers.cpp",
        "code": "// C++ program to check if a prime number can be expressed as sum of two Prime Numbers \n#include <bits/stdc++.h> \nusing namespace std; \n\n// Function to check whether \n// a number is prime or not \nbool isPrime(int n) \n{ \n\tif (n <= 1) \n\t\treturn false; \n\n\tfor (int i = 2; i <= sqrt(n); i++) \n\t{ \n\t\tif (n % i == 0) \n\t\t\treturn false; \n\t} \n\n\treturn true; \n} \n\n// Function to check if a prime number \n// can be expressed as sum of \n// two Prime Numbers \nbool isPossible(int N) \n{ \n\t// if the number is prime, \n\t// and number-2 is also prime \n\tif (isPrime(N) && isPrime(N - 2)) \n\t\treturn true; \n\telse\n\t\treturn false; \n} \n\n// Driver code \nint main() \n{ \n\tint n = 13; \n\n\tif (isPossible(n)) \n\t\tcout << \"Yes\"; \n\telse\n\t\tcout << \"No\"; \n\n\treturn 0; \n} \n",
        "private_test": "SC_MODULE(Testbench) {\n    sc_signal<int> n_sig;       // Signal for the input number\n    sc_signal<bool> result_sig; // Signal for the result\n\n    // Instance of the PrimeSumChecker module\n    PrimeSumChecker checker_inst;\n\n    // Constructor: Initialize the module and run the test thread\n    SC_CTOR(Testbench)\n    : checker_inst(\"checker_inst\") {\n        // Connect signals to module ports\n        checker_inst.n_in(n_sig);\n        checker_inst.result_out(result_sig);\n\n        // Create a test thread to provide stimulus and check the result\n        SC_THREAD(run_tests);\n    }\n\n    // Thread to run test cases\n    void run_tests() {\n        // Test case: n = 13 (expected result: true)\n        n_sig.write(13);\n        wait(1, SC_NS); // Wait for the process to update\n        bool result = result_sig.read();\n        std::cout << \"Can 13 be expressed as the sum of two primes? \" << (result ? \"Yes\" : \"No\") << std::endl;\n        assert(result == true);\n\n        // Additional test case: n = 17 (expected result: false)\n        n_sig.write(17);\n        wait(1, SC_NS);\n        result = result_sig.read();\n        std::cout << \"Can 17 be expressed as the sum of two primes? \" << (result ? \"Yes\" : \"No\") << std::endl;\n        assert(result == false);\n\n        // End simulation after successful tests\n        std::cout << \"All tests passed successfully.\" << std::endl;\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); // Instantiate the testbench module\n    sc_start();         // Start the simulation\n    return 0;\n}\n",
        "module_name": "PrimeSumChecker"
    },
    {
        "task_id": 17,
        "task": "MergeSort.cpp",
        "code": "// C++ program for the implementation of merge sort\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Merges two subarrays of vec.\n// First subarray is vec[left..mid]\n// Second subarray is vec[mid+1..right]\nvoid merge(vector<int>& vec, int left, int mid, int right) {\n    int i, j, k;\n    int n1 = mid - left + 1;\n    int n2 = right - mid;\n\n    // Create temporary vectors\n    vector<int> leftVec(n1), rightVec(n2);\n\n    // Copy data to temporary vectors\n    for (i = 0; i < n1; i++)\n        leftVec[i] = vec[left + i];\n    for (j = 0; j < n2; j++)\n        rightVec[j] = vec[mid + 1 + j];\n\n    // Merge the temporary vectors back into vec[left..right]\n    i = 0;\n    j = 0;\n    k = left;\n    while (i < n1 && j < n2) {\n        if (leftVec[i] <= rightVec[j]) {\n            vec[k] = leftVec[i];\n            i++;\n        } else {\n            vec[k] = rightVec[j];\n            j++;\n        }\n        k++;\n    }\n\n    // Copy the remaining elements of leftVec[], if any\n    while (i < n1) {\n        vec[k] = leftVec[i];\n        i++;\n        k++;\n    }\n\n    // Copy the remaining elements of rightVec[], if any\n    while (j < n2) {\n        vec[k] = rightVec[j];\n        j++;\n        k++;\n    }\n}\n\n// The subarray to be sorted is in the index range [left..right]\nvoid mergeSort(vector<int>& vec, int left, int right) {\n    if (left < right) {\n      \n        // Calculate the midpoint\n        int mid = left + (right - left) / 2;\n\n        // Sort first and second halves\n        mergeSort(vec, left, mid);\n        mergeSort(vec, mid + 1, right);\n\n        // Merge the sorted halves\n        merge(vec, left, mid, right);\n    }\n}\n\nint main() {\n    vector<int> vec = {12, 11, 13, 5, 6, 7};\n    int n = vec.size();\n\n    // Sorting vec using mergesort\n    mergeSort(vec, 0, n - 1);\n\n    for (auto i: vec)\n        cout << i << \" \";\n    return 0;\n}\n",
        "private_test": "SC_MODULE(Testbench) {\n    sc_clock clk;             // Clock signal\n    sc_signal<bool> reset;   // Reset signal\n    sc_signal<bool> start;   // Start signal to begin sorting\n    sc_signal<bool> done;    // Done signal indicating completion\n    sc_vector<sc_signal<int>> input; // Input vector of integers\n    sc_vector<sc_signal<int>> output; // Output vector of integers\n\n    MergeSortModule merge_sort_inst; // Instance of the MergeSortModule\n\n    // Constructor\n    SC_CTOR(Testbench)\n    : clk(\"clk\", 10, SC_NS, 0.5), input(\"input\", 6), output(\"output\", 6),\n      merge_sort_inst(\"merge_sort_inst\") {\n        // Connect signals to ports\n        merge_sort_inst.clk(clk);\n        merge_sort_inst.reset(reset);\n        merge_sort_inst.start(start);\n        merge_sort_inst.done(done);\n        for (size_t i = 0; i < input.size(); ++i) {\n            merge_sort_inst.input[i](input[i]);\n            merge_sort_inst.output[i](output[i]);\n        }\n\n        // Process to run tests\n        SC_THREAD(run_tests);\n    }\n\n    // Thread to run test cases\n    void run_tests() {\n        // Reset the system\n        reset.write(true);\n        wait(2, SC_NS);\n        reset.write(false);\n        wait(2, SC_NS);\n\n        // Initialize input data\n        std::vector<int> vec = {12, 11, 13, 5, 6, 7};\n        for (size_t i = 0; i < input.size(); ++i) {\n            input[i].write(vec[i]);\n        }\n\n        // Start sorting\n        start.write(true);\n        wait(1, SC_NS);\n        start.write(false);\n\n        // Wait for sorting to complete\n        while (!done.read()) {\n            wait(1, SC_NS);\n        }\n\n        // Read and print sorted output\n        for (size_t i = 0; i < output.size(); ++i) {\n            std::cout << output[i].read() << \" \";\n        }\n        std::cout << std::endl;\n\n        // End simulation\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); // Create an instance of the Testbench\n\n    // Start the simulation\n    sc_start();\n\n    return 0;\n}\n",
        "module_name": "MergeSortModule"
    },
    {
        "task_id": 18,
        "task": "Swaptwonumbers.cpp",
        "code": "// C++ program to swap two\n// numbers using 3rd variable\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Driver code\nint main()\n{\n    int a = 2, b = 3;\n\n    cout << \"Before swapping a = \" << a << \" , b = \" << b\n         << endl;\n\n    // temporary variable\n    int temp;\n\n    // appying swapping algorithm\n    temp = a;\n    a = b;\n    b = temp;\n    cout << \"After swapping a = \" << a << \" , b = \" << b\n         << endl;\n\n    return 0;\n}\n",
        "private_test": "SC_MODULE(Testbench) {\n    sc_signal<int> a_sig; // Signal for the first number\n    sc_signal<int> b_sig; // Signal for the second number\n    sc_signal<int> a_out_sig; // Signal for the first number after swap\n    sc_signal<int> b_out_sig; // Signal for the second number after swap\n\n    Swapper swapper_inst; // Instance of the Swapper module\n\n    // Constructor\n    SC_CTOR(Testbench) : swapper_inst(\"swapper\") {\n        // Connect signals to ports\n        swapper_inst.a_in(a_sig);\n        swapper_inst.b_in(b_sig);\n        swapper_inst.a_out(a_out_sig);\n        swapper_inst.b_out(b_out_sig);\n\n        // Process to run tests\n        SC_THREAD(run_tests);\n    }\n\n    // Thread to run test cases\n    void run_tests() {\n        // Initial values\n        a_sig = 2;\n        b_sig = 3;\n\n        // Wait for the swapper to process\n        wait(1, SC_NS);\n\n        // Print the values before and after swapping\n        cout << \"Before swapping a = \" << a_sig.read() << \" , b = \" << b_sig.read() << endl;\n        cout << \"After swapping a = \" << a_out_sig.read() << \" , b = \" << b_out_sig.read() << endl;\n\n        // Stop the simulation\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); // Create an instance of the Testbench\n\n    // Start the simulation\n    sc_start();\n\n    return 0;\n}\n",
        "module_name": "Swapper"
    },
    {
        "task_id": 19,
        "task": "FibonacciNumber.cpp",
        "code": "// C++ Program to find the nth fibonacci number using loops\n#include <bits/stdc++.h>\nusing namespace std;\n\nint fib(int n) {\n  \n      // For 0th and 1st term\n    if (n <= 1)\n        return n;\n    \n      // Variable to store the last two terms\n    int prev1 = 1, prev2 = 0;\n      \n      // Variable that stores the current fibonacci term\n      int curr;\n\n    // Calculating the next fibonacci number by using\n      // the previous two number\n    for (int i = 2; i <= n; i++) {\n        curr = prev1 + prev2;\n        prev2 = prev1;\n        prev1 = curr;\n    }\n    return curr;\n}\n\nint main() {\n    int n = 5;\n    \n      // Finding the nth fibonacci number\n    cout << fib(n);\n    return 0;\n}\n",
        "private_test": "SC_MODULE(Testbench) {\n    sc_signal<int> n_sig;          // Signal for the input position\n    sc_signal<int> result_sig;      // Signal for the output Fibonacci number\n\n    // Instance of the FibonacciCalculator module\n    FibonacciCalculator fib_inst;\n\n    // Constructor: Initialize the module and run the test thread\n    SC_CTOR(Testbench)\n    : fib_inst(\"fib_inst\") {\n        // Connect signals to module ports\n        fib_inst.n(n_sig);\n        fib_inst.result(result_sig);\n\n        // Create a test thread to provide stimulus and check the result\n        SC_THREAD(run_tests);\n    }\n\n    // Thread to run test cases\n    void run_tests() {\n        // Test case: n = 5 (expected Fibonacci number = 5)\n        n_sig.write(5);\n        wait(1, SC_NS); // Wait for the process to update\n        int result = result_sig.read();\n        std::cout << \"Fibonacci number at position \" << n_sig.read() << \" is \" << result << std::endl;\n        assert(result == 5);\n\n        // Additional test case: n = 10 (expected Fibonacci number = 55)\n        n_sig.write(10);\n        wait(1, SC_NS);\n        result = result_sig.read();\n        std::cout << \"Fibonacci number at position \" << n_sig.read() << \" is \" << result << std::endl;\n        assert(result == 55);\n\n        // End simulation after successful tests\n        std::cout << \"All tests passed successfully.\" << std::endl;\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); // Instantiate the testbench module\n    sc_start();         // Start the simulation\n    return 0;\n}\n",
        "module_name": "FibonacciCalculator"
    },
    {
        "task_id": 20,
        "task": "FindCommonArrayElements.cpp",
        "code": "// C++ program to find common elements between two Arrays using set_intersection()\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int arr1[] = {1, 45, 54, 71, 76, 12};\n    int arr2[] = {1, 7, 5, 4, 6, 12};\n\n    // Compute the sizes\n    int n1 = sizeof(arr1) / sizeof(arr1[0]);\n    int n2 = sizeof(arr2) / sizeof(arr2[0]);\n\n    // Sort the arrays\n    sort(arr1, arr1 + n1);\n    sort(arr2, arr2 + n2);\n\n    // Vector to store result\n    vector<int> v;\n    \n    // Finding common elements using\n    // set_intersection() function\n    set_intersection(arr1, arr1 + n1, arr2,\n        arr2 + n2, back_inserter(v));\n\n    for (auto i: v){\n        cout << i << \" \";\n    }\n    return 0;\n}\n",
        "private_test": "SC_MODULE(Testbench) {\n    sc_clock clk;          // Clock signal\n    sc_signal<bool> rst;   // Reset signal\n    sc_signal<sc_uint<32>> start; // Start signal\n    sc_signal<sc_uint<32>> done;  // Done signal\n    sc_signal<sc_uint<32>> result; // Result signal\n\n    CommonElementsFinder finder_inst; // Instance of the CommonElementsFinder module\n\n    // Constructor\n    SC_CTOR(Testbench) : clk(\"clk\", 10, SC_NS, 0.5), finder_inst(\"finder_inst\") {\n        // Connect signals to ports\n        finder_inst.clk(clk);\n        finder_inst.rst(rst);\n        finder_inst.start(start);\n        finder_inst.done(done);\n        finder_inst.result(result);\n\n        // Process to run tests\n        SC_THREAD(run_tests);\n    }\n\n    // Thread to run test cases\n    void run_tests() {\n        // Reset the system\n        rst = 1;\n        start = 0;\n        wait(2, SC_NS);\n        rst = 0;\n        wait(2, SC_NS);\n\n        // Start the process\n        start = 1;\n        wait(2, SC_NS);\n        start = 0;\n\n        // Wait until the process is done\n        while (!done) {\n            wait(2, SC_NS);\n        }\n\n        // Print the results\n        std::cout << \"Common elements: \";\n        while (result != 0) {\n            std::cout << result << \" \";\n            wait(2, SC_NS);\n        }\n        std::cout << std::endl;\n\n        // End simulation\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); // Create an instance of the Testbench\n\n    // Start the simulation\n    sc_start();\n\n    return 0;\n}\n",
        "module_name": "CommonElementsFinder"
    },
    {
        "task_id": 21,
        "task": "FindGCD.cpp",
        "code": "// C++ program to find GCD of two numbers using simple arithmetic\n#include <bits/stdc++.h>\nusing namespace std;\n\nint gcd(int a, int b) {\n    // Find Minimum of a and b\n    int res = min(a, b);\n\n      // Testing divisiblity with all numbers starting from\n    // min(a, b) to 1\n\n    while (res > 1) {\n\n        // If any number divide both a and b, so we\n        // got the answer\n        if (a % res == 0 && b % res == 0)\n            break;\n        res--;\n    }\n    return res;\n}\n\nint main() {\n    int a = 12, b = 16;\n  \n    // Finding gcd of two numbers a and b\n\n\n    cout << gcd(a, b);\n    return 0;\n}\n",
        "private_test": "SC_MODULE(Testbench) {\n    sc_signal<int> a_sig;       // Signal for the first input\n    sc_signal<int> b_sig;       // Signal for the second input\n    sc_signal<int> gcd_sig;     // Signal for the GCD output\n\n    // Instance of the GcdCalculator module\n    GcdCalculator gcd_inst;\n\n    // Constructor: Initialize the module and run the test thread\n    SC_CTOR(Testbench)\n    : gcd_inst(\"gcd_inst\") {\n        // Connect signals to module ports\n        gcd_inst.a(a_sig);\n        gcd_inst.b(b_sig);\n        gcd_inst.gcd_result(gcd_sig);\n\n        // Create a test thread to provide stimulus and check the result\n        SC_THREAD(run_tests);\n    }\n\n    // Thread to run test cases\n    void run_tests() {\n        // Test case: a = 12, b = 16 (expected GCD = 4)\n        a_sig.write(12);\n        b_sig.write(16);\n        wait(1, SC_NS); // Wait for the process to update\n        int result = gcd_sig.read();\n        std::cout << \"GCD(\" << a_sig.read() << \", \" << b_sig.read() << \") = \" << result << std::endl;\n        assert(result == 4);\n\n        // Additional test case: a = 48, b = 18 (expected GCD = 6)\n        a_sig.write(48);\n        b_sig.write(18);\n        wait(1, SC_NS);\n        result = gcd_sig.read();\n        std::cout << \"GCD(\" << a_sig.read() << \", \" << b_sig.read() << \") = \" << result << std::endl;\n        assert(result == 6);\n\n        // End simulation after successful tests\n        std::cout << \"All tests passed successfully.\" << std::endl;\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); // Instantiate the testbench module\n    sc_start();         // Start the simulation\n    return 0;\n}\n",
        "module_name": "GcdCalculator"
    },
    {
        "task_id": 22,
        "task": "CheckEvenorOddIntegers.cpp",
        "code": "// C++ program to check if the number is even or odd using modulo operator\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int n = 11;\n\n    // If n is completely divisible by 2\n    if (n % 2 == 0)\n        cout << \"Even\";\n\n    // If n is NOT completely divisible by 2\n    else\n        cout << \"Odd\";\n    return 0;\n}\n",
        "private_test": "SC_MODULE(Testbench) {\n    sc_signal<int> number_sig;       // Signal for the input number\n    sc_signal<sc_bv<4>> result_sig;  // Signal for the result (Even/Odd)\n\n    // Instance of the EvenOddChecker module\n    EvenOddChecker checker_inst;\n\n    // Constructor: Initialize the module and run the test thread\n    SC_CTOR(Testbench)\n    : checker_inst(\"checker_inst\") {\n        // Connect signals to module ports\n        checker_inst.number_in(number_sig);\n        checker_inst.result_out(result_sig);\n\n        // Create a test thread to provide stimulus and check the result\n        SC_THREAD(run_tests);\n    }\n\n    // Thread to run test cases\n    void run_tests() {\n        // Test case 1: Number is 11 (Odd)\n        number_sig.write(11);\n        wait(1, SC_NS); // Wait for the process to update\n        int result = result_sig.read().to_uint();\n        std::cout << \"Number: \" << number_sig.read() << \" is \" << (result == 0 ? \"Even\" : \"Odd\") << std::endl;\n        assert(result == 1);\n\n        // Test case 2: Number is 12 (Even)\n        number_sig.write(12);\n        wait(1, SC_NS); // Wait for the process to update\n        result = result_sig.read().to_uint();\n        std::cout << \"Number: \" << number_sig.read() << \" is \" << (result == 0 ? \"Even\" : \"Odd\") << std::endl;\n        assert(result == 0);\n\n        // End simulation after successful tests\n        std::cout << \"All tests passed successfully.\" << std::endl;\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); // Instantiate the testbench module\n    sc_start();         // Start the simulation\n    return 0;\n}\n",
        "module_name": "EvenOddChecker"
    },
    {
        "task_id": 23,
        "task": "DisplayPrimeNumbersBetweenTwoIntervalsUsingFunction.cpp",
        "code": "// C Program to Find Prime Numbers in a Given Range using Trial Division method\n#include <stdbool.h>\n#include <stdio.h>\n\nbool isPrime(int n) {\n\n    // Checking primality by finding a complete division\n      // in the range 2 to n-1\n    if (n <= 1)\n        return false;\n    for (int i = 2; i < n; i++) {\n        if (n % i == 0)\n            return false;\n    }\n    return true;\n}\n\nvoid findPrimes(int l, int r) {\n\n    // Flag to check if any prime numbers are found\n    bool found = false;\n    for (int i = l; i <= r; i++) {\n\n        // Checking if the number is prime\n        if (isPrime(i)) {\n            printf(\"%d \", i);\n            found = true;\n        }\n    }\n    if (!found) {\n        printf(\n            \"No prime numbers found in the given range.\");\n    }\n}\n\nint main() {\n    int l = 10, r = 30;\n    \n      // Finding and printing the prime between [l, r]\n    findPrimes(l, r);\n  \n    return 0;\n}\n",
        "private_test": "SC_MODULE(Testbench) {\n    sc_signal<int> lower_bound; // Signal for the lower bound of the range\n    sc_signal<int> upper_bound; // Signal for the upper bound of the range\n\n    PrimeFinder finder; // Instance of PrimeFinder module\n\n    // Constructor\n    SC_CTOR(Testbench)\n    : finder(\"finder\") {\n        // Connect signals to PrimeFinder ports\n        finder.lower_bound(lower_bound);\n        finder.upper_bound(upper_bound);\n\n        // Process to set the range and start the simulation\n        SC_THREAD(set_range);\n    }\n\n    // Thread to set the range\n    void set_range() {\n        lower_bound = 10;\n        upper_bound = 30;\n        wait(1, SC_NS); // Allow some time for PrimeFinder to process\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); // Create an instance of the Testbench\n\n    // Start the simulation\n    sc_start();\n\n    return 0;\n}\n",
        "module_name": "PrimeChecker"
    },
    {
        "task_id": 24,
        "task": "AddTwoComplexNumbers.cpp",
        "code": "// C++ Program to Add Two Complex Numbers\n\n// Importing all libraries\n#include<bits/stdc++.h>\nusing namespace std;\n\n// User Defined Complex class\nclass Complex \n{ \n\t// Declaring variables\n\tpublic: int real, imaginary;\n\n\t// Constructor to accept\n\t// real and imaginary part\n\tComplex(int tempReal = 0, \n\t\t\tint tempImaginary = 0)\n\t{\n\t\treal = tempReal;\n\t\timaginary = tempImaginary;\n\t}\n\n\t// Defining addComp() method\n\t// for adding two complex number\n\tComplex addComp(Complex C1, Complex C2)\n\t{\n\t\t// Creating temporary variable\n\t\tComplex temp;\n\n\t\t// Adding real part of \n\t\t// complex numbers\n\t\ttemp.real = C1.real + C2.real;\n\n\t\t// Adding Imaginary part of \n\t\t// complex numbers\n\t\ttemp.imaginary = (C1.imaginary + C2.imaginary);\n\n\t\t// Returning the sum\n\t\treturn temp;\n\t}\n};\n\n// Driver code\nint main()\n{\n\t// First Complex number\n\tComplex C1(3, 2);\n\n\t// printing first complex number\n\tcout << \"Complex number 1 : \" << \n\t\t\tC1.real << \" + i\" << \n\t\t\tC1.imaginary << endl;\n\n\t// Second Complex number\n\tComplex C2(9, 5);\n\n\t// Printing second complex number\n\tcout << \"Complex number 2 : \" << \n\t\t\tC2.real << \" + i\" << \n\t\t\tC2.imaginary << endl;\n\n\t// For Storing the sum\n\tComplex C3;\n\n\t// Calling addComp() method\n\tC3 = C3.addComp(C1, C2);\n\n\t// Printing the sum\n\tcout << \"Sum of complex number : \" << \n\t\t\tC3.real << \" + i\" << \n\t\t\tC3.imaginary;\n}\n",
        "private_test": "SC_MODULE(Testbench) {\n    sc_signal<int> real1; // Signal for the real part of the first complex number\n    sc_signal<int> imag1; // Signal for the imaginary part of the first complex number\n    sc_signal<int> real2; // Signal for the real part of the second complex number\n    sc_signal<int> imag2; // Signal for the imaginary part of the second complex number\n    sc_signal<int> real_sum; // Signal for the real part of the sum\n    sc_signal<int> imag_sum; // Signal for the imaginary part of the sum\n\n    ComplexAdder adder_inst; // Instance of the ComplexAdder module\n\n    // Constructor\n    SC_CTOR(Testbench) : adder_inst(\"adder\") {\n        // Connect signals to ports\n        adder_inst.real1(real1);\n        adder_inst.imag1(imag1);\n        adder_inst.real2(real2);\n        adder_inst.imag2(imag2);\n        adder_inst.real_sum(real_sum);\n        adder_inst.imag_sum(imag_sum);\n\n        // Process to run tests\n        SC_THREAD(run_tests);\n    }\n\n    // Thread to run test cases\n    void run_tests() {\n        // Test case: Adding complex numbers (3 + 2i) and (9 + 5i)\n        real1 = 3; imag1 = 2;\n        real2 = 9; imag2 = 5;\n        wait(1, SC_NS); // Wait for the adder to process\n        cout << \"Complex number 1 : \" << real1.read() << \" + i\" << imag1.read() << endl;\n        cout << \"Complex number 2 : \" << real2.read() << \" + i\" << imag2.read() << endl;\n        cout << \"Sum of complex number : \" << real_sum.read() << \" + i\" << imag_sum.read() << endl;\n\n        sc_stop(); // Stop the simulation\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); // Create an instance of the Testbench\n\n    // Start the simulation\n    sc_start();\n\n    return 0;\n}\n",
        "module_name": "ComplexAdder"
    },
    {
        "task_id": 25,
        "task": "PrintPascalsTriangle.cpp",
        "code": "//  C++ code for Pascal's Triangle\n#include <iostream>\nusing namespace std;\n\n// See https://www.geeksforgeeks.org/space-and-time-efficient-binomial-coefficient/ \n// for details of this function\nint binomialCoeff(int n, int k);\n\n// Function to print first\n// n lines of Pascal's \n// Triangle\nvoid printPascal(int n)\n{\n    // Iterate through every line and\n    // print entries in it\n    for (int line = 0; line < n; line++)\n    {\n        // Every line has number of \n        // integers equal to line \n        // number\n        for (int i = 0; i <= line; i++)\n            cout <<\" \"<< binomialCoeff(line, i);\n        cout <<\"\\n\";\n    }\n}\n\n// See https://www.geeksforgeeks.org/space-and-time-efficient-binomial-coefficient/\n// for details of this function\nint binomialCoeff(int n, int k)\n{\n    int res = 1;\n    if (k > n - k)\n    k = n - k;\n    for (int i = 0; i < k; ++i)\n    {\n        res *= (n - i);\n        res /= (i + 1);\n    }\n    \n    return res;\n}\n\n// Driver program \nint main()\n{\n    int n = 7;\n    printPascal(n);\n    return 0;\n}\n",
        "private_test": "SC_MODULE(Testbench) {\n    sc_signal<int> num_rows_sig; // Signal for the number of rows\n    sc_signal<int> coeff_sig;    // Signal for the binomial coefficient\n    sc_signal<bool> done_sig;    // Signal to indicate completion\n\n    PascalsTrianglePrinter printer_inst; // Instance of the PascalsTrianglePrinter module\n\n    // Constructor\n    SC_CTOR(Testbench)\n        : printer_inst(\"printer_inst\") {\n        // Connect signals to ports\n        printer_inst.num_rows(num_rows_sig);\n        printer_inst.coeff(coeff_sig);\n        printer_inst.done(done_sig);\n\n        // Process to run the test\n        SC_THREAD(run_test);\n    }\n\n    // Thread to run the test\n    void run_test() {\n        num_rows_sig.write(7); // Set the number of rows to 7\n        wait(done_sig.posedge_event()); // Wait until the printer is done\n        cout << \"Pascal's Triangle printed successfully.\" << endl;\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); // Create an instance of the Testbench\n\n    // Start the simulation\n    sc_start();\n\n    return 0;\n}\n",
        "module_name": "BinomialCoefficient"
    },
    {
        "task_id": 26,
        "task": "Sortthe2DArrayAcrossRows.cpp",
        "code": "// C++ code to \n// sort 2D matrix row-wise\n#include<bits/stdc++.h>\nusing namespace std;\n\n//Swap function \nvoid swap(int *xp, int *yp) \n{ \n\tint temp = *xp; \n\t*xp = *yp; \n\t*yp = temp; \n} \nvoid sortRowWise(int m[][4],\n\t\t\t\tint r, int c)\n{\n// loop for rows of matrix\nfor (int i = 0; i < r; i++) \n{\n\t// loop for column of matrix\n\tfor (int j = 0; j < c; j++) \n\t{\n\t// loop for comparison and swapping\n\tfor (int k = 0; k < c - j - 1; k++) \n\t{\n\t\tif (m[i][k] > m[i][k + 1]) \n\t\t{\n\t\t// swapping of elements\n\t\tswap(m[i][k], m[i][k + 1]);\n\t\t}\n\t}\n\t}\n}\n\n// printing the sorted matrix\nfor (int i = 0; i < r; i++) \n{\n\tfor (int j = 0; j < c; j++)\n\tcout << m[i][j] << \" \";\n\tcout << endl;\n}\n}\n\n// Driver code\nint main()\n{\nint m[][4] = {{9, 8, 7, 1},\n\t\t\t\t{7, 3, 0, 2},\n\t\t\t\t{9, 5, 3, 2},\n\t\t\t\t{6, 3, 1, 2}};\nint c = sizeof(m[0]) / sizeof(m[0][0]);\nint r = sizeof(m) / sizeof(m[0]);\nsortRowWise(m, r, c);\nreturn 0;\n}\n\n// This code is contributed by Rutvik_56\n",
        "private_test": "SC_MODULE(Testbench) {\n    sc_clock clk;             // Clock signal\n    sc_signal<bool> reset;    // Reset signal\n    sc_signal<sc_uint<32>> start; // Start signal\n    sc_signal<sc_uint<32>> done;  // Done signal\n\n    MatrixSorter sorter_inst; // Instance of the MatrixSorter module\n\n    // Constructor\n    SC_CTOR(Testbench) : clk(\"clk\", 10, SC_NS), sorter_inst(\"sorter\") {\n        // Connect signals to ports\n        sorter_inst.clk(clk);\n        sorter_inst.reset(reset);\n        sorter_inst.start(start);\n        sorter_inst.done(done);\n\n        // Process to run tests\n        SC_THREAD(run_tests);\n    }\n\n    // Thread to run test cases\n    void run_tests() {\n        // Reset the system\n        reset.write(1);\n        wait(2, SC_NS);\n        reset.write(0);\n\n        // Start the sorting process\n        start.write(1);\n        wait(1, SC_NS);\n        start.write(0);\n\n        // Wait for sorting to complete\n        wait(done.posedge_event());\n\n        // Print success message\n        cout << \"Matrix sorted successfully.\" << endl;\n\n        // Stop the simulation\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); // Create an instance of the Testbench\n\n    // Start the simulation\n    sc_start();\n\n    return 0;\n}\n",
        "module_name": "MatrixSorter"
    },
    {
        "task_id": 27,
        "task": "FindFactorialofaNumber.cpp",
        "code": "// C++ program for factorial of a number\n#include <iostream>\nusing namespace std;\n\n// Function to find factorial of\n// given number\nunsigned int factorial(unsigned int n)\n{\n\tint res = 1, i;\n\tfor (i = 2; i <= n; i++)\n\t\tres *= i;\n\treturn res;\n}\n\n// Driver code\nint main()\n{\n\tint num = 5;\n\tcout << \"Factorial of \" << num << \" is \"\n\t\t<< factorial(num) << endl;\n\treturn 0;\n}\n",
        "private_test": "SC_MODULE(Testbench) {\n    sc_signal<unsigned int> num_sig; // Signal for the number\n    sc_signal<unsigned int> fact_sig; // Signal for the factorial\n\n    FactorialCalculator fact_inst; // Instance of the FactorialCalculator module\n\n    // Constructor\n    SC_CTOR(Testbench) : fact_inst(\"fact_inst\") {\n        // Connect signals to ports\n        fact_inst.num_in(num_sig);\n        fact_inst.fact_out(fact_sig);\n\n        // Process to run tests\n        SC_THREAD(run_tests);\n    }\n\n    // Thread to run test cases\n    void run_tests() {\n        // Set the number to compute factorial\n        num_sig.write(5);\n        wait(1, SC_NS); // Wait for the process to update\n        unsigned int result = fact_sig.read();\n        cout << \"Factorial of \" << num_sig.read() << \" is \" << result << endl;\n\n        // End simulation after successful test\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); // Instantiate the testbench module\n    sc_start();         // Start the simulation\n    return 0;\n}\n",
        "module_name": "FactorialCalculator"
    },
    {
        "task_id": 28,
        "task": "CalculateFahrenheittoCelsius.cpp",
        "code": "// C++ program to convert Fahrenheit scale to Celsius scale\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to convert Fahrenheit \n// to Celsius\nfloat Conversion(float n)\n{\n\treturn (n - 32.0) * 5.0 / 9.0;\n}\n\n// Driver code\nint main()\n{\n\tfloat n = 40;\n\tcout << Conversion(n);\n\treturn 0;\n}\n",
        "private_test": "SC_MODULE(Testbench) {\n    sc_signal<float> fahrenheit; // Signal for Fahrenheit temperature\n    sc_signal<float> celsius;    // Signal for Celsius temperature\n\n    TempConverter converter_inst; // Instance of the TempConverter module\n\n    // Constructor\n    SC_CTOR(Testbench) : converter_inst(\"converter\") {\n        // Connect signals to ports\n        converter_inst.fahrenheit(fahrenheit);\n        converter_inst.celsius(celsius);\n\n        // Process to run tests\n        SC_THREAD(run_tests);\n    }\n\n    // Thread to run test cases\n    void run_tests() {\n        // Test case 1: Convert 40\u00b0F to Celsius\n        fahrenheit = 40.0;\n        wait(1, SC_NS); // Wait for the converter to process\n        float result = celsius.read();\n        cout << \"40\u00b0F in Celsius: \" << result << \"\u00b0C\" << endl;\n        assert(abs(result - 4.44444) < 0.0001); // Allow for floating-point precision errors\n\n        // Test case 2: Convert 100\u00b0F to Celsius\n        fahrenheit = 100.0;\n        wait(1, SC_NS);\n        result = celsius.read();\n        cout << \"100\u00b0F in Celsius: \" << result << \"\u00b0C\" << endl;\n        assert(abs(result - 37.7778) < 0.0001);\n\n        // Test case 3: Convert 32\u00b0F to Celsius (Freezing point of water)\n        fahrenheit = 32.0;\n        wait(1, SC_NS);\n        result = celsius.read();\n        cout << \"32\u00b0F in Celsius: \" << result << \"\u00b0C\" << endl;\n        assert(abs(result - 0.0) < 0.0001);\n\n        // Test case 4: Convert 212\u00b0F to Celsius (Boiling point of water)\n        fahrenheit = 212.0;\n        wait(1, SC_NS);\n        result = celsius.read();\n        cout << \"212\u00b0F in Celsius: \" << result << \"\u00b0C\" << endl;\n        assert(abs(result - 100.0) < 0.0001);\n\n        // Print success message\n        cout << \"All tests passed successfully.\" << endl;\n\n        // User interaction simulation\n        fahrenheit = 68.0; // Example user input\n        wait(1, SC_NS);\n        cout << \"68\u00b0F in Celsius: \" << celsius.read() << \"\u00b0C\" << endl;\n\n        sc_stop(); // Stop the simulation\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); // Create an instance of the Testbench\n\n    // Start the simulation\n    sc_start();\n\n    return 0;\n}\n",
        "module_name": "TempConverter"
    },
    {
        "task_id": 29,
        "task": "RotateMatrixElementsofaMatrix.cpp",
        "code": "// C++ program to rotate a matrix \n#include <iostream> \n#define R 4 \n#define C 4 \nusing namespace std; \n\n// A function to rotate a matrix \n// mat[][] of size R x C. \n// Initially, m = R and n = C \nvoid rotatematrix(int m, int n, \n\t\t\t\tint mat[R][C]) \n{ \n\tint row = 0, col = 0; \n\tint prev, curr; \n\n\t/* row - Starting row index \n\tm - ending row index \n\tcol - starting column index \n\tn - ending column index \n\ti - iterator */\n\twhile (row < m && col < n) \n\t{ \n\t\tif (row + 1 == m || \n\t\t\tcol + 1 == n) \n\t\t\tbreak; \n\n\t\t// Store the first element of \n\t\t// next row, this element will \n\t\t// replace first element of current \n\t\t// row \n\t\tprev = mat[row + 1][col]; \n\n\t\t/* Move elements of first row from \n\t\tthe remaining rows */\n\t\tfor (int i = col; i < n; i++) \n\t\t{ \n\t\t\tcurr = mat[row][i]; \n\t\t\tmat[row][i] = prev; \n\t\t\tprev = curr; \n\t\t} \n\t\trow++; \n\n\t\t/* Move elements of last column \n\t\tfrom the remaining columns */\n\t\tfor (int i = row; i < m; i++) \n\t\t{ \n\t\t\tcurr = mat[i][n-1]; \n\t\t\tmat[i][n-1] = prev; \n\t\t\tprev = curr; \n\t\t} \n\t\tn--; \n\n\t\t/* Move elements of last row from \n\t\tthe remaining rows */\n\t\tif (row < m) \n\t\t{ \n\t\t\tfor (int i = n-1; i >= col; i--) \n\t\t\t{ \n\t\t\t\tcurr = mat[m-1][i]; \n\t\t\t\tmat[m-1][i] = prev; \n\t\t\t\tprev = curr; \n\t\t\t} \n\t\t} \n\t\tm--; \n\n\t\t/* Move elements of first column from \n\t\tthe remaining rows */\n\t\tif (col < n) \n\t\t{ \n\t\t\tfor (int i = m-1; i >= row; i--) \n\t\t\t{ \n\t\t\t\tcurr = mat[i][col]; \n\t\t\t\tmat[i][col] = prev; \n\t\t\t\tprev = curr; \n\t\t\t} \n\t\t} \n\t\tcol++; \n\t} \n\n\t// Print rotated matrix \n\tfor (int i=0; i<R; i++) \n\t{ \n\t\tfor (int j=0; j<C; j++) \n\t\tcout << mat[i][j] << \" \"; \n\t\tcout << endl; \n\t} \n} \n\n// Driver code \nint main() \n{ \n\t// Test Case 1 \n\tint a[R][C] = {{1, 2, 3, 4}, \n\t\t\t\t{5, 6, 7, 8}, \n\t\t\t\t{9, 10, 11, 12}, \n\t\t\t\t{13, 14, 15, 16}}; \n\n\t// Test Case 2 \n\t/* int a[R][C] = {{1, 2, 3}, \n\t\t\t\t\t{4, 5, 6}, \n\t\t\t\t\t{7, 8, 9}}; \n\t*/ rotatematrix(R, C, a); \n\treturn 0; \n} \n",
        "private_test": "SC_MODULE(Testbench) {\n    sc_clock clk;             // Clock signal\n    sc_signal<bool> rst;      // Reset signal\n    sc_signal<bool> start;    // Start signal\n    sc_signal<bool> done;     // Done signal\n    sc_signal<int> rotated_mat[R][C]; // Signals for the rotated matrix\n\n    MatrixRotator rotator_inst; // Instance of the MatrixRotator module\n\n    // Constructor\n    SC_CTOR(Testbench) : clk(\"clk\", 10, SC_NS, 0.5), rotator_inst(\"rotator\") {\n        // Connect signals to ports\n        rotator_inst.clk(clk);\n        rotator_inst.rst(rst);\n        rotator_inst.start(start);\n        rotator_inst.done(done);\n        for (int i = 0; i < R; i++) {\n            for (int j = 0; j < C; j++) {\n                rotator_inst.rotated_mat[i][j](rotated_mat[i][j]);\n            }\n        }\n\n        // Process to run tests\n        SC_THREAD(run_tests);\n    }\n\n    // Thread to run test cases\n    void run_tests() {\n        // Initialize matrix values\n        for (int i = 0; i < R; i++) {\n            for (int j = 0; j < C; j++) {\n                rotated_mat[i][j].write(i * C + j + 1);\n            }\n        }\n\n        // Reset the system\n        rst.write(true);\n        wait(1, SC_NS);\n        rst.write(false);\n\n        // Start the rotation\n        start.write(true);\n        wait(1, SC_NS);\n        start.write(false);\n\n        // Wait for the rotation to complete\n        while (!done.read()) {\n            wait(1, SC_NS);\n        }\n\n        // Print the rotated matrix\n        std::cout << \"Rotated Matrix:\" << std::endl;\n        for (int i = 0; i < R; i++) {\n            for (int j = 0; j < C; j++) {\n                std::cout << rotated_mat[i][j].read() << \" \";\n            }\n            std::cout << std::endl;\n        }\n\n        // Stop the simulation\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); // Create an instance of the Testbench\n\n    // Start the simulation\n    sc_start();\n\n    return 0;\n}\n",
        "module_name": "MatrixRotator"
    },
    {
        "task_id": 30,
        "task": "SortanArray_BubbleSort.cpp",
        "code": "// C program for implementation of Bubble sort\n#include <stdio.h>\n\nvoid swap(int* arr, int i, int j) {\n    int temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n}\n\nvoid bubbleSort(int arr[], int n) {\n    for (int i = 0; i < n - 1; i++) {\n      \n        // Last i elements are already in place, so the loop\n        // will only num n - i - 1 times\n        for (int j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[j + 1])\n                swap(arr, j, j + 1);\n        }\n    }\n}\n\nint main() {\n    int arr[] = { 6, 0, 3, 5 };\n    int n = sizeof(arr) / sizeof(arr[0]);\n\n    // Calling bubble sort on array arr\n    bubbleSort(arr, n);\n\n    for (int i = 0; i < n; i++)\n        printf(\"%d \", arr[i]);\n\n    return 0;\n}\n",
        "private_test": "SC_MODULE(Testbench) {\n    sc_clock clk;                 // Clock signal\n    sc_signal<bool> rst;          // Reset signal\n    sc_signal<sc_uint<8>> arr_size;// Size of the array\n    sc_signal<sc_uint<8>> arr[4];  // Array to be sorted (fixed size for simplicity)\n    sc_signal<bool> done;          // Done signal indicating sorting completion\n\n    BubbleSortModule bubble_sort_inst; // Instance of the BubbleSortModule\n\n    // Constructor\n    SC_CTOR(Testbench)\n    : bubble_sort_inst(\"bubble_sort_inst\"), clk(\"clk\", 10, SC_NS, 0.5, 0, SC_NS, true) {\n        // Connect signals to ports\n        bubble_sort_inst.clk(clk);\n        bubble_sort_inst.rst(rst);\n        bubble_sort_inst.arr_size(arr_size);\n        for (int k = 0; k < 4; k++) {\n            bubble_sort_inst.arr[k](arr[k]);\n        }\n        bubble_sort_inst.done(done);\n\n        // Process to run tests\n        SC_THREAD(run_tests);\n    }\n\n    // Thread to run test cases\n    void run_tests() {\n        // Initialize array\n        arr[0].write(6);\n        arr[1].write(0);\n        arr[2].write(3);\n        arr[3].write(5);\n        arr_size.write(4);\n\n        // Assert reset\n        rst.write(true);\n        wait(1, SC_NS);\n        rst.write(false);\n        wait(1, SC_NS);\n\n        // Wait for sorting to complete\n        while (!done.read()) {\n            wait(1, SC_NS);\n        }\n\n        // Print sorted array\n        for (int k = 0; k < 4; k++) {\n            std::cout << arr[k].read() << \" \";\n        }\n        std::cout << std::endl;\n\n        // Stop simulation\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); // Create an instance of the Testbench\n\n    // Start the simulation\n    sc_start();\n\n    return 0;\n}\n",
        "module_name": "BubbleSortModule"
    },
    {
        "task_id": 31,
        "task": "FindtheRootsoftheQuadraticEquation.cpp",
        "code": "// C++ program to find roots of\n// a quadratic equation\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Prints roots of quadratic equation\n// ax*2 + bx + x\nvoid findRoots(int a, int b, int c)\n{\n    // If a is 0, then equation is\n    // not quadratic, but linear\n    if (a == 0) {\n        cout << \"Invalid\";\n        return;\n    }\n\n    int d = b * b - 4 * a * c;\n    double sqrt_val = sqrt(abs(d));\n\n    if (d > 0) {\n        cout << \"Roots are real and different \";\n        cout << (double)(-b + sqrt_val) / (2 * a) << \" \"\n             << (double)(-b - sqrt_val) / (2 * a);\n    }\n    else if (d == 0) {\n        cout << \"Roots are real and same \";\n        cout << -(double)b / (2 * a);\n    }\n\n    // d < 0\n    else {\n        cout << \"Roots are complex \";\n        cout << -(double)b / (2 * a) << \" + i\"\n             << sqrt_val / (2 * a) << \" \"\n             << -(double)b / (2 * a) << \" - i\"\n             << sqrt_val / (2 * a);\n    }\n}\n\n// Driver code\nint main()\n{\n    int a = 1, b = -7, c = 12;\n\n    // Function call\n    findRoots(a, b, c);\n    return 0;\n}\n",
        "private_test": "SC_MODULE(Testbench) {\n    sc_signal<int> a_sig; // Signal for coefficient a\n    sc_signal<int> b_sig; // Signal for coefficient b\n    sc_signal<int> c_sig; // Signal for coefficient c\n    sc_signal<sc_bv<64>> roots_sig; // Signal for roots\n\n    // Instance of the QuadraticSolver module\n    QuadraticSolver solver_inst;\n\n    // Constructor\n    SC_CTOR(Testbench)\n    : solver_inst(\"solver\") {\n        // Connect signals to module ports\n        solver_inst.a(a_sig);\n        solver_inst.b(b_sig);\n        solver_inst.c(c_sig);\n        solver_inst.roots(roots_sig);\n\n        // Create a test thread to provide stimulus and check the result\n        SC_THREAD(run_tests);\n    }\n\n    // Thread to run test cases\n    void run_tests() {\n        // Test case 1: a = 1, b = -7, c = 12\n        a_sig.write(1);\n        b_sig.write(-7);\n        c_sig.write(12);\n        wait(1, SC_NS); // Wait for the process to update\n        sc_bv<64> result = roots_sig.read();\n        std::cout << \"Roots: \" << result.to_string() << std::endl;\n\n        // Additional test cases can be added here\n        // For example:\n        // a_sig.write(1);\n        // b_sig.write(2);\n        // c_sig.write(1);\n        // wait(1, SC_NS);\n        // result = roots_sig.read();\n        // std::cout << \"Roots: \" << result.to_string() << std::endl;\n\n        // End simulation after successful test\n        std::cout << \"Test completed successfully.\" << std::endl;\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); // Instantiate the testbench module\n    sc_start();         // Start the simulation\n    return 0;\n}\n",
        "module_name": "QuadraticSolver"
    },
    {
        "task_id": 32,
        "task": "BinarytoDecimalConversion.cpp",
        "code": "// C++ program to convert binary to decimal \n#include <iostream> \nusing namespace std; \n\n// Function to convert binary \n// to decimal \nint binaryToDecimal(int n) \n{ \n\tint num = n; \n\tint dec_value = 0; \n\n\t// Initializing base value to \n\t// 1, i.e 2^0 \n\tint base = 1; \n\n\tint temp = num; \n\twhile (temp) { \n\t\tint last_digit = temp % 10; \n\t\ttemp = temp / 10; \n\t\tdec_value += last_digit * base; \n\t\tbase = base * 2; \n\t} \n\n\treturn dec_value; \n} \n\n// Driver code \nint main() \n{ \n\tint num = 10101001; \n\tcout << binaryToDecimal(num) << endl; \n}\n",
        "private_test": "SC_MODULE(Testbench) {\n    sc_signal<int> binary_sig; // Signal for the binary number\n    sc_signal<int> decimal_sig; // Signal for the decimal number\n\n    BinaryToDecimalConverter converter_inst; // Instance of the converter module\n\n    // Constructor\n    SC_CTOR(Testbench) : converter_inst(\"converter\") {\n        // Connect signals to ports\n        converter_inst.binary_in(binary_sig);\n        converter_inst.decimal_out(decimal_sig);\n\n        // Process to run tests\n        SC_THREAD(run_tests);\n    }\n\n    // Thread to run test cases\n    void run_tests() {\n        // Test case 1: Convert binary 10101001 to decimal\n        binary_sig = 10101001;\n        wait(1, SC_NS); // Wait for the conversion to process\n        int result = decimal_sig.read();\n        cout << \"Binary: 10101001 -> Decimal: \" << result << endl;\n        assert(result == 177);\n\n        // Test case 2: Convert binary 1111 to decimal\n        binary_sig = 1111;\n        wait(1, SC_NS);\n        result = decimal_sig.read();\n        cout << \"Binary: 1111 -> Decimal: \" << result << endl;\n        assert(result == 15);\n\n        // Test case 3: Convert binary 100000 to decimal\n        binary_sig = 100000;\n        wait(1, SC_NS);\n        result = decimal_sig.read();\n        cout << \"Binary: 100000 -> Decimal: \" << result << endl;\n        assert(result == 32);\n\n        // Print success message\n        cout << \"All tests passed successfully.\" << endl;\n\n        sc_stop(); // Stop the simulation\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); // Create an instance of the Testbench\n\n    // Start the simulation\n    sc_start();\n\n    return 0;\n}\n",
        "module_name": "BinaryToDecimalConverter"
    },
    {
        "task_id": 33,
        "task": "SortanArray_SelectionSort.cpp",
        "code": "// C++ program for implementation of \n// selection sort \n#include <bits/stdc++.h> \nusing namespace std; \n\n//Swap function \nvoid swap(int *xp, int *yp) \n{ \n\tint temp = *xp; \n\t*xp = *yp; \n\t*yp = temp; \n} \n\nvoid selectionSort(int arr[], int n) \n{ \n\tint i, j, min_idx; \n\n\t// One by one move boundary of \n\t// unsorted subarray \n\tfor (i = 0; i < n-1; i++) \n\t{ \n\t\t\n\t\t// Find the minimum element in \n\t\t// unsorted array \n\t\tmin_idx = i; \n\t\tfor (j = i+1; j < n; j++) \n\t\tif (arr[j] < arr[min_idx]) \n\t\t\tmin_idx = j; \n\n\t\t// Swap the found minimum element \n\t\t// with the first element \n\t\tswap(&arr[min_idx], &arr[i]); \n\t} \n} \n\n//Function to print an array \nvoid printArray(int arr[], int size) \n{ \n\tint i; \n\tfor (i=0; i < size; i++) \n\t\tcout << arr[i] << \" \"; \n\tcout << endl; \n} \n\n// Driver program to test above functions \nint main() \n{ \n\tint arr[] = {64, 25, 12, 22, 11}; \n\tint n = sizeof(arr)/sizeof(arr[0]); \n\tselectionSort(arr, n); \n\tcout << \"Sorted array: \"; \n\tprintArray(arr, n); \n\treturn 0; \n} \n",
        "private_test": "SC_MODULE(Testbench) {\n    sc_signal<bool> clk;          // Clock signal\n    sc_signal<bool> reset;        // Reset signal\n    sc_vector<sc_signal<int>> input;// Input vector of integers\n    sc_vector<sc_signal<int>> output;// Output vector of integers\n    sc_signal<bool> done;         // Done signal indicating sorting completion\n\n    SelectionSortModule sorter;   // Instance of the SelectionSortModule\n\n    // Constructor\n    SC_CTOR(Testbench) : sorter(\"sorter\"), input(\"input\", 10), output(\"output\", 10) {\n        // Connect signals to ports\n        sorter.clk(clk);\n        sorter.reset(reset);\n        sorter.done(done);\n        for (int i = 0; i < 10; ++i) {\n            sorter.input[i](input[i]);\n            sorter.output[i](output[i]);\n        }\n\n        // Process to run tests\n        SC_THREAD(run_tests);\n        SC_METHOD(print_output);\n        sensitive << done.posedge_event();\n    }\n\n    // Thread to run test cases\n    void run_tests() {\n        // Initialize the array with some values\n        int arr[] = {64, 25, 12, 22, 11};\n        n = sizeof(arr) / sizeof(arr[0]);\n\n        // Apply reset\n        reset = true;\n        wait(1, SC_NS);\n        reset = false;\n        wait(1, SC_NS);\n\n        // Write input values to the sorter\n        for (int i = 0; i < n; ++i) {\n            input[i] = arr[i];\n        }\n\n        // Wait for sorting to complete\n        while (!done.read()) {\n            clk = !clk;\n            wait(1, SC_NS);\n        }\n\n        // Print success message\n        cout << \"Sorting completed successfully.\" << endl;\n\n        // Stop the simulation\n        sc_stop();\n    }\n\n    // Method to print the output array\n    void print_output() {\n        cout << \"Sorted array: \";\n        for (int i = 0; i < n; ++i) {\n            cout << output[i].read() << \" \";\n        }\n        cout << endl;\n    }\n\n    int n; // Size of the array\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); // Create an instance of the Testbench\n\n    // Start the simulation\n    sc_start();\n\n    return 0;\n}\n",
        "module_name": "SelectionSortModule"
    },
    {
        "task_id": 34,
        "task": "FindQuotientandRemainder.cpp",
        "code": "// C++ program to find quotient\n// and remainder\n#include <iostream>\nusing namespace std;\n\n// Driver code\nint main()\n{\n    int Dividend, Quotient, Divisor, Remainder;\n\n    cout << \"Enter Dividend & Divisor: \";\n    cin >> Dividend >> Divisor;\n\n    // Check for division by zero\n    if (Divisor == 0) {\n        cout << \"Error: Divisor cannot be zero.\" << endl;\n    } else {\n        Quotient = Dividend / Divisor;\n        Remainder = Dividend % Divisor;\n\n        cout << \"The Quotient = \" << Quotient << endl;\n        cout << \"The Remainder = \" << Remainder << endl;\n    }\n    return 0;\n}\n",
        "private_test": "SC_MODULE(Testbench) {\n    sc_signal<int> Dividend;   // Signal for the dividend\n    sc_signal<int> Divisor;    // Signal for the divisor\n    sc_signal<int> Quotient;   // Signal for the quotient\n    sc_signal<int> Remainder;  // Signal for the remainder\n    sc_signal<bool> Error;     // Signal to indicate division by zero error\n\n    Divider divider_inst;       // Instance of the Divider module\n\n    // Constructor\n    SC_CTOR(Testbench) : divider_inst(\"divider\") {\n        // Connect signals to ports\n        divider_inst.Dividend(Dividend);\n        divider_inst.Divisor(Divisor);\n        divider_inst.Quotient(Quotient);\n        divider_inst.Remainder(Remainder);\n        divider_inst.Error(Error);\n\n        // Process to run tests\n        SC_THREAD(run_tests);\n    }\n\n    // Thread to run test cases\n    void run_tests() {\n        // Test case 1: Division by zero\n        Dividend = 10;\n        Divisor = 0;\n        wait(1, SC_NS);\n        assert(Error.read() == true);\n        cout << \"Test Case 1: Division by zero - Error: \" << Error.read() << endl;\n\n        // Test case 2: Normal division\n        Dividend = 20;\n        Divisor = 3;\n        wait(1, SC_NS);\n        assert(Error.read() == false);\n        assert(Quotient.read() == 6);\n        assert(Remainder.read() == 2);\n        cout << \"Test Case 2: Quotient: \" << Quotient.read() << \", Remainder: \" << Remainder.read() << endl;\n\n        // Test case 3: Exact division\n        Dividend = 15;\n        Divisor = 5;\n        wait(1, SC_NS);\n        assert(Error.read() == false);\n        assert(Quotient.read() == 3);\n        assert(Remainder.read() == 0);\n        cout << \"Test Case 3: Quotient: \" << Quotient.read() << \", Remainder: \" << Remainder.read() << endl;\n\n        // Test case 4: Negative dividend\n        Dividend = -20;\n        Divisor = 3;\n        wait(1, SC_NS);\n        assert(Error.read() == false);\n        assert(Quotient.read() == -7);\n        assert(Remainder.read() == -2);\n        cout << \"Test Case 4: Quotient: \" << Quotient.read() << \", Remainder: \" << Remainder.read() << endl;\n\n        // Test case 5: Negative divisor\n        Dividend = 20;\n        Divisor = -3;\n        wait(1, SC_NS);\n        assert(Error.read() == false);\n        assert(Quotient.read() == -7);\n        assert(Remainder.read() == 1);\n        cout << \"Test Case 5: Quotient: \" << Quotient.read() << \", Remainder: \" << Remainder.read() << endl;\n\n        // Test case 6: Both negative\n        Dividend = -20;\n        Divisor = -3;\n        wait(1, SC_NS);\n        assert(Error.read() == false);\n        assert(Quotient.read() == 6);\n        assert(Remainder.read() == -2);\n        cout << \"Test Case 6: Quotient: \" << Quotient.read() << \", Remainder: \" << Remainder.read() << endl;\n\n        // Print success message\n        cout << \"All tests passed successfully.\" << endl;\n\n        sc_stop(); // Stop the simulation\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); // Create an instance of the Testbench\n\n    // Start the simulation\n    sc_start();\n\n    return 0;\n}\n",
        "module_name": "Divider"
    },
    {
        "task_id": 35,
        "task": "FindtheDeterminantofaMatrix.cpp",
        "code": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nconst int MAXN = 105;\ndouble a[MAXN][MAXN];\n\ndouble determinant(int n) {\n\tdouble det = 1.0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint pivot = i;\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tif (abs(a[j][i]) > abs(a[pivot][i])) {\n\t\t\t\tpivot = j;\n\t\t\t}\n\t\t}\n\t\tif (pivot != i) {\n\t\t\tswap(a[i], a[pivot]);\n\t\t\tdet *= -1;\n\t\t}\n\t\tif (a[i][i] == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tdet *= a[i][i];\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tdouble factor = a[j][i] / a[i][i];\n\t\t\tfor (int k = i + 1; k < n; k++) {\n\t\t\t\ta[j][k] -= factor * a[i][k];\n\t\t\t}\n\t\t}\n\t}\n\treturn det;\n}\n\nint main() {\n\tint n = 4;\n\tdouble matrix[4][4] = {{1, 0, 2, -1},\n\t\t\t\t\t\t{3, 0, 0, 5},\n\t\t\t\t\t\t{2, 1, 4, -3},\n\t\t\t\t\t\t{1, 0, 5, 0}};\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\ta[i][j] = matrix[i][j];\n\t\t}\n\t}\n\tdouble det = determinant(n);\n\tcout << \"Determinant = \" << det << endl;\n\treturn 0;\n}\n",
        "private_test": "SC_MODULE(Testbench) {\n    sc_signal<int> n_sig;                     // Signal for matrix size\n    sc_signal<double> matrix_sig[105][105];    // Signal for matrix elements\n    sc_signal<double> det_sig;                 // Signal for determinant output\n\n    MatrixDeterminant md_inst;                  // Instance of the MatrixDeterminant module\n\n    // Constructor: Initialize the module and run the test thread\n    SC_CTOR(Testbench)\n    : md_inst(\"md_inst\") {\n        // Connect signals to module ports\n        md_inst.n(n_sig);\n        for (int i = 0; i < 105; ++i) {\n            for (int j = 0; j < 105; ++j) {\n                md_inst.matrix[i][j](matrix_sig[i][j]);\n            }\n        }\n        md_inst.determinant(det_sig);\n\n        // Create a test thread to provide stimulus and check the result\n        SC_THREAD(run_tests);\n    }\n\n    // Thread to run test cases\n    void run_tests() {\n        // Set matrix size\n        n_sig.write(4);\n        // Set matrix elements\n        matrix_sig[0][0].write(1); matrix_sig[0][1].write(0); matrix_sig[0][2].write(2); matrix_sig[0][3].write(-1);\n        matrix_sig[1][0].write(3); matrix_sig[1][1].write(0); matrix_sig[1][2].write(0); matrix_sig[1][3].write(5);\n        matrix_sig[2][0].write(2); matrix_sig[2][1].write(1); matrix_sig[2][2].write(4); matrix_sig[2][3].write(-3);\n        matrix_sig[3][0].write(1); matrix_sig[3][1].write(0); matrix_sig[3][2].write(5); matrix_sig[3][3].write(0);\n\n        // Wait for the process to update\n        wait(1, SC_NS);\n\n        // Read and print the determinant\n        double result = det_sig.read();\n        std::cout << \"Determinant = \" << result << std::endl;\n\n        // End simulation after successful test\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); // Instantiate the testbench module\n    sc_start();         // Start the simulation\n    return 0;\n}\n",
        "module_name": "MatrixDeterminant"
    },
    {
        "task_id": 36,
        "task": "FindPowerWithoutUsingMultiplicationAndDivisionOperators.cpp",
        "code": "// C++ code for power function \n#include <bits/stdc++.h> \nusing namespace std; \n\n// Works only if a >= 0 \n// and b >= 0 \nint pow(int a, int b) \n{ \n\tif (b == 0) \n\t\treturn 1; \n\tint answer = a; \n\tint increment = a; \n\tint i, j; \n\tfor(i = 1; i < b; i++) \n\t{ \n\t\tfor(j = 1; j < a; j++) \n\t\t{ \n\t\t\tanswer += increment; \n\t\t} \n\t\tincrement = answer; \n\t} \n\treturn answer; \n} \n\n// Driver Code \nint main() \n{ \n\tcout << pow(5, 3); \n\treturn 0; \n} \n\n// This code is contributed by rathbhupendra \n",
        "private_test": "SC_MODULE(Testbench) {\n    sc_signal<int> base_sig;   // Signal for the base input\n    sc_signal<int> exp_sig;    // Signal for the exponent input\n    sc_signal<int> res_sig;    // Signal for the result output\n\n    // Instance of the PowerCalculator module\n    PowerCalculator power_inst;\n\n    // Constructor: Initialize the module and run the test thread\n    SC_CTOR(Testbench)\n    : power_inst(\"power_inst\") {\n        // Connect signals to module ports\n        power_inst.base(base_sig);\n        power_inst.exponent(exp_sig);\n        power_inst.result(res_sig);\n\n        // Create a test thread to provide stimulus and check the result\n        SC_THREAD(run_tests);\n    }\n\n    // Thread to run test cases\n    void run_tests() {\n        // Test case: base = 5, exponent = 3 (expected result = 125)\n        base_sig.write(5);\n        exp_sig.write(3);\n        wait(1, SC_NS); // Wait for the process to update\n        int result = res_sig.read();\n        std::cout << \"Power(\" << base_sig.read() << \", \" << exp_sig.read() << \") = \" << result << std::endl;\n        assert(result == 125);\n\n        // Test case: base = 2, exponent = 4 (expected result = 16)\n        base_sig.write(2);\n        exp_sig.write(4);\n        wait(1, SC_NS); // Wait for the process to update\n        result = res_sig.read();\n        std::cout << \"Power(\" << base_sig.read() << \", \" << exp_sig.read() << \") = \" << result << std::endl;\n        assert(result == 16);\n\n        // Test case: base = 3, exponent = 0 (expected result = 1)\n        base_sig.write(3);\n        exp_sig.write(0);\n        wait(1, SC_NS); // Wait for the process to update\n        result = res_sig.read();\n        std::cout << \"Power(\" << base_sig.read() << \", \" << exp_sig.read() << \") = \" << result << std::endl;\n        assert(result == 1);\n\n        // Test case: base = 0, exponent = 5 (expected result = 0)\n        base_sig.write(0);\n        exp_sig.write(5);\n        wait(1, SC_NS); // Wait for the process to update\n        result = res_sig.read();\n        std::cout << \"Power(\" << base_sig.read() << \", \" << exp_sig.read() << \") = \" << result << std::endl;\n        assert(result == 0);\n\n        // End simulation after successful tests\n        std::cout << \"All tests passed successfully.\" << std::endl;\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); // Instantiate the testbench module\n    sc_start();         // Start the simulation\n    return 0;\n}\n",
        "module_name": "PowerCalculator"
    },
    {
        "task_id": 37,
        "task": "SorttheElementsofanArrayinAscendingOrder.cpp",
        "code": "// C++ program to sort array \n// in ascending order using\n// Brute-force approach\n// using bubble sort\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid sort(int num[], int len);\nvoid swapNums(int nums[], \n\t\t\tint first, int second);\n\n// Driver code\nint main()\n{\n\t// Initializing arrya\n\tint nums[] = {1, 12, 6, 8, 10};\n\tint size_nums = (sizeof(nums) / \n\t\t\t\t\tsizeof(nums[0]));\n\n\tcout << \"Before sorting the array is: \\n\";\n\tfor (int i = 0; i < size_nums; i++)\n\t\tcout << nums[i] << \" \";\n\tcout << \"\\n\\n\";\n\n\tsort(nums, size_nums);\n\n\tcout << \"After sorting the array is: \\n\";\n\n\tfor (int i = 0; i < size_nums; i++)\n\t\tcout << nums[i] << \" \";\n\tcout << \"\\n\";\n\treturn 0;\n}\n\n// Sort function\nvoid sort(int num[], int len)\n{\n\tbool isSwapped;\n\n\t/**\n\t* Here we are running n-1 steps, \n\tfor each step, max item will \n\tcome at the last respective \n\tindex and swap element if the \n\telement is smaller than the \n\tprevious one.\n\t**/\n\tfor (int i = 0; i < len; i++) \n\t{\n\t\tisSwapped = false;\n\t\tfor (int j = 1; j < len - i; j++) \n\t\t{\n\t\t\tif (num[j] < num[j - 1]) \n\t\t\t{\n\t\t\t\tswapNums(num, j, (j - 1));\n\t\t\t\tisSwapped = true;\n\t\t\t}\n\t\t}\n\t\tif (!isSwapped) \n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n// Swaps two numbers in array\nvoid swapNums(int nums[], \n\t\t\tint first, int second)\n{\n\tint curr = nums[first];\n\tnums[first] = nums[second];\n\tnums[second] = curr;\n}\n",
        "private_test": "SC_MODULE(Testbench) {\n    sc_signal<int> size_sig; // Signal for the size of the array\n    sc_signal<sc_vector<sc_int<32>>> array_sig; // Signal for the array to be sorted\n    sc_signal<sc_vector<sc_int<32>>> sorted_array_sig; // Signal for the sorted array\n\n    // Instance of the BubbleSort module\n    BubbleSort bubble_sort_inst;\n\n    // Constructor\n    SC_CTOR(Testbench) : array_sig(\"array_sig\", 5), sorted_array_sig(\"sorted_array_sig\", 5), bubble_sort_inst(\"bubble_sort_inst\") {\n        // Connect signals to module ports\n        bubble_sort_inst.size_in(size_sig);\n        bubble_sort_inst.array_in(array_sig);\n        bubble_sort_inst.sorted_array_out(sorted_array_sig);\n\n        // Process to run tests\n        SC_THREAD(run_tests);\n    }\n\n    // Thread to run test cases\n    void run_tests() {\n        // Initialize array\n        int initial_array[] = {1, 12, 6, 8, 10};\n        size_sig.write(5);\n\n        // Write initial array to input signal\n        for (int i = 0; i < 5; ++i) {\n            array_sig[i].write(initial_array[i]);\n        }\n\n        // Wait for sorting to complete\n        wait(1, SC_NS);\n\n        // Read sorted array from output signal\n        cout << \"After sorting the array is: \\n\";\n        for (int i = 0; i < 5; ++i) {\n            cout << sorted_array_sig[i].read() << \" \";\n        }\n        cout << \"\\n\";\n\n        // End simulation after successful test\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); // Create an instance of the Testbench\n\n    // Start the simulation\n    sc_start();\n\n    return 0;\n}\n",
        "module_name": "BubbleSort"
    },
    {
        "task_id": 38,
        "task": "DecimaltoOctalConversion.cpp",
        "code": "// C++ program to convert a decimal number to octal number \n#include <iostream> \nusing namespace std; \n\n// Function to convert decimal to octal \nvoid decToOctal(int n) \n{ \n\t// Array to store octal number \n\tint octalNum[100]; \n\n\t// Counter for octal number array \n\tint i = 0; \n\twhile (n != 0) { \n\t\t// Storing remainder in octal array \n\t\toctalNum[i] = n % 8; \n\t\tn = n / 8; \n\t\ti++; \n\t} \n\n\t// Printing octal number array in \n\t// reverse order \n\tfor (int j = i - 1; j >= 0; j--) \n\t\tcout << octalNum[j]; \n} \n\n// Driver Code \nint main() \n{ \n\tint n = 33; \n\n\t// Function Call \n\tdecToOctal(n); \n\n\treturn 0; \n}\n",
        "private_test": "SC_MODULE(Testbench) {\n    sc_signal<int> decimal_in; // Signal for the decimal number\n    sc_signal<sc_bv<32>> octal_out; // Signal for the octal number\n\n    DecimalToOctalConverter converter_inst; // Instance of the converter module\n\n    // Constructor\n    SC_CTOR(Testbench) : converter_inst(\"converter\") {\n        // Connect signals to ports\n        converter_inst.decimal_in(decimal_in);\n        converter_inst.octal_out(octal_out);\n\n        // Process to run tests\n        SC_THREAD(run_tests);\n    }\n\n    // Thread to run test cases\n    void run_tests() {\n        // Test case 1: Convert 33 to octal\n        decimal_in = 33;\n        wait(1, SC_NS); // Wait for the conversion to process\n        std::cout << \"Decimal: \" << decimal_in.read() << \" -> Octal: \" << octal_out.read().to_string(SC_BIN).c_str() << std::endl;\n\n        // Additional test case: Convert 0 to octal\n        decimal_in = 0;\n        wait(1, SC_NS);\n        std::cout << \"Decimal: \" << decimal_in.read() << \" -> Octal: \" << octal_out.read().to_string(SC_BIN).c_str() << std::endl;\n\n        // Additional test case: Convert 255 to octal\n        decimal_in = 255;\n        wait(1, SC_NS);\n        std::cout << \"Decimal: \" << decimal_in.read() << \" -> Octal: \" << octal_out.read().to_string(SC_BIN).c_str() << std::endl;\n\n        // End simulation after running tests\n        std::cout << \"Tests completed.\" << std::endl;\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); // Create an instance of the Testbench\n\n    // Start the simulation\n    sc_start();\n\n    return 0;\n}\n",
        "module_name": "DecimalToOctalConverter"
    },
    {
        "task_id": 39,
        "task": "RemoveLeadingZeros.cpp",
        "code": "// C++ program to remove leading zeros \n// from a given string \n#include <iostream> \n\nusing namespace std; \n\nstring removeZero(string str) \n{ \n\t// Count leading zeros \n\tint i = 0; \n\twhile (str[i] == '0') \n\t\ti++; \n\n\t// The erase function removes i characters \n\t// from given index (0 here) \n\tstr.erase(0, i); \n\n\treturn str; \n} \n\n// Driver code \nint main() \n{ \n\tstring str; \n\tstr = \"00000123569\"; \n\tstr = removeZero(str); \n\tcout << str << endl; \n\treturn 0; \n}\n",
        "private_test": "SC_MODULE(Testbench) {\n    sc_signal<std::string> input_str;  // Signal for the input string\n    sc_signal<std::string> output_str; // Signal for the output string\n\n    RemoveLeadingZeros rlz_inst; // Instance of the RemoveLeadingZeros module\n\n    // Constructor\n    SC_CTOR(Testbench) : rlz_inst(\"rlz_inst\") {\n        // Connect signals to ports\n        rlz_inst.input_str(input_str);\n        rlz_inst.output_str(output_str);\n\n        // Process to run tests\n        SC_THREAD(run_tests);\n    }\n\n    // Thread to run test cases\n    void run_tests() {\n        // Test case 1\n        input_str.write(\"00000123569\");\n        wait(1, SC_NS); // Wait for the module to process\n        std::cout << \"Modified String: \" << output_str.read() << std::endl;\n        assert(output_str.read() == \"123569\");\n\n        // Test case 2\n        input_str.write(\"00000000000\");\n        wait(1, SC_NS);\n        std::cout << \"Modified String: \" << output_str.read() << std::endl;\n        assert(output_str.read() == \"\");\n\n        // Test case 3\n        input_str.write(\"123456789\");\n        wait(1, SC_NS);\n        std::cout << \"Modified String: \" << output_str.read() << std::endl;\n        assert(output_str.read() == \"123456789\");\n\n        // Test case 4\n        input_str.write(\"000000000001\");\n        wait(1, SC_NS);\n        std::cout << \"Modified String: \" << output_str.read() << std::endl;\n        assert(output_str.read() == \"1\");\n\n        // Print success message\n        std::cout << \"All tests passed successfully.\" << std::endl;\n\n        sc_stop(); // Stop the simulation\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); // Create an instance of the Testbench\n\n    // Start the simulation\n    sc_start();\n\n    return 0;\n}\n",
        "module_name": "RemoveLeadingZeros"
    },
    {
        "task_id": 40,
        "task": "NumberofUniqueTripletsWhoseXORisZero.cpp",
        "code": "// CPP program to count the number of\n// unique triplets whose XOR is 0\n#include <bits/stdc++.h>\nusing namespace std;\n\n// function to count the number of \n// unique triplets whose xor is 0\nint countTriplets(int a[], int n) \n{\n\t// To store values that are present\n\tunordered_set<int> s;\n\tfor (int i = 0; i < n; i++)\n\t\ts.insert(a[i]);\n\t\n\t// stores the count of unique triplets\n\tint count = 0;\n\t\n\t// traverse for all i, j pairs such that j>i\n\tfor (int i = 0; i < n-1; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\n\t\t// xor of a[i] and a[j]\n\t\tint xr = a[i] ^ a[j];\n\t\n\t\t// if xr of two numbers is present, \n\t\t// then increase the count\n\t\tif (s.find(xr) != s.end() && xr != a[i] && \n\t\t\t\t\t\t\t\t\txr != a[j])\n\t\t\tcount++;\n\t\t}\n\t}\n\t\n\t// returns answer\n\treturn count / 3;\n}\n\n// Driver code to test above function\nint main() \n{\n\tint a[] = {1, 3, 5, 10, 14, 15};\n\tint n = sizeof(a) / sizeof(a[0]); \n\tcout << countTriplets(a, n); \n\treturn 0;\n}\n",
        "private_test": "SC_MODULE(Testbench) {\n    sc_signal<sc_uint<32>> a[6]; // Signals for array elements\n    sc_signal<sc_uint<32>> count_out; // Signal for the count of triplets\n\n    TripletCounter triplet_counter_inst; // Instance of the TripletCounter module\n\n    // Constructor\n    SC_CTOR(Testbench) : triplet_counter_inst(\"triplet_counter\") {\n        // Connect signals to ports\n        for (int i = 0; i < 6; ++i) {\n            triplet_counter_inst.a[i](a[i]);\n        }\n        triplet_counter_inst.count_out(count_out);\n\n        // Process to run tests\n        SC_THREAD(run_tests);\n    }\n\n    // Thread to run test cases\n    void run_tests() {\n        // Initialize array values\n        a[0] = 1; a[1] = 3; a[2] = 5; a[3] = 10; a[4] = 14; a[5] = 15;\n        wait(1, SC_NS); // Wait for the process to update\n\n        // Print the result\n        std::cout << \"Number of unique triplets: \" << count_out.read() << std::endl;\n\n        // End simulation\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); // Create an instance of the Testbench\n\n    // Start the simulation\n    sc_start();\n\n    return 0;\n}\n",
        "module_name": "TripletCounter"
    },
    {
        "task_id": 41,
        "task": "FindSimpleInterest.cpp",
        "code": "// C++ program to find simple interest \n// for given principal amount, time \n// and rate of interest.\n#include<iostream>\nusing namespace std;\n\n// Driver code\nint main()\n{\n\t// We can change values here for\n\t// different inputs\n\tfloat P = 1, R = 1, T = 1;\n\n\t// Calculate simple interest \n\tfloat SI = (P * T * R) / 100;\n\n\t// Print the resultant value of SI \n\tcout << \"Simple Interest = \" << SI;\n\n\treturn 0;\n}\n\n",
        "private_test": "SC_MODULE(Testbench) {\n    sc_signal<float> P_sig;      // Signal for Principal\n    sc_signal<float> R_sig;      // Signal for Rate\n    sc_signal<float> T_sig;      // Signal for Time\n    sc_signal<float> SI_sig;     // Signal for Simple Interest\n\n    SimpleInterestCalculator si_inst; // Instance of the SimpleInterestCalculator module\n\n    // Constructor\n    SC_CTOR(Testbench)\n    : si_inst(\"si_inst\") {\n        // Connect signals to module ports\n        si_inst.P(P_sig);\n        si_inst.R(R_sig);\n        si_inst.T(T_sig);\n        si_inst.SI(SI_sig);\n\n        // Create a test thread to provide stimulus and check the result\n        SC_THREAD(run_tests);\n    }\n\n    // Thread to run test cases\n    void run_tests() {\n        // Test case 1: P = 1, R = 1, T = 1 (expected SI = 0.01)\n        P_sig = 1.0;\n        R_sig = 1.0;\n        T_sig = 1.0;\n        wait(1, SC_NS); // Wait for the process to update\n        float result = SI_sig.read();\n        std::cout << \"Simple Interest for P=1, R=1, T=1: \" << result << std::endl;\n        assert(abs(result - 0.01) < 1e-6); // Allow for floating-point precision errors\n\n        // End simulation after successful test\n        std::cout << \"Test passed successfully.\" << std::endl;\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); // Instantiate the testbench module\n    sc_start();         // Start the simulation\n    return 0;\n}\n",
        "module_name": "SimpleInterestCalculator"
    },
    {
        "task_id": 42,
        "task": "FindtheNormalandTraceofaMatrix.cpp",
        "code": "// C++ program to find trace and \n// normal of given matrix \n#include<bits/stdc++.h> \nusing namespace std; \n\n// Size of given matrix \nconst int MAX = 100; \n\n// Returns Normal of a matrix of \n// size n x n \nint findNormal(int mat[][MAX], int n) \n{ \n\tint sum = 0; \n\tfor (int i = 0; i < n; i++) \n\t\tfor (int j = 0; j < n; j++) \n\t\t\tsum += mat[i][j] * mat[i][j]; \n\treturn sqrt(sum); \n} \n\n// Returns trace of a matrix of \n// size n x n \nint findTrace(int mat[][MAX], int n) \n{ \n\tint sum = 0; \n\tfor (int i = 0; i < n; i++) \n\t\tsum += mat[i][i]; \n\treturn sum; \n} \n\n// Driven code \nint main() \n{ \n\tint mat[][MAX] = {{1, 1, 1, 1, 1}, \n\t\t{2, 2, 2, 2, 2}, \n\t\t{3, 3, 3, 3, 3}, \n\t\t{4, 4, 4, 4, 4}, \n\t\t{5, 5, 5, 5, 5}}; \n\tcout << \"Trace of Matrix = \" << \n\t\t\tfindTrace(mat, 5) << endl; \n\tcout << \"Normal of Matrix = \" << \n\t\t\tfindNormal(mat, 5) << endl; \n\treturn 0; \n} \n",
        "private_test": "SC_MODULE(Testbench) {\n    sc_signal<sc_matrix<int>> mat; // Signal for the matrix\n    sc_signal<int> n; // Signal for the size of the matrix\n    sc_signal<int> trace; // Signal for the trace\n    sc_signal<double> normal; // Signal for the normal\n\n    MatrixOperations matrix_ops_inst; // Instance of the MatrixOperations module\n\n    // Constructor\n    SC_CTOR(Testbench) : matrix_ops_inst(\"matrix_ops\") {\n        // Connect signals to ports\n        matrix_ops_inst.mat(mat);\n        matrix_ops_inst.n(n);\n        matrix_ops_inst.trace(trace);\n        matrix_ops_inst.normal(normal);\n\n        // Process to run tests\n        SC_THREAD(run_tests);\n    }\n\n    // Thread to run test cases\n    void run_tests() {\n        // Initialize a 5x5 matrix\n        sc_matrix<int> matrix(5, 5);\n        matrix[0] = {1, 1, 1, 1, 1};\n        matrix[1] = {2, 2, 2, 2, 2};\n        matrix[2] = {3, 3, 3, 3, 3};\n        matrix[3] = {4, 4, 4, 4, 4};\n        matrix[4] = {5, 5, 5, 5, 5};\n\n        // Set matrix and size\n        mat.write(matrix);\n        n.write(5);\n\n        // Wait for the computation to complete\n        wait(1, SC_NS);\n\n        // Print results\n        std::cout << \"Trace of Matrix = \" << trace.read() << std::endl;\n        std::cout << \"Normal of Matrix = \" << normal.read() << std::endl;\n\n        // Stop the simulation\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); // Create an instance of the Testbench\n\n    // Start the simulation\n    sc_start();\n\n    return 0;\n}\n",
        "module_name": "MatrixOperations"
    },
    {
        "task_id": 43,
        "task": "CalculatethePowerofaNumber.cpp",
        "code": "// C program to illustrate power function\n#include <math.h>\n#include <stdio.h>\n\nint main()\n{\n    double x = 6.1, y = 4.8;\n\n    // Storing the answer in result.\n    double result = pow(x, y);\n    printf(\"%.2lf\", result);\n\n    return 0;\n}\n",
        "private_test": "SC_MODULE(Testbench) {\n    sc_signal<double> base_sig;       // Signal for the base\n    sc_signal<double> exponent_sig;   // Signal for the exponent\n    sc_signal<double> result_sig;     // Signal for the result\n\n    // Instance of the PowerCalculator module\n    PowerCalculator power_inst;\n\n    // Constructor: Initialize the module and run the test thread\n    SC_CTOR(Testbench)\n    : power_inst(\"power_inst\") {\n        // Connect signals to module ports\n        power_inst.base(base_sig);\n        power_inst.exponent(exponent_sig);\n        power_inst.result(result_sig);\n\n        // Create a test thread to provide stimulus and check the result\n        SC_THREAD(run_tests);\n    }\n\n    // Thread to run test cases\n    void run_tests() {\n        // Set the base and exponent values\n        base_sig.write(6.1);\n        exponent_sig.write(4.8);\n        wait(1, SC_NS); // Wait for the process to update\n\n        // Read and print the result\n        double result = result_sig.read();\n        std::cout << \"Result: \" << result << std::endl;\n\n        // End simulation after successful test\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); // Instantiate the testbench module\n    sc_start();         // Start the simulation\n    return 0;\n}\n",
        "module_name": "PowerCalculator"
    },
    {
        "task_id": 44,
        "task": "InterchangeElementsofFirstAndLastRowsinMatrix.cpp",
        "code": "// C++ code to swap the element of first \n// and last column and display the result \n#include <iostream> \nusing namespace std; \n\n#define n 4 \n\nvoid interchangeFirstLast(int m[][n]) \n{ \n\t// swapping of element between first \n\t// and last columns \n\tfor (int i = 0; i < n; i++) \n\t{ \n\t\tint t = m[i][0]; \n\t\tm[i][0] = m[i][n - 1]; \n\t\tm[i][n - 1] = t; \n\t} \n} \n\n// Driver function \nint main() \n{ \n\t// input in the array \n\tint m[n][n] = {{8, 9, 7, 6}, \n\t\t\t\t{4, 7, 6, 5}, \n\t\t\t\t{3, 2, 1, 8}, \n\t\t\t\t{9, 9, 7, 7}}; \n\n\tinterchangeFirstLast(m); \n\n\t// printing the interchanged matrix \n\tfor (int i = 0; i < n; i++) \n\t{ \n\t\tfor (int j = 0; j < n; j++) \n\t\t\tcout << m[i][j] << \" \"; \n\t\tcout << endl; \n\t} \n} \n",
        "private_test": "SC_MODULE(Testbench) {\n    sc_clock clk;                    // Clock signal\n    sc_signal<bool> reset;          // Reset signal\n    sc_signal<sc_matrix<int, 4>> input_matrix;  // Input matrix signal\n    sc_signal<sc_matrix<int, 4>> output_matrix; // Output matrix signal\n\n    // Instance of the MatrixColumnSwapper module\n    MatrixColumnSwapper swapper_inst;\n\n    // Constructor\n    SC_CTOR(Testbench)\n    : swapper_inst(\"swapper\"), clk(\"clk\", 10, SC_NS, 0.5, 0, SC_NS, true) {\n        // Connect signals to ports\n        swapper_inst.clk(clk);\n        swapper_inst.reset(reset);\n        swapper_inst.input_matrix(input_matrix);\n        swapper_inst.output_matrix(output_matrix);\n\n        // Process to initialize and run the test\n        SC_THREAD(run_test);\n    }\n\n    // Thread to run test cases\n    void run_test() {\n        // Initialize the reset signal\n        reset.write(true);\n        wait(2, SC_NS); // Hold reset for 2 cycles\n        reset.write(false);\n\n        // Initialize the input matrix\n        sc_matrix<int, 4> init_matrix = {{8, 9, 7, 6},\n                                         {4, 7, 6, 5},\n                                         {3, 2, 1, 8},\n                                         {9, 9, 7, 7}};\n        input_matrix.write(init_matrix);\n\n        // Wait for a few clock cycles to let the swapper process the input\n        wait(5, SC_NS);\n\n        // Read and print the output matrix\n        sc_matrix<int, 4> result_matrix = output_matrix.read();\n        cout << \"Modified Matrix:\" << endl;\n        for (int i = 0; i < 4; i++) {\n            for (int j = 0; j < 4; j++) {\n                cout << result_matrix[i][j] << \" \";\n            }\n            cout << endl;\n        }\n\n        // Stop the simulation\n        sc_stop();\n    }\n};\n\n// Main function to start the simulation\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); // Create an instance of the Testbench\n\n    // Start the simulation\n    sc_start();\n\n    return 0;\n}\n",
        "module_name": "MatrixColumnSwapper"
    },
    {
        "task_id": 45,
        "task": "AreaAndPerimeterofRectangle.cpp",
        "code": "// C++ program to find area\n// and perimeter of rectangle\n#include<iostream>\nusing namespace std;\n\n// Utility function\nint areaRectangle(int a, int b)\n{\nint area = a * b;\nreturn area;\n}\n\nint perimeterRectangle(int a, int b)\n{\nint perimeter = 2*(a + b);\nreturn perimeter;\n}\n\n// Driver code\nint main()\n{\nint a = 5;\nint b = 6;\ncout << \"Area = \" << \n\t\tareaRectangle(a, b) << \n\t\tendl;\ncout << \"Perimeter = \" << \n\t\tperimeterRectangle(a, b);\nreturn 0;\n} \n",
        "private_test": "SC_MODULE(Testbench) {\n    sc_signal<int> length_sig;  // Signal for the length of the rectangle\n    sc_signal<int> width_sig;   // Signal for the width of the rectangle\n    sc_signal<int> area_sig;     // Signal for the area of the rectangle\n    sc_signal<int> perimeter_sig;// Signal for the perimeter of the rectangle\n\n    // Instance of the RectangleCalculator module\n    RectangleCalculator rect_calc_inst;\n\n    // Constructor: Initialize the module and run the test thread\n    SC_CTOR(Testbench)\n    : rect_calc_inst(\"rect_calc_inst\") {\n        // Connect signals to module ports\n        rect_calc_inst.length(length_sig);\n        rect_calc_inst.width(width_sig);\n        rect_calc_inst.area(area_sig);\n        rect_calc_inst.perimeter(perimeter_sig);\n\n        // Create a test thread to provide stimulus and check the result\n        SC_THREAD(run_tests);\n    }\n\n    // Thread to run test cases\n    void run_tests() {\n        // Set the dimensions of the rectangle\n        length_sig.write(5);\n        width_sig.write(6);\n        wait(1, SC_NS); // Wait for the process to update\n\n        // Read and print the results\n        int calculated_area = area_sig.read();\n        int calculated_perimeter = perimeter_sig.read();\n        cout << \"Area = \" << calculated_area << endl;\n        cout << \"Perimeter = \" << calculated_perimeter << endl;\n\n        // End simulation after successful test\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); // Instantiate the testbench module\n    sc_start();         // Start the simulation\n    return 0;\n}\n",
        "module_name": "RectangleCalculator"
    },
    {
        "task_id": 46,
        "task": "DisplayArmstrongNumbersBetween1to1000.cpp",
        "code": "// C++ program to find Armstrong numbers between 1 to 1000 using a brute force approach\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to return the order of a number.\nint order(int num)\n{\n\tint count = 0;\n\twhile (num > 0)\n\t{\n\t\tnum /= 10;\n\t\tcount++;\n\t}\n\treturn count;\n}\n\n// Function to check whether thegiven number is Armstrong numberor not\nbool isArmstrong(int num)\n{\n\tint order_n = order(num);\n\tint num_temp = num, sum = 0;\n\n\twhile (num_temp > 0)\n\t{\n\t\tint curr = num_temp % 10;\n\t\tsum += pow(curr, order_n);\n\t\tnum_temp /= 10;\n\t}\n\tif (sum == num)\n\t{\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n\n// Driver code\nint main()\n{\n\n\tcout << \"Armstrong numbers between 1 to 1000 : \";\n\t// Loop which will run from 1 to 1000\n\tfor (int num = 1; num <= 1000; ++num)\n\t{\n\n\t\tif (isArmstrong(num))\n\t\t{\n\t\t\tcout << num << \" \";\n\t\t}\n\t}\n\treturn 0;\n}\n",
        "private_test": "SC_MODULE(Testbench) {\n    sc_signal<int> number_sig;       // Signal for the number to check\n    sc_signal<bool> armstrong_sig;   // Signal indicating if the number is an Armstrong number\n\n    // Instance of the ArmstrongChecker module\n    ArmstrongChecker checker_inst;\n\n    // Constructor\n    SC_CTOR(Testbench) : checker_inst(\"checker\") {\n        // Connect signals to module ports\n        checker_inst.number_in(number_sig);\n        checker_inst.is_armstrong(armstrong_sig);\n\n        // Create a process to iterate through numbers and check Armstrong condition\n        SC_THREAD(run_tests);\n    }\n\n    // Thread to run test cases\n    void run_tests() {\n        cout << \"Armstrong numbers between 1 to 1000 : \";\n        for (int num = 1; num <= 1000; ++num) {\n            number_sig.write(num);\n            wait(1, SC_NS); // Wait for the checker to process\n            if (armstrong_sig.read()) {\n                cout << num << \" \";\n            }\n        }\n        cout << endl;\n        sc_stop(); // Stop the simulation\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); // Create an instance of the Testbench\n\n    // Start the simulation\n    sc_start();\n\n    return 0;\n}\n",
        "module_name": "ArmstrongChecker"
    },
    {
        "task_id": 47,
        "task": "FindLCM.cpp",
        "code": "// C++ program to find the LCM of two\n// numbers using the if statement and\n// while loop\n#include <iostream>\nusing namespace std;\n\n// Driver code\nint main()\n{\n\tint a = 15, b = 20, max_num, flag = 1;\n\n\t// Use ternary operator to get the\n\t// large number\n\tmax_num = (a > b) ? a : b;\n\n\twhile (flag) {\n\t\t// if statement checks max_num is completely\n\t\t// divisible by n1 and n2.\n\t\tif (max_num % a == 0 && max_num % b == 0) {\n\t\t\tcout << \"LCM of \" << a << \" and \" << b << \" is \"\n\t\t\t\t<< max_num;\n\t\t\tbreak;\n\t\t}\n\n\t\t// update by 1 on each iteration\n\t\t++max_num;\n\t}\n\treturn 0;\n}\n",
        "private_test": "SC_MODULE(Testbench) {\n    sc_signal<int> a_sig;       // Signal for the first input\n    sc_signal<int> b_sig;       // Signal for the second input\n    sc_signal<int> lcm_sig;      // Signal for the LCM output\n\n    // Instance of the LcmCalculator module\n    LcmCalculator lcm_inst;\n\n    // Constructor: Initialize the module and run the test thread\n    SC_CTOR(Testbench)\n    : lcm_inst(\"lcm_inst\") {\n        // Connect signals to module ports\n        lcm_inst.a(a_sig);\n        lcm_inst.b(b_sig);\n        lcm_inst.lcm_result(lcm_sig);\n\n        // Create a test thread to provide stimulus and check the result\n        SC_THREAD(run_tests);\n    }\n\n    // Thread to run test cases\n    void run_tests() {\n        // Test case: a = 15, b = 20 (expected LCM = 60)\n        a_sig.write(15);\n        b_sig.write(20);\n        wait(1, SC_NS); // Wait for the process to update\n        int result = lcm_sig.read();\n        std::cout << \"LCM(\" << a_sig.read() << \", \" << b_sig.read() << \") = \" << result << std::endl;\n        assert(result == 60);\n\n        // End simulation after successful test\n        std::cout << \"Test passed successfully.\" << endl;\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); // Instantiate the testbench module\n    sc_start();         // Start the simulation\n    return 0;\n}\n",
        "module_name": "LcmCalculator"
    },
    {
        "task_id": 48,
        "task": "MakeaSimpleCalculator.cpp",
        "code": "// C++ Program to make a Simple Calculator using\n// switch-case statements\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    char op;\n    double a, b, res;\n\n    // Read the operator\n    cout << \"Enter an operator (+, -, *, /): \";\n    cin >> op;\n\n    // Read the two numbers\n    cout << \"Enter two numbers: \";\n    cin >> a >> b;\n\n    // Define all four operations in the corresponding\n    // switch-case\n    switch (op) {\n    case '+':\n        res = a + b;\n        break;\n    case '-':\n        res = a - b;\n        break;\n    case '*':\n        res = a * b;\n        break;\n    case '/':\n        res = a / b;\n        break;\n    default:\n        cout << \"Error! Operator is not correct\";\n        res = -DBL_MAX;\n    }\n    \n      // Printing the result\n    if (res != -DBL_MAX)\n        cout << \"Result: \" << res;\n    return 0;\n}\n",
        "private_test": "SC_MODULE(Testbench) {\n    sc_signal<char> op_sig;       // Signal for the operator\n    sc_signal<double> a_sig;      // Signal for the first number\n    sc_signal<double> b_sig;      // Signal for the second number\n    sc_signal<double> result_sig; // Signal for the result\n\n    // Instance of the SimpleCalculator module\n    SimpleCalculator calc_inst;\n\n    // Constructor: Initialize the module and run the test thread\n    SC_CTOR(Testbench)\n    : calc_inst(\"calc_inst\") {\n        // Connect signals to module ports\n        calc_inst.op(op_sig);\n        calc_inst.a(a_sig);\n        calc_inst.b(b_sig);\n        calc_inst.result(result_sig);\n\n        // Create a test thread to provide stimulus and check the result\n        SC_THREAD(run_tests);\n    }\n\n    // Thread to run test cases\n    void run_tests() {\n        // Test case 1: Addition\n        op_sig.write('+');\n        a_sig.write(5.0);\n        b_sig.write(3.0);\n        wait(1, SC_NS); // Wait for the process to update\n        double result = result_sig.read();\n        cout << \"5.0 + 3.0 = \" << result << endl;\n        assert(abs(result - 8.0) < 1e-9);\n\n        // Test case 2: Subtraction\n        op_sig.write('-');\n        a_sig.write(10.0);\n        b_sig.write(4.0);\n        wait(1, SC_NS);\n        result = result_sig.read();\n        cout << \"10.0 - 4.0 = \" << result << endl;\n        assert(abs(result - 6.0) < 1e-9);\n\n        // Test case 3: Multiplication\n        op_sig.write('*');\n        a_sig.write(6.0);\n        b_sig.write(7.0);\n        wait(1, SC_NS);\n        result = result_sig.read();\n        cout << \"6.0 * 7.0 = \" << result << endl;\n        assert(abs(result - 42.0) < 1e-9);\n\n        // Test case 4: Division\n        op_sig.write('/');\n        a_sig.write(8.0);\n        b_sig.write(2.0);\n        wait(1, SC_NS);\n        result = result_sig.read();\n        cout << \"8.0 / 2.0 = \" << result << endl;\n        assert(abs(result - 4.0) < 1e-9);\n\n        // Test case 5: Invalid operator\n        op_sig.write('%');\n        a_sig.write(1.0);\n        b_sig.write(1.0);\n        wait(1, SC_NS);\n        result = result_sig.read();\n        cout << \"Invalid operator '%' test passed.\" << endl;\n        assert(result == -DBL_MAX);\n\n        // End simulation after successful test\n        cout << \"All tests passed successfully.\" << endl;\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); // Instantiate the testbench module\n    sc_start();         // Start the simulation\n    return 0;\n}\n",
        "module_name": "SimpleCalculator"
    },
    {
        "task_id": 49,
        "task": "CheckWhetherTwoMatricesAreEqualorNot.cpp",
        "code": "// C++ Program to check if two given matrices are identical \n#include <bits/stdc++.h> \n#define N 4 \nusing namespace std; \n\n// This function returns 1 if A[][] \n// and B[][] are identical otherwise \n// returns 0 \nint areSame(int A[][N], int B[][N]) \n{ \n\tint i, j; \n\tfor (i = 0; i < N; i++) \n\t\tfor (j = 0; j < N; j++) \n\t\t\tif (A[i][j] != B[i][j]) \n\t\t\t\treturn 0; \n\treturn 1; \n} \n\nint main() \n{ \n\tint A[N][N] = {{1, 1, 1, 1}, \n\t\t\t\t{2, 2, 2, 2}, \n\t\t\t\t{3, 3, 3, 3}, \n\t\t\t\t{4, 4, 4, 4}}; \n\n\tint B[N][N] = {{1, 1, 1, 1}, \n\t\t\t\t{2, 2, 2, 2}, \n\t\t\t\t{3, 3, 3, 3}, \n\t\t\t\t{4, 4, 4, 4}}; \n\n\tif (areSame(A, B)) \n\t\tcout << \"Matrices are identical\"; \n\telse\n\t\tcout << \"Matrices are not identical\"; \n\treturn 0; \n} \n",
        "private_test": "SC_MODULE(Testbench) {\n    sc_clock clk;             // Clock signal\n    sc_signal<bool> rst;      // Reset signal\n    sc_signal<int> A[N][N];   // Signals for matrix A\n    sc_signal<int> B[N][N];   // Signals for matrix B\n    sc_signal<bool> identical; // Signal for the result\n\n    MatrixComparator comparator_inst; // Instance of the MatrixComparator module\n\n    // Constructor\n    SC_CTOR(Testbench) : clk(\"clk\", 10, SC_NS), comparator_inst(\"comparator\") {\n        // Connect signals to ports\n        comparator_inst.clk(clk);\n        comparator_inst.rst(rst);\n        for (int i = 0; i < N; ++i) {\n            for (int j = 0; j < N; ++j) {\n                comparator_inst.A[i][j](A[i][j]);\n                comparator_inst.B[i][j](B[i][j]);\n            }\n        }\n        comparator_inst.identical(identical);\n\n        // Process to run tests\n        SC_THREAD(run_tests);\n    }\n\n    // Thread to run test cases\n    void run_tests() {\n        // Initialize matrices\n        for (int i = 0; i < N; ++i) {\n            for (int j = 0; j < N; ++j) {\n                A[i][j].write(1 + i); // Fill A with values 1 to 4\n                B[i][j].write(1 + i); // Fill B with values 1 to 4\n            }\n        }\n\n        // Apply reset\n        rst.write(true);\n        wait(2, SC_NS);\n        rst.write(false);\n\n        // Wait for the comparison to complete\n        wait(2, SC_NS);\n\n        // Check the result\n        if (identical.read()) {\n            cout << \"Matrices are identical\" << endl;\n        } else {\n            cout << \"Matrices are not identical\" << endl;\n        }\n\n        // Modify B to make matrices different\n        B[0][0].write(99); // Change the first element of B\n\n        // Wait for the comparison to complete\n        wait(2, SC_NS);\n\n        // Check the result again\n        if (identical.read()) {\n            cout << \"Matrices are identical\" << endl;\n        } else {\n            cout << \"Matrices are not identical\" << endl;\n        }\n\n        // Stop the simulation\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); // Create an instance of the Testbench\n\n    // Start the simulation\n    sc_start();\n\n    return 0;\n}\n",
        "module_name": "MatrixComparator"
    },
    {
        "task_id": 50,
        "task": "DecimaltoBinaryConversion.cpp",
        "code": "// C++ program to convert a decimal number to binary number\n#include <iostream>\nusing namespace std;\n\n// Function to convert decimal\n// to binary\nvoid decToBinary(int n)\n{\n\t// Array to store binary number\n\tint binaryNum[32];\n\n\t// Counter for binary array\n\tint i = 0;\n\twhile (n > 0) {\n\t\t// Storing remainder in binary\n\t\t// array\n\t\tbinaryNum[i] = n % 2;\n\t\tn = n / 2;\n\t\ti++;\n\t}\n\n\t// Printing binary array in reverse\n\t// order\n\tfor (int j = i - 1; j >= 0; j--)\n\t\tcout << binaryNum[j];\n}\n\n// Driver code\nint main()\n{\n\tint n = 10;\n\tdecToBinary(n);\n\treturn 0;\n}\n",
        "private_test": "SC_MODULE(Testbench) {\n    sc_signal<int> n_sig;           // Signal for the input decimal number\n    sc_signal<sc_bv<32>> bin_sig;   // Signal for the output binary number\n\n    DecToBinConverter converter_inst; // Instance of the converter module\n\n    // Constructor\n    SC_CTOR(Testbench) : converter_inst(\"converter\") {\n        // Connect signals to ports\n        converter_inst.n(n_sig);\n        converter_inst.bin(bin_sig);\n\n        // Process to run tests\n        SC_THREAD(run_tests);\n    }\n\n    // Thread to run test cases\n    void run_tests() {\n        // Test case 1: Convert 10 to binary\n        n_sig = 10;\n        wait(1, SC_NS); // Wait for the converter to process\n        sc_bv<32> result = bin_sig.read();\n        std::cout << \"Decimal: 10 -> Binary: \" << result << std::endl;\n\n        // Additional test case: Convert 0 to binary\n        n_sig = 0;\n        wait(1, SC_NS);\n        result = bin_sig.read();\n        std::cout << \"Decimal: 0 -> Binary: \" << result << std::endl;\n\n        // Additional test case: Convert 255 to binary\n        n_sig = 255;\n        wait(1, SC_NS);\n        result = bin_sig.read();\n        std::cout << \"Decimal: 255 -> Binary: \" << result << std::endl;\n\n        // End simulation after successful test\n        std::cout << \"Tests completed successfully.\" << std::endl;\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); // Create an instance of the Testbench\n\n    // Start the simulation\n    sc_start();\n\n    return 0;\n}\n",
        "module_name": "DecToBinConverter"
    },
    {
        "task_id": 51,
        "task": "CheckWhetheraNumberisaPalindromeorNot.cpp",
        "code": "// C++ implementation of the above approach\n#include <iostream>\nusing namespace std;\n\n// Function to check palindrome\nint checkPalindrome(string str)\n{ \n\t// Calculating string length\n\tint len = str.length();\n\n\t// Traversing through the string \n\t// upto half its length\n\tfor (int i = 0; i < len / 2; i++) \n\t{\t \n\t\t// Comparing i th character from \n\t\t// starting and len-i th character \n\t\t// from end\n\t\tif (str[i] != str[len - i - 1])\n\t\t\treturn false;\n\t}\n\n\t// If the above loop doesn't return \n\t// then it is palindrome\n\treturn true;\n}\n\n// Driver Code\nint main()\n{ \n\t// Taking number as string\n\tstring st = \n\t\"112233445566778899000000998877665544332211\";\n\tif (checkPalindrome(st) == true)\n\t\tcout << \"Yes\";\n\telse\n\t\tcout << \"No\";\n\treturn 0;\n}\n// This code is written by vikkycirus\n",
        "private_test": "SC_MODULE(Testbench) {\n    sc_signal<std::string> str_sig;  // Signal for the string input\n    sc_signal<bool> result_sig;      // Signal for the palindrome result\n\n    // Instance of the PalindromeChecker module\n    PalindromeChecker checker_inst;\n\n    // Constructor\n    SC_CTOR(Testbench)\n    : checker_inst(\"checker_inst\") {\n        // Connect signals to module ports\n        checker_inst.input_string(str_sig);\n        checker_inst.is_palindrome(result_sig);\n\n        // Create a test thread to provide stimulus and check the result\n        SC_THREAD(run_tests);\n    }\n\n    // Thread to run test cases\n    void run_tests() {\n        // Test case: Given string\n        str_sig.write(\"112233445566778899000000998877665544332211\");\n        wait(1, SC_NS); // Wait for the process to update\n        bool result = result_sig.read();\n        std::cout << \"Is palindrome: \" << (result ? \"Yes\" : \"No\") << std::endl;\n        assert(result == true);\n\n        // Additional test case: Non-palindrome string\n        str_sig.write(\"HelloWorld\");\n        wait(1, SC_NS);\n        result = result_sig.read();\n        std::cout << \"Is palindrome: \" << (result ? \"Yes\" : \"No\") << std::endl;\n        assert(result == false);\n\n        // End simulation after successful test\n        std::cout << \"All tests passed successfully.\" << std::endl;\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); // Instantiate the testbench module\n    sc_start();         // Start the simulation\n    return 0;\n}\n",
        "module_name": "PalindromeChecker"
    },
    {
        "task_id": 52,
        "task": "AddTwoNumbers.cpp",
        "code": "// C++ program to add two number using addition operator\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int a = 11, b = 9;\n\n    // Adding the two numbers and printing\n    // their sum\n    cout << a + b;\n    return 0;\n}\n",
        "private_test": "SC_MODULE(Testbench) {\n    sc_signal<int> a; // Signal for the first number\n    sc_signal<int> b; // Signal for the second number\n    sc_signal<int> sum; // Signal for the sum\n\n    Adder adder_inst; // Instance of the Adder module\n\n    // Constructor\n    SC_CTOR(Testbench) : adder_inst(\"adder\") {\n        // Connect signals to ports\n        adder_inst.a(a);\n        adder_inst.b(b);\n        adder_inst.sum(sum);\n\n        // Process to run tests\n        SC_THREAD(run_tests);\n    }\n\n    // Thread to run test cases\n    void run_tests() {\n        // Test case 1: Simple addition\n        a = 11; b = 9;\n        wait(1, SC_NS); // Wait for the adder to process\n        assert(sum.read() == 20);\n        cout << \"Sum: \" << sum.read() << endl;\n\n        // Additional test case: One operand is zero\n        a = 0; b = 5;\n        wait(1, SC_NS);\n        assert(sum.read() == 5);\n        cout << \"Sum: \" << sum.read() << endl;\n\n        // Additional test case: Both operands are zero\n        a = 0; b = 0;\n        wait(1, SC_NS);\n        assert(sum.read() == 0);\n        cout << \"Sum: \" << sum.read() << endl;\n\n        // Print success message\n        cout << \"All tests passed successfully.\" << endl;\n\n        // User interaction simulation\n        a = 3; b = 7; // Example user input\n        wait(1, SC_NS);\n        cout << \"Sum: \" << sum.read() << endl;\n\n        sc_stop(); // Stop the simulation\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); // Create an instance of the Testbench\n\n    // Start the simulation\n    sc_start();\n\n    return 0;\n}\n",
        "module_name": "Adder"
    },
    {
        "task_id": 53,
        "task": "ArrayRotation.cpp",
        "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to rotate array\nvoid Rotate(int arr[], int d, int n)\n{\n\t// Storing rotated version of array\n\tint temp[n];\n\n\t// Keeping track of the current index\n\t// of temp[]\n\tint k = 0;\n\n\t// Storing the n - d elements of\n\t// array arr[] to the front of temp[]\n\tfor (int i = d; i < n; i++) {\n\t\ttemp[k] = arr[i];\n\t\tk++;\n\t}\n\n\t// Storing the first d elements of array arr[]\n\t// into temp\n\tfor (int i = 0; i < d; i++) {\n\t\ttemp[k] = arr[i];\n\t\tk++;\n\t}\n\n\t// Copying the elements of temp[] in arr[]\n\t// to get the final rotated array\n\tfor (int i = 0; i < n; i++) {\n\t\tarr[i] = temp[i];\n\t}\n}\n\n// Function to print elements of array\nvoid PrintTheArray(int arr[], int n)\n{\n\tfor (int i = 0; i < n; i++) {\n\t\tcout << arr[i] << \" \";\n\t}\n}\n\n// Driver code\nint main()\n{\n\tint arr[] = { 1, 2, 3, 4, 5, 6, 7 };\n\tint N = sizeof(arr) / sizeof(arr[0]);\n\tint d = 2;\n\n\t// Function calling\n\tRotate(arr, d, N);\n\tPrintTheArray(arr, N);\n\n\treturn 0;\n}\n",
        "private_test": "SC_MODULE(Testbench) {\n    sc_signal<int> d;      // Signal for the number of positions to rotate\n    sc_signal<int> n;      // Signal for the size of the array\n    sc_vector<sc_signal<int>> arr_in; // Signals for the array elements\n    sc_vector<sc_signal<int>> arr_out; // Signals for the rotated array elements\n\n    ArrayRotator rotator_inst; // Instance of the ArrayRotator module\n\n    // Constructor\n    SC_CTOR(Testbench) : arr_in(\"arr_in\", n), arr_out(\"arr_out\", n), rotator_inst(\"rotator\") {\n        // Connect signals to ports\n        rotator_inst.d(d);\n        rotator_inst.n(n);\n        for (int i = 0; i < n.read(); i++) {\n            rotator_inst.arr_in[i](arr_in[i]);\n            rotator_inst.arr_out[i](arr_out[i]);\n        }\n\n        // Process to run tests\n        SC_THREAD(run_tests);\n    }\n\n    // Thread to run test cases\n    void run_tests() {\n        // Initialize array size\n        n = 7;\n\n        // Initialize array elements\n        int initial_arr[] = { 1, 2, 3, 4, 5, 6, 7 };\n\n        for (int i = 0; i < n.read(); i++) {\n            arr_in[i] = initial_arr[i];\n        }\n\n        // Set rotation amount\n        d = 2;\n\n        // Wait for the rotator to process\n        wait(1, SC_NS);\n\n        // Print rotated array\n        cout << \"Rotated Array: \";\n        for (int i = 0; i < n.read(); i++) {\n            cout << arr_out[i].read() << \" \";\n        }\n        cout << endl;\n\n        // Stop the simulation\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); // Create an instance of the Testbench\n\n    // Start the simulation\n    sc_start();\n\n    return 0;\n}\n",
        "module_name": "ArrayRotator"
    },
    {
        "task_id": 54,
        "task": "FindCompoundInterest.cpp",
        "code": "// C++ program to find compound interest for given values.\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Driver code\nint main()\n{\n    double principal = 10000, rate = 5, time = 2;\n\n    // Calculate compound interest\n    double A = principal * ((pow((1 + rate / 100), time)));\n    double CI = A - principal;\n\n    cout << \"Compound interest is \" << CI;\n\n    return 0;\n}\n// This Code is Contributed by Sahil Rai.\n",
        "private_test": "SC_MODULE(Testbench) {\n    sc_signal<double> principal_sig; // Signal for principal amount\n    sc_signal<double> rate_sig;      // Signal for interest rate\n    sc_signal<double> time_sig;      // Signal for time period\n    sc_signal<double> ci_sig;        // Signal for compound interest\n\n    // Instance of the CompoundInterestCalculator module\n    CompoundInterestCalculator ci_inst;\n\n    // Constructor: Initialize the module and run the test thread\n    SC_CTOR(Testbench)\n    : ci_inst(\"ci_inst\") {\n        // Connect signals to module ports\n        ci_inst.principal(principal_sig);\n        ci_inst.rate(rate_sig);\n        ci_inst.time(time_sig);\n        ci_inst.ci(ci_sig);\n\n        // Create a test thread to provide stimulus and check the result\n        SC_THREAD(run_tests);\n    }\n\n    // Thread to run test cases\n    void run_tests() {\n        // Set input values\n        principal_sig = 10000;\n        rate_sig = 5;\n        time_sig = 2;\n        wait(1, SC_NS); // Wait for the process to update\n\n        // Read and print the compound interest\n        double result = ci_sig.read();\n        std::cout << \"Compound interest is \" << result << std::endl;\n\n        // End simulation after successful test\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); // Instantiate the testbench module\n    sc_start();         // Start the simulation\n    return 0;\n}\n",
        "module_name": "CompoundInterestCalculator"
    },
    {
        "task_id": 55,
        "task": "CheckiftwoArraysareEqualornot.cpp",
        "code": "// C++ program to implement the approach\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to check if both arrays are equal\nbool checkArrays(int arr1[], int arr2[],\n\t\t\t\tint n, int m)\n{\n\t// If lengths of array are not equal\n\t// means array are not equal\n\tif (n != m)\n\t\treturn false;\n\n\t// Sort both arrays\n\tsort(arr1, arr1 + n);\n\tsort(arr2, arr2 + m);\n\n\t// Linearly compare elements\n\tfor (int i = 0; i < n; i++)\n\t\tif (arr1[i] != arr2[i])\n\t\t\treturn false;\n\n\t// If elements are same\n\treturn true;\n}\n\n// Driver Code\nint main()\n{\n\tint arr1[] = { 1, 2, 3, 4, 5 };\n\tint arr2[] = { 5, 4, 3, 2, 1 };\n\tint N = sizeof(arr1) / sizeof(int);\n\tint M = sizeof(arr2) / sizeof(int);\n\n\t// Function call\n\tif (checkArrays(arr1, arr2, N, M))\n\t\tcout << \"Equal\";\n\telse\n\t\tcout << \"Not Equal\";\n\treturn 0;\n}\n",
        "private_test": "SC_MODULE(Testbench) {\n    // Signals for the arrays and their sizes\n    sc_signal<sc_int<32>> arr1[5];\n    sc_signal<sc_int<32>> arr2[5];\n    sc_signal<sc_uint<8>> N;\n    sc_signal<sc_uint<8>> M;\n\n    // Signal for the result\n    sc_signal<bool> are_equal;\n\n    // Instance of the ArrayEqualityChecker module\n    ArrayEqualityChecker checker_inst;\n\n    // Constructor: Initialize the module and run the test thread\n    SC_CTOR(Testbench)\n    : checker_inst(\"checker_inst\") {\n        // Connect signals to module ports\n        for (int i = 0; i < 5; ++i) {\n            checker_inst.arr1[i](arr1[i]);\n            checker_inst.arr2[i](arr2[i]);\n        }\n        checker_inst.N(N);\n        checker_inst.M(M);\n        checker_inst.are_equal(are_equal);\n\n        // Create a test thread to provide stimulus and check the result\n        SC_THREAD(run_tests);\n    }\n\n    // Thread to run test cases\n    void run_tests() {\n        // Initialize arrays and sizes\n        for (int i = 0; i < 5; ++i) {\n            arr1[i].write(i + 1);\n            arr2[i].write(5 - i);\n        }\n        N.write(5);\n        M.write(5);\n        wait(1, SC_NS); // Wait for the process to update\n        bool result = are_equal.read();\n        std::cout << \"Arrays are \" << (result ? \"Equal\" : \"Not Equal\") << std::endl;\n\n        // End simulation after successful test\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); // Instantiate the testbench module\n    sc_start();         // Start the simulation\n    return 0;\n}\n",
        "module_name": "ArrayEqualityChecker"
    },
    {
        "task_id": 56,
        "task": "HexadecimaltoDecimalConversion.cpp",
        "code": "// C++ program to convert hexadecimal \n// to decimal \n#include <bits/stdc++.h> \nusing namespace std; \n\n// Function to convert hexadecimal \n// to decimal \nint hexadecimalToDecimal(string hexVal) \n{ \n\tint len = hexVal.size(); \n\n\t// Initializing base value to 1, \n\t// i.e 16^0 \n\tint base = 1; \n\n\tint dec_val = 0; \n\n\t// Extracting characters as digits \n\t// from last character \n\tfor (int i = len - 1; i >= 0; i--) { \n\t\t// If character lies in '0'-'9', \n\t\t// converting it to integral 0-9 \n\t\t// by subtracting 48 from ASCII value \n\t\tif (hexVal[i] >= '0' && hexVal[i] <= '9') { \n\t\t\tdec_val += (int(hexVal[i]) - 48) * base; \n\n\t\t\t// incrementing base by power \n\t\t\tbase = base * 16; \n\t\t} \n\n\t\t// If character lies in 'A'-'F' , converting \n\t\t// it to integral 10 - 15 by subtracting 55 \n\t\t// from ASCII value \n\t\telse if (hexVal[i] >= 'A' && hexVal[i] <= 'F') { \n\t\t\tdec_val += (int(hexVal[i]) - 55) * base; \n\n\t\t\t// Incrementing base by power \n\t\t\tbase = base * 16; \n\t\t} \n\t} \n\treturn dec_val; \n} \n\n// Driver code \nint main() \n{ \n\tstring hexNum = \"1A\"; \n\tcout << (hexadecimalToDecimal(hexNum)); \n\n\treturn 0; \n}\n",
        "private_test": "SC_MODULE(Testbench) {\n    sc_signal<std::string> hex_sig; // Signal for the hexadecimal input\n    sc_signal<int> dec_sig;         // Signal for the decimal output\n\n    // Instance of the HexToDecConverter module\n    HexToDecConverter converter_inst;\n\n    // Constructor: Initialize the module and run the test thread\n    SC_CTOR(Testbench)\n    : converter_inst(\"converter_inst\") {\n        // Connect signals to module ports\n        converter_inst.hex_in(hex_sig);\n        converter_inst.dec_out(dec_sig);\n\n        // Create a test thread to provide stimulus and check the result\n        SC_THREAD(run_tests);\n    }\n\n    // Thread to run test cases\n    void run_tests() {\n        // Test case: hex = \"1A\" (expected decimal = 26)\n        hex_sig.write(\"1A\");\n        wait(1, SC_NS); // Wait for the process to update\n        int result = dec_sig.read();\n        std::cout << \"Hexadecimal: 1A -> Decimal: \" << result << std::endl;\n        assert(result == 26);\n\n        // Additional test case: hex = \"FF\" (expected decimal = 255)\n        hex_sig.write(\"FF\");\n        wait(1, SC_NS);\n        result = dec_sig.read();\n        std::cout << \"Hexadecimal: FF -> Decimal: \" << result << std::endl;\n        assert(result == 255);\n\n        // Additional test case: hex = \"0\" (expected decimal = 0)\n        hex_sig.write(\"0\");\n        wait(1, SC_NS);\n        result = dec_sig.read();\n        std::cout << \"Hexadecimal: 0 -> Decimal: \" << result << std::endl;\n        assert(result == 0);\n\n        // Additional test case: hex = \"10\" (expected decimal = 16)\n        hex_sig.write(\"10\");\n        wait(1, SC_NS);\n        result = dec_sig.read();\n        std::cout << \"Hexadecimal: 10 -> Decimal: \" << result << std::endl;\n        assert(result == 16);\n\n        // End simulation after successful tests\n        std::cout << \"All tests passed successfully.\" << std::endl;\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); // Instantiate the testbench module\n    sc_start();         // Start the simulation\n    return 0;\n}\n",
        "module_name": "HexToDecConverter"
    },
    {
        "task_id": 57,
        "task": "CheckArmstrongNumber.cpp",
        "code": "// C++ program to implement the above approach\n#include <iostream>\nusing namespace std;\n\n// Driver code\nint main()\n{\n\tint n = 153;\n\tint temp = n;\n\tint p = 0;\n\n\t// Function to calculate\n\t// the sum of individual digits\n\twhile (n > 0) {\n\t\tint rem = n % 10;\n\t\tp = (p) + (rem * rem * rem);\n\t\tn = n / 10;\n\t}\n\n\t// Condition to check whether\n\t// the value of P equals\n\t// to user input or not.\n\tif (temp == p) {\n\t\tcout << (\"Yes. It is Armstrong No.\");\n\t}\n\telse {\n\t\tcout << (\"No. It is not an Armstrong No.\");\n\t}\n\treturn 0;\n}\n",
        "private_test": "SC_MODULE(Testbench) {\n    sc_signal<int> num_sig;       // Signal for the number input\n    sc_signal<bool> armstrong_sig; // Signal for the Armstrong check result\n\n    // Instance of the ArmstrongChecker module\n    ArmstrongChecker armstrong_checker_inst;\n\n    // Constructor: Initialize the module and run the test thread\n    SC_CTOR(Testbench)\n    : armstrong_checker_inst(\"armstrong_checker_inst\") {\n        // Connect signals to module ports\n        armstrong_checker_inst.num_in(num_sig);\n        armstrong_checker_inst.is_armstrong(armstrong_sig);\n\n        // Create a test thread to provide stimulus and check the result\n        SC_THREAD(run_tests);\n    }\n\n    // Thread to run test cases\n    void run_tests() {\n        // Test case: n = 153 (expected: Armstrong number)\n        num_sig.write(153);\n        wait(1, SC_NS); // Wait for the process to update\n        bool result = armstrong_sig.read();\n        std::cout << \"Number: 153 is Armstrong? \" << (result ? \"Yes\" : \"No\") << std::endl;\n        assert(result == true);\n\n        // Test case: n = 123 (expected: Not an Armstrong number)\n        num_sig.write(123);\n        wait(1, SC_NS); // Wait for the process to update\n        result = armstrong_sig.read();\n        std::cout << \"Number: 123 is Armstrong? \" << (result ? \"Yes\" : \"No\") << std::endl;\n        assert(result == false);\n\n        // End simulation after successful test\n        std::cout << \"Tests passed successfully.\" << std::endl;\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); // Instantiate the testbench module\n    sc_start();         // Start the simulation\n    return 0;\n}\n",
        "module_name": "ArmstrongChecker"
    },
    {
        "task_id": 58,
        "task": "FindtheMaximumandMinimuminanArray.cpp",
        "code": "// C++ program to find minimum (or maximum) element \n// in an array. \n#include <bits/stdc++.h> \nusing namespace std; \n\nint getMin(int arr[], int n) \n{ \n\treturn *min_element(arr, arr + n); \n} \n\nint getMax(int arr[], int n) \n{ \n\treturn *max_element(arr, arr + n); \n} \n\nint main() \n{ \n\tint arr[] = { 12, 1234, 45, 67, 1 }; \n\tint n = sizeof(arr) / sizeof(arr[0]); \n\tcout << \"Minimum element of array: \" << getMin(arr, n) << \" \"; \n\tcout << \"Maximum element of array: \" << getMax(arr, n); \n\treturn 0; \n} \n",
        "private_test": "SC_MODULE(Testbench) {\n    sc_clock clk;              // Clock signal\n    sc_signal<bool> rst;       // Reset signal\n    sc_signal<sc_uint<32>> data_in; // Input data\n    sc_signal<bool> valid_in;   // Valid signal indicating new data\n    sc_signal<sc_uint<32>> min_out; // Minimum element output\n    sc_signal<sc_uint<32>> max_out; // Maximum element output\n    sc_signal<bool> ready_out;  // Ready signal indicating processing completion\n\n    MinMaxFinder min_max_finder_inst; // Instance of the MinMaxFinder module\n\n    // Constructor\n    SC_CTOR(Testbench) : min_max_finder_inst(\"min_max_finder\") {\n        // Connect signals to module ports\n        min_max_finder_inst.clk(clk);\n        min_max_finder_inst.rst(rst);\n        min_max_finder_inst.data_in(data_in);\n        min_max_finder_inst.valid_in(valid_in);\n        min_max_finder_inst.min_out(min_out);\n        min_max_finder_inst.max_out(max_out);\n        min_max_finder_inst.ready_out(ready_out);\n\n        // Process to run tests\n        SC_THREAD(run_tests);\n    }\n\n    // Thread to run test cases\n    void run_tests() {\n        // Reset the system\n        rst.write(true);\n        wait(2, SC_NS);\n        rst.write(false);\n        wait(1, SC_NS);\n\n        // Test case 1: Array [12, 1234, 45, 67, 1]\n        sc_uint<32> test_array[] = {12, 1234, 45, 67, 1};\n        for (int i = 0; i < 5; ++i) {\n            data_in.write(test_array[i]);\n            valid_in.write(true);\n            wait(1, SC_NS);\n            valid_in.write(false);\n            wait(1, SC_NS);\n        }\n        wait(1, SC_NS); // Ensure final values are processed\n        cout << \"Minimum element of array: \" << min_out.read() << \" \";\n        cout << \"Maximum element of array: \" << max_out.read() << endl;\n\n        // End simulation\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); // Create an instance of the Testbench\n\n    // Start the simulation\n    sc_start();\n\n    return 0;\n}\n",
        "module_name": "MinMaxFinder"
    },
    {
        "task_id": 59,
        "task": "ComputetheSumofDiagonalsofaMatrix.cpp",
        "code": "// A simple C++ program to find sum of diagonals \n#include <bits/stdc++.h> \nusing namespace std; \n\nconst int MAX = 100; \n\nvoid printDiagonalSums(int mat[][MAX], int n) \n{ \n\tint principal = 0, secondary = 0; \n\tfor (int i = 0; i < n; i++) \n\t{ \n\t\tfor (int j = 0; j < n; j++)\t \n\t\t{ \n\t\t\t// Condition for principal diagonal \n\t\t\tif (i == j) \n\t\t\t\tprincipal += mat[i][j]; \n\n\t\t\t// Condition for secondary diagonal \n\t\t\tif ((i + j) == (n - 1)) \n\t\t\t\tsecondary += mat[i][j]; \n\t\t} \n\t} \n\n\tcout << \"Principal Diagonal:\" << \n\t\t\tprincipal << endl; \n\tcout << \"Secondary Diagonal:\" << \n\t\t\tsecondary << endl; \n} \n\n// Driver code \nint main() \n{ \n\tint a[][MAX] = {{1, 2, 3, 4}, \n\t\t\t\t\t{5, 6, 7, 8}, \n\t\t\t\t\t{1, 2, 3, 4}, \n\t\t\t\t\t{5, 6, 7, 8}}; \n\tprintDiagonalSums(a, 4); \n\treturn 0; \n} \n",
        "private_test": "SC_MODULE(Testbench) {\n    // Signal for the matrix size\n    sc_signal<int> n;\n    // Signal for the matrix data\n    sc_signal<int>[100][100] mat;\n    // Signals for the diagonal sums\n    sc_signal<int> principal_sum;\n    sc_signal<int> secondary_sum;\n\n    // Instance of the DiagonalSumCalculator module\n    DiagonalSumCalculator calc_inst;\n\n    // Constructor: Initialize the module and run the test thread\n    SC_CTOR(Testbench)\n    : calc_inst(\"calc_inst\") {\n        // Connect signals to module ports\n        calc_inst.n(n);\n        calc_inst.mat(mat);\n        calc_inst.principal_sum(principal_sum);\n        calc_inst.secondary_sum(secondary_sum);\n\n        // Create a test thread to provide stimulus and check the result\n        SC_THREAD(run_tests);\n    }\n\n    // Thread to run test cases\n    void run_tests() {\n        // Define a 4x4 matrix\n        int a[4][4] = {{1, 2, 3, 4},\n                       {5, 6, 7, 8},\n                       {1, 2, 3, 4},\n                       {5, 6, 7, 8}};\n\n        // Set the matrix size\n        n.write(4);\n\n        // Assign values to the matrix signal\n        for (int i = 0; i < 4; i++) {\n            for (int j = 0; j < 4; j++) {\n                mat[i][j].write(a[i][j]);\n            }\n        }\n\n        // Wait for the process to update\n        wait(1, SC_NS);\n\n        // Read and print the results\n        int principal = principal_sum.read();\n        int secondary = secondary_sum.read();\n        std::cout << \"Principal Diagonal: \" << principal << std::endl;\n        std::cout << \"Secondary Diagonal: \" << secondary << std::endl;\n\n        // End simulation after successful test\n        std::cout << \"Test passed successfully.\" << std::endl;\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); // Instantiate the testbench module\n    sc_start();         // Start the simulation\n    return 0;\n}\n",
        "module_name": "DiagonalSumCalculator"
    },
    {
        "task_id": 60,
        "task": "DisplayFactorsofaNaturalNumber.cpp",
        "code": "// C++ implementation of Naive method to print all divisors \n#include <iostream> \nusing namespace std; \n\n// Function to print the divisors \nvoid printDivisors(int n) \n{ \n\tfor (int i = 1; i <= n; i++) \n\t\tif (n % i == 0) \n\t\t\tcout <<\" \" << i; \n} \n\n// Driver code \nint main() \n{ \n\tcout <<\"The divisors of 100 are: \"; \n\tprintDivisors(100); \n\treturn 0; \n} \n\n// This code is contributed by shivanisinghss2110\n",
        "private_test": "SC_MODULE(Testbench) {\n    sc_signal<int> number_sig; // Signal for the number\n    sc_signal<sc_bv<10>> divisors_sig; // Signal for the divisors\n\n    // Instance of the DivisorPrinter module\n    DivisorPrinter divisor_printer_inst;\n\n    // Constructor\n    SC_CTOR(Testbench) : divisor_printer_inst(\"divisor_printer\") {\n        // Connect signals to ports\n        divisor_printer_inst.number(number_sig);\n        divisor_printer_inst.divisors(divisors_sig);\n\n        // Process to run tests\n        SC_THREAD(run_tests);\n    }\n\n    // Thread to run test cases\n    void run_tests() {\n        // Test case: Number 100\n        number_sig.write(100);\n        wait(1, SC_NS); // Wait for the divisor printer to process\n        cout << \"Divisors bit vector: \" << divisors_sig.read() << endl;\n\n        // Additional test case: Number 30\n        number_sig.write(30);\n        wait(1, SC_NS);\n        cout << \"Divisors bit vector: \" << divisors_sig.read() << endl;\n\n        // Print success message\n        cout << \"All tests completed successfully.\" << endl;\n\n        sc_stop(); // Stop the simulation\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); // Create an instance of the Testbench\n\n    // Start the simulation\n    sc_start();\n\n    return 0;\n}\n",
        "module_name": "DivisorPrinter"
    },
    {
        "task_id": 61,
        "task": "SearchanElementinanArray_LinearSearch.cpp",
        "code": "// C++ Program to implement linear search \n// algorithm iteratively\n#include <bits/stdc++.h>\nusing namespace std;\n\nint linearSearch(vector<int> v, int key) {\n      \n      // We test all the elements of the vector\n      // v against the given key\n      for (int i = 0; i < v.size(); i++) {\n      \n          // If the KEY IS FOUND\n          if (v[i] == key) {\n              return i;\n        }\n    }\n      \n      // Return some value denoting KEY NOT FOUND\n      return -1;\n}\n\nint main() {\n    vector<int> v = {1, 2, 3, 4, 5, 8, 9, 11};\n  \n    // Value to search\n      int key = 8;\n\n    // Searching the key in the vector v\n      int i = linearSearch(v, key);\n      \n      // Checking if element is found or not\n    if (i != -1)\n        cout << key << \" Found at Position: \" <<\n              i + 1;\n    else\n        cout << key << \" NOT found.\";\n    return 0;\n}\n",
        "private_test": "SC_MODULE(Testbench) {\n    sc_vector<sc_signal<int>> vec_sig;    // Signals for the vector elements\n    sc_signal<int> key_sig;               // Signal for the key\n    sc_signal<int> result_sig;            // Signal for the result\n\n    LinearSearchModule ls_inst;           // Instance of the LinearSearchModule\n\n    // Constructor\n    SC_CTOR(Testbench) : ls_inst(\"ls_inst\", 8) {\n        // Connect signals to module ports\n        ls_inst.vec_in(vec_sig);\n        ls_inst.key_in(key_sig);\n        ls_inst.result_out(result_sig);\n\n        // Initialize vector with given values\n        vec_sig[0].write(1);\n        vec_sig[1].write(2);\n        vec_sig[2].write(3);\n        vec_sig[3].write(4);\n        vec_sig[4].write(5);\n        vec_sig[5].write(8);\n        vec_sig[6].write(9);\n        vec_sig[7].write(11);\n\n        // Set key to search\n        key_sig.write(8);\n\n        // Process to run tests\n        SC_THREAD(run_tests);\n    }\n\n    // Thread to run test cases\n    void run_tests() {\n        // Wait for the linear search to complete\n        wait(1, SC_NS);\n\n        // Check the result\n        int result = result_sig.read();\n        if (result != -1) {\n            cout << \"Key \" << key_sig.read() << \" Found at Position: \" << result + 1 << endl;\n        } else {\n            cout << \"Key \" << key_sig.read() << \" NOT found.\" << endl;\n        }\n\n        // End simulation after successful test\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); // Create an instance of the Testbench\n\n    // Start the simulation\n    sc_start();\n\n    return 0;\n}\n",
        "module_name": "LinearSearchModule"
    },
    {
        "task_id": 62,
        "task": "ReverseaNumber.cpp",
        "code": "// C++ program to implement \n// the above approach \n#include <bits/stdc++.h> \nusing namespace std; \n\n// Iterative function to \n// reverse digits of num \nint reverseDigits(int num) \n{ \n\tint rev_num = 0; \n\twhile (num > 0) { \n\t\trev_num = rev_num * 10 + num % 10; \n\t\tnum = num / 10; \n\t} \n\treturn rev_num; \n} \n\n// Driver code \nint main() \n{ \n\tint num = 4562; \n\tcout << \"Reverse of num is \" << reverseDigits(num); \n\n\tgetchar(); \n\n\treturn 0; \n}\n",
        "private_test": "SC_MODULE(Testbench) {\n    sc_signal<int> num_sig;       // Signal for the input number\n    sc_signal<int> rev_num_sig;   // Signal for the reversed number\n\n    // Instance of the ReverseDigits module\n    ReverseDigits reverse_inst;\n\n    // Constructor: Initialize the module and run the test thread\n    SC_CTOR(Testbench)\n    : reverse_inst(\"reverse_inst\") {\n        // Connect signals to module ports\n        reverse_inst.num_in(num_sig);\n        reverse_inst.num_out(rev_num_sig);\n\n        // Create a test thread to provide stimulus and check the result\n        SC_THREAD(run_tests);\n    }\n\n    // Thread to run test cases\n    void run_tests() {\n        // Test case: num = 4562 (expected reversed number = 2654)\n        num_sig.write(4562);\n        wait(1, SC_NS); // Wait for the process to update\n        int result = rev_num_sig.read();\n        std::cout << \"Reverse of \" << num_sig.read() << \" is \" << result << std::endl;\n        assert(result == 2654);\n\n        // Additional test case: num = 12345 (expected reversed number = 54321)\n        num_sig.write(12345);\n        wait(1, SC_NS);\n        result = rev_num_sig.read();\n        std::cout << \"Reverse of \" << num_sig.read() << \" is \" << result << std::endl;\n        assert(result == 54321);\n\n        // End simulation after successful test\n        std::cout << \"All tests passed successfully.\" << std::endl;\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); // Instantiate the testbench module\n    sc_start();         // Start the simulation\n    return 0;\n}\n",
        "module_name": "ReverseDigits"
    },
    {
        "task_id": 63,
        "task": "MultiplyTwoMatrices.cpp",
        "code": "// C++ program to multiply two matrices\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Edit MACROs here, according to your Matrix Dimensions for\n// mat1[R1][C1] and mat2[R2][C2]\n#define R1 2 // number of rows in Matrix-1\n#define C1 2 // number of columns in Matrix-1\n#define R2 2 // number of rows in Matrix-2\n#define C2 3 // number of columns in Matrix-2\n\nvoid mulMat(int mat1[][C1], int mat2[][C2])\n{\n\tint rslt[R1][C2];\n\n\tcout << \"Multiplication of given two matrices is:\\n\";\n\n\tfor (int i = 0; i < R1; i++) {\n\t\tfor (int j = 0; j < C2; j++) {\n\t\t\trslt[i][j] = 0;\n\n\t\t\tfor (int k = 0; k < R2; k++) {\n\t\t\t\trslt[i][j] += mat1[i][k] * mat2[k][j];\n\t\t\t}\n\n\t\t\tcout << rslt[i][j] << \"\\t\";\n\t\t}\n\n\t\tcout << endl;\n\t}\n}\n\n// Driver code\nint main()\n{\n\t// R1 = 4, C1 = 4 and R2 = 4, C2 = 4 (Update these\n\t// values in MACROs)\n\tint mat1[R1][C1] = { { 1, 1 }, { 2, 2 } };\n\n\tint mat2[R2][C2] = { { 1, 1, 1 }, { 2, 2, 2 } };\n\n\tif (C1 != R2) {\n\t\tcout << \"The number of columns in Matrix-1 must \"\n\t\t\t\t\"be equal to the number of rows in \"\n\t\t\t\t\"Matrix-2\"\n\t\t\t<< endl;\n\t\tcout << \"Please update MACROs according to your \"\n\t\t\t\t\"array dimension in #define section\"\n\t\t\t<< endl;\n\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t// Function call\n\tmulMat(mat1, mat2);\n\n\treturn 0;\n}\n",
        "private_test": "SC_MODULE(Testbench) {\n    sc_signal<bool> clk;                  // Clock signal\n    sc_signal<bool> rst;                  // Reset signal\n    sc_signal<sc_uint<32>> mat1[2][2];    // Input matrix 1 (2x2)\n    sc_signal<sc_uint<32>> mat2[2][3];    // Input matrix 2 (2x3)\n    sc_signal<sc_uint<32>> result[2][3];   // Output matrix (2x3)\n\n    MatrixMultiplier multiplier_inst;     // Instance of the MatrixMultiplier module\n\n    // Constructor\n    SC_CTOR(Testbench) : multiplier_inst(\"multiplier\") {\n        // Connect signals to ports\n        multiplier_inst.clk(clk);\n        multiplier_inst.rst(rst);\n        for (int i = 0; i < 2; i++) {\n            for (int j = 0; j < 2; j++) {\n                multiplier_inst.mat1[i][j](mat1[i][j]);\n            }\n        }\n        for (int i = 0; i < 2; i++) {\n            for (int j = 0; j < 3; j++) {\n                multiplier_inst.mat2[i][j](mat2[i][j]);\n                multiplier_inst.result[i][j](result[i][j]);\n            }\n        }\n\n        // Process to generate clock\n        SC_THREAD(gen_clk);\n\n        // Process to run tests\n        SC_THREAD(run_tests);\n    }\n\n    // Thread to generate clock signal\n    void gen_clk() {\n        rst.write(true);\n        wait(5, SC_NS);\n        rst.write(false);\n        while (true) {\n            clk.write(false);\n            wait(1, SC_NS);\n            clk.write(true);\n            wait(1, SC_NS);\n        }\n    }\n\n    // Thread to run test cases\n    void run_tests() {\n        // Initialize matrices\n        mat1[0][0].write(1);\n        mat1[0][1].write(1);\n        mat1[1][0].write(2);\n        mat1[1][1].write(2);\n\n        mat2[0][0].write(1);\n        mat2[0][1].write(1);\n        mat2[0][2].write(1);\n        mat2[1][0].write(2);\n        mat2[1][1].write(2);\n        mat2[1][2].write(2);\n\n        // Wait for the multiplication to complete\n        wait(20, SC_NS);\n\n        // Print results\n        cout << \"Multiplication of given two matrices is:\" << endl;\n        for (int i = 0; i < 2; i++) {\n            for (int j = 0; j < 3; j++) {\n                cout << result[i][j].read() << \"\\t\";\n            }\n            cout << endl;\n        }\n\n        // End simulation\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); // Create an instance of the Testbench\n\n    // Start the simulation\n    sc_start();\n\n    return 0;\n}\n",
        "module_name": "MatrixMultiplier"
    },
    {
        "task_id": 64,
        "task": "MergeTwoArrays.cpp",
        "code": "// C++ program to merge two sorted arrays/ \n#include<bits/stdc++.h> \nusing namespace std; \n\nvoid mergeArrays(int arr1[], int arr2[], int n1, \n\t\t\t\t\t\t\tint n2, int arr3[]) \n{ \n\tint i = 0, j = 0, k = 0; \n\t// traverse the arr1 and insert its element in arr3 \n\twhile(i < n1){ \n\tarr3[k++] = arr1[i++]; \n\t} \n\t\t\n\t// now traverse arr2 and insert in arr3 \n\twhile(j < n2){ \n\tarr3[k++] = arr2[j++]; \n\t} \n\t\t\n\t// sort the whole array arr3 \n\tsort(arr3, arr3+n1+n2); \n} \n\n// Driver code \nint main() \n{ \n\tint arr1[] = {1, 3, 5, 7}; \n\tint n1 = sizeof(arr1) / sizeof(arr1[0]); \n\n\tint arr2[] = {2, 4, 6, 8}; \n\tint n2 = sizeof(arr2) / sizeof(arr2[0]); \n\n\tint arr3[n1+n2]; \n\tmergeArrays(arr1, arr2, n1, n2, arr3); \n\n\tcout << \"Array after merging\" <<endl; \n\tfor (int i=0; i < n1+n2; i++) \n\t\tcout << arr3[i] << \" \"; \n\n\treturn 0; \n} \n",
        "private_test": "SC_MODULE(Testbench) {\n    sc_clock clk;             // Clock signal\n    sc_signal<bool> rst_n;    // Reset signal (active low)\n    sc_signal<sc_uint<32>> n1;// Size of the first array\n    sc_signal<sc_uint<32>> n2;// Size of the second array\n    sc_signal<sc_uint<32>> arr1[100]; // First sorted array\n    sc_signal<sc_uint<32>> arr2[100]; // Second sorted array\n    sc_signal<sc_uint<32>> arr3[200]; // Merged and sorted array\n\n    MergeArrays merge_inst; // Instance of the MergeArrays module\n\n    // Constructor\n    SC_CTOR(Testbench) : merge_inst(\"merge_inst\"), clk(\"clk\", 10, SC_NS) {\n        // Connect signals to ports\n        merge_inst.clk(clk);\n        merge_inst.rst_n(rst_n);\n        merge_inst.n1(n1);\n        merge_inst.n2(n2);\n        for (int i = 0; i < 100; ++i) {\n            merge_inst.arr1[i](arr1[i]);\n            merge_inst.arr2[i](arr2[i]);\n        }\n        for (int i = 0; i < 200; ++i) {\n            merge_inst.arr3[i](arr3[i]);\n        }\n\n        // Process to run tests\n        SC_THREAD(run_tests);\n    }\n\n    // Thread to run test cases\n    void run_tests() {\n        // Initialize arrays\n        n1.write(4);\n        n2.write(4);\n        arr1[0].write(1); arr1[1].write(3); arr1[2].write(5); arr1[3].write(7);\n        arr2[0].write(2); arr2[1].write(4); arr2[2].write(6); arr2[3].write(8);\n\n        // Apply reset\n        rst_n.write(false);\n        wait(1, SC_NS);\n        rst_n.write(true);\n        wait(10, SC_NS); // Wait for the merge and sort to complete\n\n        // Print the merged and sorted array\n        cout << \"Array after merging:\" << endl;\n        for (int i = 0; i < 8; ++i) {\n            cout << arr3[i].read() << \" \";\n        }\n        cout << endl;\n\n        // End simulation\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); // Create an instance of the Testbench\n\n    // Start the simulation\n    sc_start();\n\n    return 0;\n}\n",
        "module_name": "MergeArrays"
    },
    {
        "task_id": 65,
        "task": "RemoveDuplicateElementsFromanArray.cpp",
        "code": "// Simple C++ program to remove duplicates \n#include <iostream> \nusing namespace std; \n\n// Function to remove duplicate \n// elements This function returns \n// new size of modified array. \nint removeDuplicates(int arr[], int n) \n{ \n\t// Return, if array is empty or \n\t// contains a single element \n\tif (n == 0 || n == 1) \n\t\treturn n; \n\n\tint temp[n]; \n\n\t// Start traversing elements \n\tint j = 0; \n\n\t// If current element is not equal \n\t// to next element then store that \n\t// current element \n\tfor (int i = 0; i < n - 1; i++) \n\t\tif (arr[i] != arr[i + 1]) \n\t\t\ttemp[j++] = arr[i]; \n\n\t// Store the last element as whether \n\t// it is unique or repeated, it hasn't \n\t// stored previously \n\ttemp[j++] = arr[n - 1]; \n\n\t// Modify original array \n\tfor (int i = 0; i < j; i++) \n\t\tarr[i] = temp[i]; \n\n\treturn j; \n} \n\n// Driver code \nint main() \n{ \n\tint arr[] = {1, 2, 2, 3, 4, \n\t\t\t\t4, 4, 5, 5}; \n\tint n = sizeof(arr) / sizeof(arr[0]); \n\n\t// RemoveDuplicates() returns \n\t// new size of array. \n\tn = removeDuplicates(arr, n); \n\n\t// Print updated array \n\tfor (int i = 0; i < n; i++) \n\t\tcout << arr[i] << \" \"; \n\n\treturn 0; \n} \n\n// This code is contributed by Aditya Kumar (adityakumar129)\n",
        "private_test": "SC_MODULE(Testbench) {\n    sc_signal<bool> clk;          // Clock signal\n    sc_signal<bool> rst;          // Reset signal\n    sc_signal<int> n;             // Size of the array\n    sc_signal<int> arr_in[9];      // Input array (fixed size for simplicity)\n    sc_signal<int> n_out;          // New size of the array\n    sc_signal<int> arr_out[9];     // Output array (fixed size for simplicity)\n\n    RemoveDuplicates remove_duplicates_inst;\n\n    SC_CTOR(Testbench) : remove_duplicates_inst(\"remove_duplicates_inst\") {\n        // Connect signals to ports\n        remove_duplicates_inst.clk(clk);\n        remove_duplicates_inst.rst(rst);\n        remove_duplicates_inst.n(n);\n        for (int i = 0; i < 9; ++i) {\n            remove_duplicates_inst.arr_in[i](arr_in[i]);\n            remove_duplicates_inst.arr_out[i](arr_out[i]);\n        }\n        remove_duplicates_inst.n_out(n_out);\n\n        // Process to run tests\n        SC_THREAD(run_tests);\n        sensitive << clk.posedge_event();\n    }\n\n    void run_tests() {\n        // Initialize clock and reset\n        clk = 0;\n        rst = 1;\n        wait(1, SC_NS);\n        rst = 0;\n        wait(1, SC_NS);\n\n        // Set input array and size\n        n = 9;\n        arr_in[0] = 1; arr_in[1] = 2; arr_in[2] = 2; arr_in[3] = 3;\n        arr_in[4] = 4; arr_in[5] = 4; arr_in[6] = 4; arr_in[7] = 5;\n        arr_in[8] = 5;\n\n        // Wait for the operation to complete\n        wait(1, SC_NS);\n\n        // Print updated array\n        for (int i = 0; i < n_out.read(); ++i) {\n            cout << arr_out[i].read() << \" \";\n        }\n        cout << endl;\n\n        // End simulation\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); // Create an instance of the Testbench\n\n    // Start the simulation\n    sc_start();\n\n    return 0;\n}\n",
        "module_name": "RemoveDuplicates"
    },
    {
        "task_id": 66,
        "task": "RemoveAllOccurrencesofanElementinanArray.cpp",
        "code": "// C++ program to remove all the \n// occurrences \n#include <iostream>\nusing namespace std;\n\nvoid remove_all_occurrence(int arr[],\n\t\t\t\t\t\tint target,\n\t\t\t\t\t\tint n)\n{\nint cnt = 0;\n\n// Counting all occurrence of \n// target element\nfor(int i = 0; i < n; i++)\n{\n\tif(arr[i] == target) \n\tcnt++;\n}\n\t\n// Creating new array of \n// size = original size - \n// no. of target element\nint new_arr[n - cnt];\nint ind = 0;\nfor(int i = 0; i < n; i++)\n{\n\tif(arr[i] != target)\n\t{\n\tnew_arr[ind] = arr[i];\n\tind++;\n\t}\n}\n\t\n// Printing the new array \nint m = (sizeof(new_arr) / \n\t\tsizeof(new_arr[0]));\nfor(int i = 0; i < m; i++)\n{\n\tcout << new_arr[i] << \" \"; \n}\nreturn;\n}\n\n// Driver code\nint main() \n{\nint arr[]={1, 4, 3, 6, 8,\n\t\t\t3, 9, 10, 3, 3, 7};\nint target = 3;\nint n = (sizeof(arr) / \n\t\tsizeof(arr[0]));\nremove_all_occurrence(arr, target, n);\nreturn 0;\n}\n",
        "private_test": "SC_MODULE(Testbench) {\n    sc_signal<sc_uint<32>> target; // Target element to remove\n    sc_signal<sc_uint<32>> arr_size; // Size of the input array\n    sc_vector<sc_signal<sc_uint<32>>> arr; // Input array\n    sc_vector<sc_signal<sc_uint<32>>> result; // Resulting array without target elements\n\n    RemoveOccurrences remove_occurrences_inst; // Instance of the RemoveOccurrences module\n\n    // Constructor\n    SC_CTOR(Testbench) : arr(\"arr\", arr_size), result(\"result\", arr_size),\n                         remove_occurrences_inst(\"remove_occurrences_inst\") {\n        // Connect signals to ports\n        remove_occurrences_inst.target(target);\n        remove_occurrences_inst.arr_size(arr_size);\n        for (int i = 0; i < arr_size.read(); i++) {\n            remove_occurrences_inst.arr[i](arr[i]);\n            remove_occurrences_inst.result[i](result[i]);\n        }\n\n        // Process to run tests\n        SC_THREAD(run_tests);\n    }\n\n    // Thread to run test cases\n    void run_tests() {\n        // Initialize the array and target\n        arr_size.write(11);\n        arr[0].write(1);\n        arr[1].write(4);\n        arr[2].write(3);\n        arr[3].write(6);\n        arr[4].write(8);\n        arr[5].write(3);\n        arr[6].write(9);\n        arr[7].write(10);\n        arr[8].write(3);\n        arr[9].write(3);\n        arr[10].write(7);\n        target.write(3);\n\n        // Wait for the process to complete\n        wait(1, SC_NS);\n\n        // Stop the simulation\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); // Create an instance of the Testbench\n\n    // Start the simulation\n    sc_start();\n\n    return 0;\n}\n",
        "module_name": "RemoveOccurrences"
    },
    {
        "task_id": 67,
        "task": "MultiplyTwoFloating-PointNumbers.cpp",
        "code": "// C++ program to multiply two \n// floating point numbers \n#include <iostream> \nusing namespace std; \n\n// Creating a user-defined function \n// called mul_floatnumbers that \n// multiplies the numbers passed to \n// it as an input. It gives you the \n// product of these numbers. \nfloat mul_floatnumbers(float a, float b) { return a * b; } \n\n// Driver code \nint main() \n{ \n\tfloat A = 1.2, B = 3.0, product; \n\n\t// Calling mul_floatnumbers function \n\tproduct = mul_floatnumbers(A, B); \n\n\t// Printing the output \n\tcout << product; \n\n\treturn 0; \n}\n",
        "private_test": "SC_MODULE(Testbench) {\n    sc_signal<float> a;       // Signal for the first number\n    sc_signal<float> b;       // Signal for the second number\n    sc_signal<float> product;  // Signal for the product\n\n    Multiplier multiplier_inst; // Instance of the Multiplier module\n\n    // Constructor\n    SC_CTOR(Testbench) : multiplier_inst(\"multiplier\") {\n        // Connect signals to ports\n        multiplier_inst.a(a);\n        multiplier_inst.b(b);\n        multiplier_inst.product(product);\n\n        // Process to run tests\n        SC_THREAD(run_tests);\n    }\n\n    // Thread to run test cases\n    void run_tests() {\n        // Test case: Multiplying 1.2 and 3.0\n        a = 1.2; b = 3.0;\n        wait(1, SC_NS); // Wait for the multiplier to process\n        float result = product.read();\n        cout << \"Product: \" << result << endl;\n\n        // End simulation after successful test\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); // Create an instance of the Testbench\n\n    // Start the simulation\n    sc_start();\n\n    return 0;\n}\n",
        "module_name": "Multiplier"
    },
    {
        "task_id": 68,
        "task": "BinarytoOctalConversion.cpp",
        "code": "// C++ program to convert octal to decimal\n#include <iostream>\nusing namespace std;\n\n// Function to convert octal \n// to decimal\nint octalToDecimal(int n)\n{\n\tint num = n;\n\tint dec_value = 0;\n\n\t// Initializing base value to 1, \n\t// i.e 8^0\n\tint base = 1;\n\n\tint temp = num;\n\twhile (temp) \n\t{\n\t\t// Extracting last digit\n\t\tint last_digit = temp % 10;\n\t\ttemp = temp / 10;\n\n\t\t// Multiplying last digit with \n\t\t// appropriate base value and adding \n\t\t// it to dec_value\n\t\tdec_value += last_digit * base;\n\n\t\tbase = base * 8;\n\t}\n\n\treturn dec_value;\n}\n\n// Driver code\nint main()\n{\n\tint num = 67;\n\n\tcout << octalToDecimal(num) << endl;\n}\n",
        "private_test": "SC_MODULE(Testbench) {\n    sc_signal<int> octal_input; // Signal for the octal number\n    sc_signal<int> decimal_output; // Signal for the decimal number\n\n    OctalToDecimalConverter converter_inst; // Instance of the converter module\n\n    // Constructor\n    SC_CTOR(Testbench) : converter_inst(\"converter\") {\n        // Connect signals to ports\n        converter_inst.octal_input(octal_input);\n        converter_inst.decimal_output(decimal_output);\n\n        // Process to run tests\n        SC_THREAD(run_tests);\n    }\n\n    // Thread to run test cases\n    void run_tests() {\n        // Test case 1: Octal 67\n        octal_input = 67;\n        wait(1, SC_NS); // Wait for the converter to process\n        assert(decimal_output.read() == 55);\n        cout << \"Octal 67 -> Decimal \" << decimal_output.read() << endl;\n\n        // Test case 2: Octal 123\n        octal_input = 123;\n        wait(1, SC_NS);\n        assert(decimal_output.read() == 83);\n        cout << \"Octal 123 -> Decimal \" << decimal_output.read() << endl;\n\n        // Test case 3: Octal 0\n        octal_input = 0;\n        wait(1, SC_NS);\n        assert(decimal_output.read() == 0);\n        cout << \"Octal 0 -> Decimal \" << decimal_output.read() << endl;\n\n        // Test case 4: Octal 10\n        octal_input = 10;\n        wait(1, SC_NS);\n        assert(decimal_output.read() == 8);\n        cout << \"Octal 10 -> Decimal \" << decimal_output.read() << endl;\n\n        // Print success message\n        cout << \"All tests passed successfully.\" << endl;\n\n        sc_stop(); // Stop the simulation\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); // Create an instance of the Testbench\n\n    // Start the simulation\n    sc_start();\n\n    return 0;\n}\n",
        "module_name": "OctalToDecimalConverter"
    },
    {
        "task_id": 69,
        "task": "AddTwoBinaryStrings.cpp",
        "code": "// C++ program to add two binary strings \n#include <bits/stdc++.h> \nusing namespace std; \n\n// This function adds two binary strings and return result as a third string \nstring addBinary(string A, string B) \n{ \n\t// If the length of string A is greater \n\t// than the length of B then just swap \n\t// the string by calling the same \n\t// function and make sure to return \n\t// the function otherwise recursion \n\t// will occur which leads to calling \n\t// the same function twice \n\tif (A.length() > B.length()) \n\t\treturn addBinary(B, A); \n\n\t// Calculating the difference between \n\t// the length of the two strings. \n\tint diff = B.length() - A.length(); \n\n\t// Initialise the padding string which \n\t// is used to store zeroes that should \n\t// be added as prefix to the string which \n\t// has length smaller than the other string. \n\tstring padding; \n\tfor (int i = 0; i < diff; i++) \n\t\tpadding.push_back('0'); \n\n\tA = padding + A; \n\tstring res; \n\tchar carry = '0'; \n\n\tfor (int i = A.length() - 1; i >= 0; i--) \n\t{ \n\t\t// This if condition solves 110 111 \n\t\t// possible cases \n\t\tif (A[i] == '1' && B[i] == '1') \n\t\t{ \n\t\t\tif (carry == '1') \n\t\t\t\tres.push_back('1'), carry = '1'; \n\t\t\telse\n\t\t\t\tres.push_back('0'), carry = '1'; \n\t\t} \n\n\t\t// This if condition solves 000 001 \n\t\t// possible cases \n\t\telse if (A[i] == '0' && B[i] == '0') \n\t\t{ \n\t\t\tif (carry == '1') \n\t\t\t\tres.push_back('1'), carry = '0'; \n\t\t\telse\n\t\t\t\tres.push_back('0'), carry = '0'; \n\t\t} \n\n\t\t// This if condition solves 100 101 010 \n\t\t// 011 possible cases \n\t\telse if (A[i] != B[i]) \n\t\t{ \n\t\t\tif (carry == '1') \n\t\t\t\tres.push_back('0'), carry = '1'; \n\t\t\telse\n\t\t\t\tres.push_back('1'), carry = '0'; \n\t\t} \n\t} \n\n\t// If at the end their is carry then just \n\t// add it to the result \n\tif (carry == '1') \n\t\tres.push_back(carry); \n\t// reverse the result \n\treverse(res.begin(), res.end()); \n\n\t// To remove leading zeroes \n\tint index = 0; \n\twhile (index + 1 < res.length() && \n\t\tres[index] == '0') \n\t\tindex++; \n\treturn (res.substr(index)); \n} \n\n// Driver code \nint main() \n{ \n\tstring a = \"1101\", b = \"100\"; \n\tcout << addBinary(a, b) << endl; \n\treturn 0; \n}\n",
        "private_test": "SC_MODULE(Testbench) {\n    sc_signal<std::string> a; // Signal for the first binary string\n    sc_signal<std::string> b; // Signal for the second binary string\n    sc_signal<std::string> sum; // Signal for the sum of the binary strings\n\n    BinaryAdder adder_inst; // Instance of the BinaryAdder module\n\n    // Constructor\n    SC_CTOR(Testbench) : adder_inst(\"adder\") {\n        // Connect signals to ports\n        adder_inst.A(a);\n        adder_inst.B(b);\n        adder_inst.sum(sum);\n\n        // Process to run tests\n        SC_THREAD(run_tests);\n    }\n\n    // Thread to run test cases\n    void run_tests() {\n        // Test case 1: Simple addition\n        a = \"1101\"; b = \"100\";\n        wait(1, SC_NS); // Wait for the adder to process\n        assert(sum.read() == \"10001\");\n        cout << \"Sum: \" << sum.read() << endl;\n\n        // Test case 2: Different lengths\n        a = \"1010\"; b = \"11010\";\n        wait(1, SC_NS);\n        assert(sum.read() == \"100100\");\n        cout << \"Sum: \" << sum.read() << endl;\n\n        // Test case 3: Leading zeros in result\n        a = \"0\"; b = \"0\";\n        wait(1, SC_NS);\n        assert(sum.read() == \"0\");\n        cout << \"Sum: \" << sum.read() << endl;\n\n        // Test case 4: Different values\n        a = \"1111\"; b = \"1\";\n        wait(1, SC_NS);\n        assert(sum.read() == \"10000\");\n        cout << \"Sum: \" << sum.read() << endl;\n\n        // Print success message\n        cout << \"All tests passed successfully.\" << endl;\n\n        sc_stop(); // Stop the simulation\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); // Create an instance of the Testbench\n\n    // Start the simulation\n    sc_start();\n\n    return 0;\n}\n",
        "module_name": "BinaryAdder"
    },
    {
        "task_id": 70,
        "task": "FindLargestAmong3Numbers.cpp",
        "code": "// C++ Program to find largest among three numbers using if-else-if ladder\n#include <iostream>\nusing namespace std;\n\nint main() {\n    int a = 1, b = 2, c = 11;\n\n    // Finding the largest by comparing using\n      // relational operators with if-else\n    if (a >= b) {\n        if (a >= c)\n            cout << a;\n        else\n            cout << c;\n    }\n    else {\n        if (b >= c)\n            cout << b;\n        else\n            cout << c;\n    }\n\n    return 0;\n}\n",
        "private_test": "SC_MODULE(Testbench) {\n    sc_signal<int> a; // Signal for the first number\n    sc_signal<int> b; // Signal for the second number\n    sc_signal<int> c; // Signal for the third number\n    sc_signal<int> largest; // Signal for the largest number\n\n    LargestFinder largest_finder_inst; // Instance of the LargestFinder module\n\n    // Constructor\n    SC_CTOR(Testbench) : largest_finder_inst(\"largest_finder\") {\n        // Connect signals to ports\n        largest_finder_inst.a(a);\n        largest_finder_inst.b(b);\n        largest_finder_inst.c(c);\n        largest_finder_inst.largest(largest);\n\n        // Process to run tests\n        SC_THREAD(run_tests);\n    }\n\n    // Thread to run test cases\n    void run_tests() {\n        // Test case 1: Basic test\n        a = 1; b = 2; c = 11;\n        wait(1, SC_NS); // Wait for the largest_finder to process\n        assert(largest.read() == 11);\n        cout << \"Largest: \" << largest.read() << endl;\n\n        // Test case 2: All numbers are the same\n        a = 5; b = 5; c = 5;\n        wait(1, SC_NS);\n        assert(largest.read() == 5);\n        cout << \"Largest: \" << largest.read() << endl;\n\n        // Test case 3: Two numbers are the same, one is larger\n        a = 7; b = 7; c = 8;\n        wait(1, SC_NS);\n        assert(largest.read() == 8);\n        cout << \"Largest: \" << largest.read() << endl;\n\n        // Test case 4: Two numbers are the same, one is smaller\n        a = 9; b = 9; c = 1;\n        wait(1, SC_NS);\n        assert(largest.read() == 9);\n        cout << \"Largest: \" << largest.read() << endl;\n\n        // Test case 5: All different numbers\n        a = 3; b = 15; c = 9;\n        wait(1, SC_NS);\n        assert(largest.read() == 15);\n        cout << \"Largest: \" << largest.read() << endl;\n\n        // Print success message\n        cout << \"All tests passed successfully.\" << endl;\n\n        sc_stop(); // Stop the simulation\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); // Create an instance of the Testbench\n\n    // Start the simulation\n    sc_start();\n\n    return 0;\n}\n",
        "module_name": "LargestFinder"
    },
    {
        "task_id": 71,
        "task": "FindtheTransposeofaMatrix.cpp",
        "code": "// C++ Program to find the transpose \n// of a matrix\n#include <bits/stdc++.h> \nusing namespace std; \n#define N 4\n\n// This function stores transpose \n// of A[][] in B[][]\nvoid transpose(int A[][N], \n\t\t\tint B[][N])\n{\n\tint i, j;\n\tfor (i = 0; i < N; i++)\n\t\tfor (j = 0; j < N; j++)\n\t\t\tB[i][j] = A[j][i];\n}\n\n// Driver code\nint main()\n{\n\tint A[N][N] = {{1, 1, 1, 1},\n\t\t\t\t{2, 2, 2, 2},\n\t\t\t\t{3, 3, 3, 3},\n\t\t\t\t{4, 4, 4, 4}};\n\n\tint B[N][N], i, j;\n\n\ttranspose(A, B);\n\n\tcout << \"Result matrix is \\n\";\n\tfor (i = 0; i < N; i++)\n\t{\n\t\tfor (j = 0; j < N; j++)\n\t\tcout << \" \" << B[i][j];\n\t\tcout <<\"\\n\";\n\t}\n\treturn 0;\n}\n",
        "private_test": "SC_MODULE(Testbench) {\n    // Signals for the input matrix A and output matrix B\n    sc_signal<int> A[N][N];\n    sc_signal<int> B[N][N];\n\n    // Instance of the MatrixTranspose module\n    MatrixTranspose transpose_inst;\n\n    // Constructor\n    SC_CTOR(Testbench) : transpose_inst(\"transpose_inst\") {\n        // Connect signals to module ports\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                transpose_inst.A[i][j](A[i][j]);\n                transpose_inst.B[i][j](B[i][j]);\n            }\n        }\n\n        // Process to run tests\n        SC_THREAD(run_tests);\n    }\n\n    // Thread to run test cases\n    void run_tests() {\n        // Initialize matrix A with predefined values\n        A[0][0] = 1; A[0][1] = 1; A[0][2] = 1; A[0][3] = 1;\n        A[1][0] = 2; A[1][1] = 2; A[1][2] = 2; A[1][3] = 2;\n        A[2][0] = 3; A[2][1] = 3; A[2][2] = 3; A[2][3] = 3;\n        A[3][0] = 4; A[3][1] = 4; A[3][2] = 4; A[3][3] = 4;\n\n        // Wait for the process to update\n        wait(1, SC_NS);\n\n        // Print the transposed matrix B\n        cout << \"Result matrix is \\n\";\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                cout << \" \" << B[i][j].read();\n            }\n            cout << \"\\n\";\n        }\n\n        // Stop the simulation\n        sc_stop();\n    }\n};\n\nint sc_main(int argc, char* argv[]) {\n    Testbench tb(\"tb\"); // Create an instance of the Testbench\n\n    // Start the simulation\n    sc_start();\n\n    return 0;\n}\n",
        "module_name": "MatrixTranspose"
    }
]